<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="description" content="My Programming Directory">
	<meta name="keywords" content="HTML , CSS , JS , Bootstrap">
	<meta name="author" content="George Levchenko">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>My Code Directory</title>
	<link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Dokdo" rel="stylesheet">
	<link rel="stylesheet" href="img/css/fontello.css">
	<link rel="stylesheet" href="styles/style_index.css">
	<link rel="stylesheet" href="styles/style_javascript.css">
</head>
<body>

<header>
	<h1 class="logo_big">Pro<span class="bold_black">-G-</span>running</h1>
	<h1 class="logo_small">Pro<span class="bold_black">-G-</span></h1>
</header>

<nav class="not_responsive">
	<ul class="left_side_nav  not_responsive">
		<li id="menu"><a href="#">&#9776</a></li>
		<li class="home_page not_responsive"><a href="index.html"><i class="icon-home"></i></a></li>
		<li class="html_page not_responsive"><a href="html.html">HTML</a></li>
		<li class="css_page not_responsive"><a href="css.html">CSS</a></li>
		<li class="bootstrap_page not_responsive"><a href="bootstrap.html">BootsTrap</a></li>
		<li class="javascript_page not_responsive" style="background: #000"><a href="#">JavaScript</a></li>
		<li class="typescript_page not_responsive"><a href="typescript.html">TypeScript</a></li>
		<li class="angular_page not_responsive"><a href="angular.html">Angular</a></li>
	</ul>

	<ul class="right_side_nav  not_responsive">
		<li class="practice_page not_responsive"><a href="practice.html">Practice</a></li>
		<li class="search_field" id="search_field_li">
			<input type="text" placeholder=" Enter Javascript Theme" id="search_field" onkeyup="searchJavascript()">
			<i class="icon-search"></i>
		</li>
	</ul>
</nav>

<main>
	<section class="left_side_anchors">
		<ul id="left_anchors">
			<li><a href="#variables">Variables</a></li>
			<li><a href="#types_of_data">Types of Data</a></li>
			<li><a href="#operators">Operators</a></li>
			<li><a href="#comparison_operators">Comparison Operators</a></li>
			<li><a href="#binary_operators">Binary Operators</a></li>
			<li><a href="#logical_operators">Logical Operators</a></li>
			<li><a href="#converting_of_types">Converting Of Types</a></li>
			<li><a href="#modal_windows">Modal Windows</a></li>
			<li><a href="#flow_statements">Flow Statements</a></li>
			<li><a href="#functions_part">Functions</a></li>
			<li><a href="#timeout_interval">Timeout/Interval</a></li>
			<li><a href="#number_methods">Number Methods</a></li>
			<li><a href="#string_methods">String Methods</a></li>
			<li><a href="#object_methods">Object Methods</a></li>
			<li><a href="#array_methods">Array Methods</a></li>
			<li><a href="#pseudo-array">Pseudo-Array</a></li>
			<li><a href="#date_object">Date Object</a></li>
			<li><a href="#map_object">Map Object</a></li>
			<li><a href="#set_object">Set Object</a></li>
			<li><a href="#visibility_of_var">Scope</a></li>
			<li><a href="#oop_functional">OOP Functional</a></li>
			<li><a href="#oop_prototype">OOP Prototype</a></li>
			<li><a href="#constructor_class">Constructor/Class</a></li>
			<li><a href="#json">JSON</a></li>
			<li><a href="#errors">Errors</a></li>
			<li class="global_table_anchor_top"><a href="#dom">DOM</a></li>
			<li><a href="#sizes_coordinates">Sizes/Coordinates</a></li>
			<li><a href="#events">Events</a></li>
		</ul>
	</section>
	<section class="main_text">

		<div class="table_row first_row zebra1">
			<div>
				<h2>Theme</h2>
			</div>
			<div>
				<h2>Description</h2>
			</div>
			<div>
				<h2>Example</h2>
			</div>
		</div>

		<!-- ---------------------------------------------------------Variables------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="variables">
			<h1>Variables</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>var</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Глобальная переменная(видна во всём документе) <br>
					-Видна и до объявления
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					b = 10; <br>
					vat b;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>let </p>
			</div>
			<div class="second_column table_column">
				<p>
					-Область видимости переменной let – блок {...} <br>
					-Переменная let видна только после объявления. <br>
					- При использовании в цикле, для каждой итерации создаётся своя переменная.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					if (true) { <br>
					  let apples = 10;<br>
					  alert(apples); // 10 (внутри блока)<br>
					}<br>
					alert(apples); // ошибка!<br>
                     <br>
					alert(a); // undefined <br>
					var a = 5; <br>
					<br>					
					let x; <br>
					let x; // ошибка: переменная x уже объявлена <br>
					<br>
					for(var i=0; i&lt;10; i++) { <br>
					alert(i); } 10
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>const </p>
			</div>
			<div class="second_column table_column">
				<p>
					Объявление const задаёт константу, то есть переменную, которую нельзя менять: <br>
					Переменная const – это константа, в остальном – как let.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					const apple = 5; <br>
					apple = 10; // ошибка
				</p>
			</div>
		</div>
	
		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					Array destructurization
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Деструктуризация (destructuring assignment) – это особый синтаксис присваивания, при котором можно присвоить массив или объект сразу нескольким переменным, разбив его на части. <br>

					Если значений в массиве меньше, чем переменных – ошибки не будет, просто присвоится undefined: <br>

					задают значение по умолчанию. Для этого нужно после переменной использовать символ = со значением <br>

					В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, даже включающие в себя вызовы функций:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let [firstName, lastName] = ["Илья", "Кантор"]; <br>
					 <br>
					alert(firstName); // Илья  <br>
					alert(lastName);  // Кантор <br>
					 <br>
					// первый и второй элементы не нужны <br>
					let [, , title] = "Юлий Цезарь Император Рима".split(" "); <br>
						 <br>
					alert(title); // Император <br>
					 <br>
					// значения по умолчанию <br>
					let [firstName="Гость", lastName="Анонимный"] = []; <br>
					 <br>
					// lastName получит значение, соответствующее текущей дате: <br>
					let [firstName, lastName=defaultLastName()] = ["Вася"];
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					Object destructurization
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Деструктуризацию можно использовать и с объектами. При этом мы указываем, какие свойства в какие переменные должны «идти». <br>
					let {var1, var2} = {var1: …, var2: …}; <br>
		
					Если хочется присвоить свойство объекта в переменную с другим именем, например, чтобы свойство options.width пошло в переменную w, то можно указать соответствие через двоеточие <br>
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let options = { <br>
					  title: "Меню", <br>
					  width: 100, <br>
					  height: 200 <br>
					}; <br>
					 <br>
					let {title, width, height} = options; <br>
					let {width: w, height: h, title} = options; <br>
					 <br>
					alert(title);  // Меню <br>
					alert(w);      // 100 <br>
					alert(h);      // 200 <br>

					let {width:w=100, height:h=200, title} = options; <br>
					 <br>
					alert(title);  // Меню <br>
					alert(w);      // 100 <br>
					alert(h);      // 200
				</p>
			</div>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p> … (spread)</p>
			</div>
			<div class="second_column table_column">
				<p>Если мы хотим получить и последующие значения массива, но не уверены в их числе – можно добавить ещё один параметр, который получит «всё остальное», при помощи оператора "..." («spread», троеточие):</p>
			</div>
			<div class="third_column table_column">
				<p>
					let [firstName, lastName, ...rest] = "Юлий Цезарь Император Рима".split(" "); <br>
					<br>
					alert(firstName); // Юлий <br>
					alert(lastName);  // Цезарь <br>
					alert(rest);      // Император,Рима (массив из 2х элементов)
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Types of Data------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="types_of_data">
			<h1>Type of Data</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>number</p>
			</div>
			<div class="second_column table_column">
				<p>
					В 64-бит формате. <br>
					-123 / 123.456 <br>
					- Infinity / -Infinity / NaN <br>
					-0xFF (255 в 16-тиричной) <br>
					- 3e5 (30 000 научный формат)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( 3e5 ); // 300000 <br>
					alert( 3e-5 ); // 0.00003 <br>
					alert( 12345 / 0 ); // Infinity <br>
					alert( Infinity + 5 == Infinity ); // true <br>
					alert( -1 / 0 ); // -Infinity <br>
					alert( 1e500 ); // Infinity <br>
					alert( 0 / 0 ); // NaN <br>
					NaN != NaN // Не ровняется <br>
					alert( NaN + 1 ); // NaN
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>string</p>
			</div>
			<div class="second_column table_column">
				<p>
					"моя строка" <br>
					"012345" <br>
					\ - экранирование символа <br>
					\n – пример спец символа <br>
					Unicode: <br>
					-Строчные буквы идут после заглавных, поэтому они всегда больше. <br>
					- Ряд букв, например ё, находятся вне основного алфавита. <br>
					str = `обратные кавычки`;  <br>
					- В них разрешён перевод строки. <br>
					-Можно вставлять выражения при помощи ${…}
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( 'Привет\nМир' ); // выведет "Мир" на новой строке <br>
					var str = ' символ \\ '; <br>
					alert( str ); // символ \ <br>
					alert(`моя <br>
					  многострочная <br>
					  строка`); <br>
					   <br>
					let apples = 2; <br>
					let oranges = 3; <br>
					alert(`${apples} + ${oranges} = ${apples + oranges}`); // 2 + 3 = 5
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>boolean</p>
			</div>
			<div class="second_column table_column">
				<p>true / false</p>
			</div>
			<div class="third_column table_column">
				<p>
					var accept = true; <br>
					var decline = false;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>null</p>
			</div>
			<div class="second_column table_column">
				<p> «значение неизвестно»</p>
			</div>
			<div class="third_column table_column">
				<p>
					var escape = null;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>undefined</p>
			</div>
			<div class="second_column table_column">
				<p>«значение не присвоено»</p>
			</div>
			<div class="third_column table_column">
				<p>
					var unknown; // undefined
					var unknown = undefined;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>object</p>
			</div>
			<div class="second_column table_column">
				<p>{}, [], date, function(){}</p>
			</div>
			<div class="third_column table_column">
				<p>
					var obj = {};
					var arr = [];
					var date = new Date();
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>symbol</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Символы – новый примитивный тип, предназначенный для уникальных идентификаторов. <br>
					- Все символы уникальны. Символы с одинаковым именем не равны друг другу. <br>
					- Существует глобальный реестр символов, доступных через метод Symbol.for("name"). Для глобального символа можно получить имя вызовом Symbol.keyFor(sym).
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let sym = Symbol(); <br>
					let sym = Symbol("name"); <br>
					alert( sym.toString() ); // Symbol(name)
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Operators------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="operators">
			<h1>Operators</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Binary «+»</p>
			</div>
			<div class="second_column table_column">
				<p>Если хотя бы один аргумент является строкой, то второй будет также преобразован к строке!</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( '1' + 2 ); // "12" <br>
					alert( 2 + '1' ); // "21" <br>
					alert( 2 - '1' ); // 1 <br>
					alert( 6 / '2' ); // 3
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Unary «+»</p>
			</div>
			<div class="second_column table_column">
				<p>Преобразование к числу</p>
			</div>
			<div class="third_column table_column">
				<p>
					var apples = "2"; <br>
					var oranges = "3"; <br>
					alert(+apples + +oranges); - 5 <br>
					 <br>
					alert( +"12test" ); // NaN <br>
					alert( +"  -12" ); // -12 <br>
					alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом <br>
					alert( +"" ); // 0, пустая строка становится нулем <br>
					alert( +"1 2" ); // NaN, пробел посередине числа – ошибка <br>
					alert(+new Date) // милисекунды
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>«%»</p>
			</div>
			<div class="second_column table_column">
				<p>Взятие остатка</p>
			</div>
			<div class="third_column table_column">
				<p>alert( 5 % 2 ); - 1</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>«++»</p>
			</div>
			<div class="second_column table_column">
				<p>Инкримент Увеличение на 1</p>
			</div>
			<div class="third_column table_column">
				<p>
					Постфиксная форма i++: <br>
					var i = 0; <br>
					alert( i++ ); // 0 <br>
					alert( i ); // 1 <br>
					Префиксная форма  ++i: <br>
					var i = 0; <br>
					alert( ++i ); // 1 <br>
					alert( i ); // 1
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>«--»</p>
			</div>
			<div class="second_column table_column">
				<p>Декремент Уменьшение на 1</p>
			</div>
			<div class="third_column table_column">
				<p>
					Постфиксная форма i++: <br>
					var i = 0; <br>
					alert( i++ ); // 0 <br>
					alert( i ); // 1 <br>
					Префиксная форма  ++i: <br>
					var i = 0; <br>
					alert( ++i ); // 1 <br>
					alert( i ); // 1
				</p>
			</div>
		</div>


		<div class="tips_table_row zebra1">
			<div class="second_column table_column">
				<h2>Tips:</h2>
				<p>
					Сокращённая форма арифметика с присваиванием
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					n += 5; (n = n+5) <br>
					n *= 2; (n = n*2)
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Comparison_Operators------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="comparison_operators">
			<h1>Comparison Operators</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p> > , < , >=, <=, ==, !=, ==, ===, !== </p>
			</div>
			<div class="second_column table_column">
				<p>Возвращают true/false</p>
			</div>
			<div class="third_column table_column">
				<p>
					var a = 1;
					var b = 2;
					a < b == true;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>=== , !==</p>
			</div>
			<div class="second_column table_column">
				<p>Строгое сравнение</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( false == 0 );true, <br>
					alert( true == 1 );true,  <br>
					alert( false === 0 );false,
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>string > string</p>
			</div>
			<div class="second_column table_column">
				<p>Строки сравниваются побуквенно, относительно кодировки Unicode</p>
			</div>
			<div class="third_column table_column">
				<p>
					'а' > 'Я' <br>
					'Б' > 'А' <br>
					'Вася' > 'Ваня' <br>
					'Привет' > 'Прив' <br>
					"2" > "14"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>string > number</p>
			</div>
			<div class="second_column table_column">
				<p>Приводится к числу</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( '2' > 1 ); // true <br>
					alert( '01' == 1 );
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>null & undefined</p>
			</div>
			<div class="second_column table_column">
				<p>Лучше не сравнивать во избежании ошибок</p>
			</div>
			<div class="third_column table_column">
				<p>
					+null == 0 <br>
					+undefined == NaN <br>
					null == undefined <br>
					null > 0 , false <br>
					null == 0 , false <br>
					null >= 0 , true <br>
					undefined > 0 , false <br>
					undefined < 0 , false <br>
					undefined == 0 , false
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Binary_Operators------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="binary_operators">
			<h1>Binary Operators</h1>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					Побитовые операторы работают следующим образом: <br>
					1.	Операнды преобразуются в 32-битные целые числа, представленные последовательностью битов. Дробная часть, если она есть, отбрасывается. <br>
					2.	Для бинарных операторов – каждый бит в первом операнде рассматривается вместе с соответствующим битом второго операнда: первый бит с первым, второй со вторым и т.п. Оператор применяется к каждой паре бит, давая соответствующий бит результата. <br>
					3.	Получившаяся в результате последовательность бит интерпретируется как обычное число.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					9 (по осн. 10) <br>
					  = 00000000000000000000000000001001 (по осн. 2) <br>
					14 (по осн. 10) <br>
					  = 00000000000000000000000000001110 (по осн. 2) <br>
					  <br>
					14 & 9 (по осн. 10) <br>
					  = 00000000000000000000000000001000 (по осн. 2) <br>
					  = 8 (по осн. 10)
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>a & b</p>
			</div>
			<div class="second_column table_column">
				<p>Побитовое И (AND)</p>
			</div>
			<div class="third_column table_column">
				<p>
					a    b    a & b <br>
					0    0      0  <br>
					0    1      0 <br>
					1    0      0 <br>
					1    1      1

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>a | b</p>
			</div>
			<div class="second_column table_column">
				<p>Побитовое ИЛИ (OR)</p>
			</div>
			<div class="third_column table_column">
				<p>
					a    b    a | b <br>
					0    0      0 <br>
					0    1      1 <br>
					1    0      1 <br>
					1    1      1
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>a ^ b</p>
			</div>
			<div class="second_column table_column">
				<p>Побитовое исключающее ИЛИ (XOR)</p>
			</div>
			<div class="third_column table_column">
				<p>
					a    b    a ^ b <br>
					0    0      0 <br>
					0    1      1 <br>
					1    0      1 <br>
					1    1      0
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>~a</p>
			</div>
			<div class="second_column table_column">
				<p>Побитовое НЕ (NOT)</p>
			</div>
			<div class="third_column table_column">
				<p>
					a     ~a <br>
					0      1  <br>
					1      0 
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>a << b</p>
			</div>
			<div class="second_column table_column">
				<p>
					Левый сдвиг<br>
					(примерно равен *2)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					9 (по осн.10) <br>
					  = 00000000000000000000000000001001 (по осн.2) <br>
					9 << 2 (по осн.10) <br>
					  = 00000000000000000000000000100100 (по осн.2) <br>
					  = 36 (по осн.10)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>a >> b</p>
			</div>
			<div class="second_column table_column">
				<p>
					Правый сдвиг, переносящий знак <br>
					(примерно равен /2)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					-9 (по осн.10) <br>
					  = 11111111111111111111111111110111 (по осн.2)  <br>                 
					-9 >> 2 (по осн.10) <br>
					  = 11111111111111111111111111111101 (по осн.2) = -3 (по осн.10) 
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>a >>> b</p>
			</div>
			<div class="second_column table_column">
				<p>Правый сдвиг с заполнением нулями</p>
			</div>
			<div class="third_column table_column">
				<p>
					-9 (по осн.10) <br>
					  = 11111111111111111111111111110111 (по осн.2) <br>
					-9 >>> 2 (по осн.10) <br>
					  = 00111111111111111111111111111101 (по осн.2) <br>
					  = 1073741821 (по осн.10)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>parseInt("11000", 2)</p>
			</div>
			<div class="second_column table_column">
				<p>переводит строку с двоичной записью числа в число.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var access = parseInt("11000", 2); === 24
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>n.toString(2)</p>
			</div>
			<div class="second_column table_column">
				<p>получает для числа n запись в 2-ной системе в виде строки.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var access2 = access.toString(2); === 11000
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					~~number  <br>
					number^0
				</p>
			</div>
			<div class="second_column table_column">
				<p>округление</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( ~~12.345 ); // 12 <br>
					alert( 12.345 ^ 0 ); // 12
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>~n</p>
			</div>
			<div class="second_column table_column">
				<p>
					Проверка на -1: <br>
					~n = -(n+1) <br>
					~n == 0 <br>
					n == -1
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var n = -1; <br>
					if (~n) {  <br>
					  alert( "...ничего не выведет..." );}
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Logical_Operators------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="logical_operators">
			<h1>Logical Operators</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>|| (OR)</p>
			</div>
			<div class="second_column table_column">
				<p>
					result = a || b; <br>
					- Возвращает true/false <br>
					- Сводит значение a и b, к логическому типу 
					1 - True; 0 - False; <br>
					- Работает до первого True, дальше не считает и возвращает его значение <br>
					- Если все False, выводит последнее значение
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( true || true ); // true <br>
					alert( false || true ); // true <br>
					alert( true || false ); // true <br>
					alert( false || false ); // false <br>
					alert( true || 'неважно что' ); // true <br>
					alert( null || 1 ); // 1 <br>
					alert( undefined || '' || false || 0 ); // 0
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>&& (AND)</p>
			</div>
			<div class="second_column table_column">
				<p>
					result = a && b; <br>
					- Возвращает true/false <br>
					- Сводит значение a и b, к логическому типу
					1 - True; 0 - False; <br>
					- Работает до первого False, дальше не считает и возвращает его значение <br>
					- Если все True, выводит последнее значение <br>
					- Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( true && true ); // true <br>
					alert( false && true ); // false <br>
					alert( true && false ); // false <br>
					alert( false && false ); // false <br>
					alert( 1 && 5 ); // 5 <br>
					alert( null && 5 ); // null <br>
					alert( 0 && "не важно" ); // 0
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>! (NOT)</p>
			</div>
			<div class="second_column table_column">
				<p>
					var result = !value; <br>
					- Возвращает true/false <br>
					- Сводит значение a и b, к логическому типу
					1 - True; 0 - False; <br>
					- Возвращает противоположное значение
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( !true ); // false <br>
					alert( !0 ); // true
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					!!string <br>
					!!number <br>
					!!null …
				</p>
			</div>
			<div class="second_column table_column">
				<p>двойное НЕ используют для преобразования значений к логическому типу:</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( !!"строка" ); // true <br>
					alert( !!null ); // false 
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Converting of Types------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="converting_of_types">
			<h1>Converting of Types</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>String(val)</p>
			</div>
			<div class="second_column table_column">
				<p>Преобразует в строку</p>
			</div>
			<div class="third_column table_column">
				<p>
					var string = String(null); === "null" <br>
					Аналог: <br>
					alert( true + "test" ); // "truetest" <br>
					alert( "123" + undefined ); // "123undefined"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Number(val)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Преобразует в число <br>
					 <br>
					undefined – NaN <br>
					null – 0 <br>
					true/false – 1/0 <br>
					Строка - Пробельные символы по краям обрезаются. <br>
					Далее, если остаётся пустая строка, то 0, иначе из непустой строки "считывается" число, при ошибке результат NaN.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var a = Number("123"); === 123 <br>
					"\n0 " == 0 <br>
					"\n" == false == 0 <br>
					"1" == true == 1 <br>
					Аналог: <br>
					var a = +"123";
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Boolean(val)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Преобразует в Boolean <br>
					 <br>
					Undefined,null – false <br>
					числа – все true, кроме: 0 , Nan - False  <br>
					Строки - Все true, кроме: пустой строки "" – false  <br>
					Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var a = Boolean("123"); === true <br>
					Аналог: <br>
					!!"0" == true <br>
					!!"  " == true <br>
					!!"" == false
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>typeof</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает тип аргумента</p>
			</div>
			<div class="third_column table_column">
				<p>
					typeof undefined -"undefined" <br>
					typeof 0 -"number" <br>
					typeof true -"boolean" <br>
					typeof "foo" -"string" <br>
					typeof {} -"object" <br>
					typeof null -"object" – ошибка языка <br>
					typeof function(){} -"function" – удобство <br>
					typeof sym // symbol
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>[[class]] </p>
			</div>
			<div class="second_column table_column">
				<p>Для встроенных объектов мы можем получить тип из скрытого свойства [[Class]], при помощи вызова {}.toString.call(obj).slice(8, -1). Для конструкторов, которые объявлены нами, [[Class]] всегда равно "Object".</p>
			</div>
			<div class="third_column table_column">
				<p>
					var toString = {}.toString; <br>
					var arr = [1, 2]; <br>
					alert( toString.call(arr) ); // [object Array] <br>
					var date = new Date; <br>
					alert( toString.call(date) ); // [object Date] <br>
					var user = { name: "Вася" }; <br>
					alert( toString.call(user) ); // [object Object] <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>"Duck typing"</p>
			</div>
			<div class="second_column table_column">
				<p>Смысл утиной типизации – в проверке необходимых методов и свойств.</p>
			</div>
			<div class="third_column table_column">
				<p>
					if (something.splice) {  <br>
					  alert( 'Это утка! То есть, массив!' ); }  <br>
					if (x.getTime) {  <br>
					  alert( 'Дата!' ); }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Array.isArray(arr)</p>
			</div>
			<div class="second_column table_column">
				<p>Он возвращает true только если arr – массив:</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( Array.isArray([1,2,3]) ); // true <br>
					alert( Array.isArray("not array")); // false
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>instanceof</p>
			</div>
			<div class="second_column table_column">
				<p>позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.</p>
			</div>
			<div class="third_column table_column">
				<p>
					function User() {} <br>
					<br>
					var user = new User();<br>
					alert( user instanceof User ); // true
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Modal Windows------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="modal_windows">
			<h1>Modal Windows</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>alert</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Модальное окно c кнопкой ОК <br>
					-Ничего не возвращает
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( "Привет" );
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>prompt</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Модальное окно c кнопкой ОК и Сancel <br>
					-prompt(title, default); <br>
					title – заголовок <br>
					default – строка по умолчанию. <br>
					-Возвращает String <br>
					-Cancel/ESC === null
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var test = prompt("Тест", '');
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>confirm</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Модальное окно c кнопкой ОК и Сancel <br>
					-confirm(question); <br>
					- Возвращает <br>
					OK - true / Cancel - false
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var isAdmin = confirm("Вы - администратор?");
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Flow Statements------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="flow_statements">
			<h1>Flow Statements</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>if () {}</p>
			</div>
			<div class="second_column table_column">
				<p>
					if (условие) { <br>
						  // код <br>
						} <br>
					- Преобразует к логическому типу <br>
					- Работает только если True <br>
					- Число 0, пустая строка "", null и undefined, а также NaN являются false,
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					if (0) { Никогда не сработает } <br>
					if (1) { Всегда работает } <br>
					<br> 
					var cond = (year != 2011);
					true/false <br>
					if (cond) {}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					if () { <br>
					}  else {}
				</p>
			</div>
			<div class="second_column table_column">
				<p>Необязательный блок else («иначе») выполняется, если условие неверно:</p>
			</div>
			<div class="third_column table_column">
				<p>
					if (year == 2011) { <br>
						  alert( 'Да вы знаток!' ); <br>
						} else { <br>
						  alert( 'А вот и неправильно!' ); любое значение, кроме 2011 }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					if () { <br>
					}  else if { <br>
					}  else {}
				</p>
			</div>
			<div class="second_column table_column">
				<p>нужно проверить несколько вариантов условия.</p>
			</div>
			<div class="third_column table_column">
				<p>
					if (year < 2011) { <br>
					  alert( 'Это слишком рано..' ); <br>
					} else if (year > 2011) { <br>
					  alert( 'Это поздновато..' ); <br>
					} else { <br>
					  alert( 'Да, точно в этом году!' );}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>

					condition ? (true) : (false)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Тернарный оператор:
					condition ? value1 : value2
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					access = (age > 14) ? true : false; <br>
					<br> 
					if (age > 14) { <br>
					  access = true; <br>
					} else { <br>
					  access = false; <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					condition1  ? (true) : <br>
					condition2  ? (true) : <br>
					condition3  ? (true) : (false) <br>
				</p>
			</div>
			<div class="second_column table_column">
				<p>Несколько тернарных операторов</p>
			</div>
			<div class="third_column table_column">
				<p>
					var message = (age < 3) ? 'Здравствуй, малыш!' : <br>
					  (age < 18) ? 'Привет!' : <br>
					  (age < 100) ? 'Здравствуйте!' : <br>
					  'Какой необычный возраст!'; <br>

					if (age < 3) { <br>
					  message = 'Здравствуй, малыш!'; <br>
					} else if (age < 18) { <br>
					  message = 'Привет!'; <br>
					} else if (age < 100) { <br>
					  message = 'Здравствуйте!';<br>
					} else {  <br>
					  message = 'Какой необычный возраст!'; <br>
					} <br> <br>

					let r = number1 !== undefined ? number2 !== undefined ? 300 : 100 : 200; <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>while() {}</p>
			</div>
			<div class="second_column table_column">
				<p>
					while (условие) { <br>
					  // код, тело цикла <br>
					} <br>
					-Преобразует к логическому типу <br>
					- Работает пока True <br>
					- Число 0, пустая строка "", null и undefined, а также NaN являются false, <br>
					- каждое повторение цикла называется – «итерация»
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					while (true) { <br>
					  // бесконечный цикл <br>
					} <br>
					var i = 3; <br>
					while (i) { // при i, равном 0, значение в скобках будет false и цикл остановится <br>
					  alert( i ); <br>
					  i--; <br>
					}
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>do {} while ();</p>
			</div>
			<div class="second_column table_column">
				<p>
					do { <br>
					  // тело цикла <br>
					} while (условие);
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var i = 0; <br> 
					do { <br>
					  alert( i ); <br>
					  i++; }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>for() {}</p>
			</div>
			<div class="second_column table_column">
				<p>
					for (начало; условие; шаг) { <br>
					  // ... тело цикла ...<br>
					}<br>
					-Начало: i=0.<br>
					-Условие: i&lt3.<br>
					-Шаг: i++.<br>
					-Тело: alert(i)<br>
					-Цикл выполняется так:<br>
					1.	Начало: i=0 выполняется один-единственный раз, при заходе в цикл.<br>
					2.	Условие: i&lt3 проверяется перед каждой итерацией и при входе в цикл, если оно нарушено, то происходит выход.<br>
					3.	Тело: alert(i).<br>
					4.	Шаг: i++ выполняется после тела на каждой итерации, но перед проверкой условия.<br>
					5.	Идти на шаг 2.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					for (var i = 0; i < 3; i++) { <br>
					  alert( i ); <br>
					} <br>
					for (;;) { <br>
					  // будет выполняться вечно <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>break</p>
			</div>
			<div class="second_column table_column">
				<p>Выйти из цикла можно не только при проверке условия но и, вообще, в любой момент. Эту возможность обеспечивает директива break.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var sum = 0; <br>
					while (true) { <br>
					var value = +prompt("Введите число", ''); <br>
					  if (!value) break; // (*) <br>
					  sum += value; <br>
					 } <br>
					alert( 'Сумма: ' + sum );
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>continue</p>
			</div>
			<div class="second_column table_column">
				<p>Директива continue прекращает выполнение текущей итерации цикла.</p>
			</div>
			<div class="third_column table_column">
				<p>
					for (var i = 0; i < 10; i++) { <br>
					  if (i % 2 == 0) continue; <br>
					  alert(i); <br>
					} 
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Tags for break/continue</p>
			</div>
			<div class="second_column table_column">
				<p>
					"имя:" – перед циклом <br>
					Когда нужно выйти одновременно из нескольких уровней цикла.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					outer: for (var i = 0; i < 3; i++) { <br>
					  for (var j = 0; j < 3; j++) { <br>
					    var input = prompt('Значение в координатах '+i+','+j, ''); <br>
					    if (!input) break outer; // (*) <br>
					  } <br>
					} <br>
					alert('Готово!');
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>switch () {}</p>
			</div>
			<div class="second_column table_column">
				<p>
					switch(x) { <br>
					  case 'value1':  // if (x === 'value1') <br>
					    ... <br>
					    [break] <br>
					  case 'value2':  // if (x === 'value2') <br>
					    ... <br>
					    [break] <br>
					  default: <br>
					    ... <br>
					    [break] <br>
					} <br>
					-Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее. <br>
					-Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch). <br>
					-Если ни один case не совпал – выполняется (если есть) вариант default.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var a = 2 + 2;  <br>
					switch (a) {  <br>
					  case 3: <br>
					    alert( 'Маловато' ); <br>
					    break; <br>
					  case 4: <br>
					    alert( 'В точку!' ); <br>
					    break; <br>
					  case 5: <br>
					    alert( 'Перебор' ); <br>
					    break; <br>
					  default: <br>
					    alert( 'Я таких значений не знаю' ); <br>
					} <br>
   					 <br>
					Групировка case: <br>
					switch (a) { <br>
					  case 4: <br>
					    alert('Верно!'); <br>
					    break; <br>
						 <br>
					  case 3:    <br>                 
					  case 5:   <br>                  
					    alert('Неверно!'); <br>
					    alert('Немного ошиблись, бывает.'); <br>
					    break; <br>
						 <br>
					  default: <br>
					    alert('Странный результат, очень странный'); <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>for..of</p>
			</div>
			<div class="second_column table_column">
				<p>Для перебора итерируемых объектов</p>
			</div>
			<div class="third_column table_column">
				<p>
					let arr = [1, 2, 3]; // массив — пример итерируемого объекта <br>
						 <br>
					for (let value of arr) { <br>
					  alert(value); // 1, затем 2, затем 3 <br>
					} <br>
					 <br>
					for (let char of "Привет") { <br>
					  alert(char); // Выведет по одной букве: П, р, и, в, е, т <br>
					}
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Functions------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="functions_part">
			<h1>Functions</h1>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>function () {}</p>
			</div>
			<div class="second_column table_column">
				<p>
					function name(param) { <br>
					body; <br>
					} <br>
					-Param – список параметров, копируется в локальные переменные. Если параметр не задан, он считается undefined. Необязательные в конце <br>
					- var объявленный в нутрии функции – это локальная переменная и виден только в ней 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function showMessage() {  <br>
					  alert( 'Привет всем присутствующим!' );  <br>
					}  <br>
					showMessage();  <br>
					 <br>
					function showMessage(from, text) {  <br>
					  if (text === undefined) {  <br>
					    text = 'текст не передан';  <br>
					  }  <br>
					  alert( from + ": " + text );  <br>
					} <br>
					showMessage("Маша", "Привет!"); // Маша: Привет! <br>
					showMessage("Маша"); // Маша: текст не передан
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>return</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Для возврата значения либо просто выхода из функции <br>

					-Она может находиться в любом месте функции. Как только до неё доходит управление – функция завершается и значение передается обратно. <br>

					-В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function calcD(a, b, c) { <br>
					   return b*b - 4*a*c; <br>
					} <br>
					function doNothing() { <br>
					  return; <br>
					}
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					1. Вызов функции без скобок – выводил код функции <br>
					2. Можно копировать код функции в другие переменные и снова запускать уже через новую переменную <br>
					3. Запуск функции с двумя парами скобок ()() <br>
					 <br>
					Types of function declaration: <br>
					1. Function Declaration – function sayHi(){}
					 Создаются до выполнения кода. <br>
					2. Function Expression – var sayHi() = function(){}
					 Создаются по ходу выполнения кода и записываются в переменную. <br>
					2.5 Named Function Exression (NFE) - var f = function sayHi(...) { } <br>
					Внутреннее имя позволяет функции надёжно обращаться к самой себе, где бы она ни находилась. При рекурсии к примеру. <br>
					Внутреннее имя видно только изнутри функции f. <br>
					3. Anon function -  function(){}
					  Функциональное выражение, которое не записывается в переменную. <br>
					4. new Function - new Function(params, code);
					  Cоздаёт функцию полностью «на лету» из строки
					  Params - Параметры функции через запятую в виде строки. <br>
					  Code - Код функции в виде строки. <br>
					5. Функции-стрелки - (args) => expr
					-Без фигурных скобок возвращают выражение expr: (args) => expr. <br>
					-С фигурными скобками требуют явного return. <br>
					-Не имеют своих this и arguments, при обращении получают их из окружающего контекста. <br>
					-Не могут быть использованы как конструкторы, с new.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					1. <br>
					 function sayHi() { <br>
					  alert( "Привет" ); <br>
					} <br>
					alert( sayHi ); // выведет код функции <br>
					2. <br>
					var func = sayHi;    // (2) <br>
					func(); // Привет    // (3) <br>
					3.  <br>
					function sum(a) { <br>
					  return function(b) { <br>
					    return a + b; //  <br>
					  }; <br>
					} <br>
					alert( sum(1)(2) ); <br>
					alert( sum(5)(-1) ); <br>
						 <br>
					Types: <br>
					1. function sum(a, b) { <br>
					  return a + b; <br>
					} <br>

					2. var sum = function(a, b) { <br>
					  return a + b; <br>
					} <br>
					2.5 var f = function factorial(n) { <br>
					  return n ? n*factorial(n-1) : 1; <br>
					}; <br>

					3.  function() { alert("Вы согласились."); }, <br>
					  function() { alert("Вы отменили выполнение."); } <br>

					4. var sum = new Function('a,b', ' return a+b; '); <br>
					var result = sum(1, 2); <br>
					alert( result ); // 3 <br>

					5. let sum = (a,b) => a + b; <br>

					let inc = x => x+1; <br>

					 showList: function() {   this.students.forEach( <br>
					      student => alert(this.title + ': ' + student) ) <br>
					  }
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra1">
			<div class="second_column table_column">
				<h2>ES-2015 Tips:</h2>
				<p>
					- Можно указывать параметры по умолчанию через равенство =
					Параметр по умолчанию используется при отсутствующем аргументе или равном undefined<br>
					Параметры по умолчанию могут быть не только значениями, но и выражениями.<br>

					- Оператор spread вместо arguments
					В  rest попадёт массив всех аргументов, начиная с третьего.<br>

					- Деструктуризация в параметрах.
					Если функция получает объект, то она может его тут же разбить в переменные:<br>

					-В свойстве name у функции находится её имя.
					function f() {} // f.name == "f"<br>

					- Объявление функции Function Declaration, сделанное в блоке, видно только в этом блоке.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					function showMenu(title = "Без заголовка", width = 100, height = 200) { <br>
					  alert(title + ' ' + width + ' ' + height); <br>
					} <br>

					function showName(firstName, lastName, ...rest) { <br>
					  alert(firstName + ' ' + lastName + ' - ' + rest); <br>

					function showMenu({title="Заголовок", width:w=100, height:h=200}) { <br>
					  alert(title + ' ' + w + ' ' + h); <br>
					}
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Tips:</h2>
				<p>
					Рекурсия -  это когда функция вызывает сама себя, как правило, с другими аргументами. <br>
					У каждого вызова функции есть свой «контекст выполнения» (execution context). <br>
					При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов». <br>
					Любая рекурсия может быть переделана в цикл. Как правило, вариант с циклом будет эффективнее.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					function pow(x, n) { <br>
					  if (n != 1) { // пока n != 1, сводить вычисление pow(x,n) к pow(x,n-1) <br>
					    return x * pow(x, n - 1); <br>
					  } else { <br>
					    return x; <br>
					  } <br>
					} <br>
					alert( pow(2, 3) ); // 8
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.call</p>
			</div>
			<div class="second_column table_column">
				<p>
					func.call(context, arg1, arg2, ...) <br>
					Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context). <br>

					Оддалживание метода: <br>
					  arguments.join = [].join; // одолжили метод (1) <br>
					  var argStr = arguments.join(':'); // (2) <br>

					var args = [].slice.call(arguments); <br>
					  alert( args.join(', ') ); // args - полноценный массив из аргументов
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function showFullName() { <br>
					  alert( this.firstName + " " + this.lastName ); <br>
					} <br>
					var user = { <br>
					  firstName: "Василий", <br>
					  lastName: "Петров" <br>
					}; <br>

					// функция вызовется с this=user <br>
					showFullName.call(user) // "Василий Петров"
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.apply</p>
			</div>
			<div class="second_column table_column">
				<p>
					func.apply(context, [arg1, arg2]); <br>
					Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					showFullName.apply(user, ['firstName', 'surname']);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.bind</p>
			</div>
			<div class="second_column table_column">
				<p>
					var wrapper = func.bind(context[, arg1, arg2...]) <br>
					Используется для привязки функции к контексту. <br>
					func - Произвольная функция  <br>
					context - Контекст, который привязывается к func  <br>
					arg1, arg2, … - Если указаны аргументы arg1, arg2... – они будут прибавлены к каждому вызову новой функции, причем встанут перед теми, которые указаны при вызове.
					Методы call/apply вызывают функцию с заданным контекстом и аргументами. <br>
					А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом. <br>
					Карринг (currying) или каррирование – термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей. <br>
					При помощи bind мы можем получить из функции её «частный вариант» как самостоятельную функцию и дальше передавать её уже
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function f(a, b) { <br>
					  alert( this ); <br>
					  alert( a + b ); <br>
					} <br>

					// вместо <br> 
					// var g = bind(f, "Context"); <br>
					var g = f.bind("Context"); <br>
					g(1, 2); // Context, затем 3 <br>

					Карринг: <br>
					var triple = mul.bind(null, 3); // контекст фиксируем null, он не используется <br>

					alert( triple(3) ); // = mul(3, 3) = 9 <br>
					alert( triple(4) ); // = mul(3, 4) = 12 <br>
					alert( triple(5) ); // = mul(3, 5) = 15
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------Timeout------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="timeout_interval">
			<h1>Timeout/Interval</h1>
		</div>
		
		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>setTimeout</p>
			</div>
			<div class="second_column table_column">
				<p>
					var timerId = setTimeout(func / code, delay[, arg1, arg2...]) <br>
					Параметры:<br>
					func/code - Функция или строка кода для исполнения. Строка поддерживается для совместимости, использовать её не рекомендуется. <br>
					delay - Задержка в миллисекундах, 1000 миллисекунд равны 1 секунде. <br>
					arg1, arg2… - Аргументы, которые нужно передать функции <br>
					- Минимальная задержка по стандарту составляет 4 мс .В реальности срабатывания таймера могут быть гораздо реже, чем назначено, например если процессор перегружен, вкладка находится в фоновом режиме, ноутбук работает от батареи или по какой-то иной причине.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function func() {  <br>
					  alert( 'Привет' ); <br>
					} <br>

					setTimeout(func, 1000); <br>

					function func(phrase, who) { <br>
					  alert( phrase + ', ' + who ); <br>
					} <br>

					setTimeout(func, 1000, "Привет", "Вася"); // Привет, Вася
				</p>
			</div>
		</div>
		
		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>clearTimeout</p>
			</div>
			<div class="second_column table_column">
				<p>
					Функция setTimeout возвращает числовой идентификатор таймера timerId, который можно использовать для отмены действия. <br>
					var timerId = setTimeout(...); <br>
					clearTimeout(timerId); 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var timerId = setTimeout(function() { alert(1) }, 1000); <br>
					alert(timerId); // число - идентификатор таймера <br>
					
					clearTimeout(timerId); <br>
					alert(timerId); // всё ещё число, оно не обнуляется после отмены
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					setInterval
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					var timerId = setInterval(func / code, delay[, arg1, arg2...]) <br>

					Смысл аргументов – тот же самый. Но, в отличие от setTimeout, он запускает выполнение функции не один раз, а регулярно повторяет её через указанный интервал времени. <br>

					Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва. <br>

					Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval, так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего. <br>
					Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// начать повторы с интервалом 2 сек  <br>
					var timerId = setInterval(function() { <br>
					  alert( "тик" ); <br>
					}, 2000); <br>
						 <br>
					Вместо: <br>
					var i = 1; <br>
					setInterval(function() { <br>
					  func(i); <br>
					}, 100); <br>
					 <br>
					Получаем: <br>
					var i = 1; <br>
					setTimeout(function run() { <br>
					  func(i); <br>
					  setTimeout(run, 100); <br>
					}, 100);
				</p>
			</div>
		</div>
		
		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>clearInterval(timerId)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Остановить исполнение setTimeout
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// через 5 сек остановить повторы <br>
					setTimeout(function() { <br>
					  clearInterval(timerId); <br>
					  alert( 'стоп' ); <br>
					}, 5000);
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------Number Methods------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="number_methods">
			<h1>Number Methods</h1>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>isNaN(n)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-преобразует к числу <br>
					-возвращает True, если NaN <br>
					-возвращает False, в любом другом случае
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var n = 0 / 0; <br>
					alert( isNaN(n) ); // true <br>
					alert( isNaN("12") ); // false
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>isFinite(n)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-преобразует к числу <br>
					-возвращает True, если NaN, Infinity, -Infinity <br>
					-возвращает False, в любом другом случае
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( isFinite(1) ); // true <br>
					alert( isFinite(Infinity) ); // false <br>
					alert( isFinite(NaN) ); // false
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					parseInt(str) <br>
					parseFloat(str)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Преобразуют строку символ за символом <br>

					Функция parseInt также позволяет указать систему счисления, то есть считывать числа, заданные в шестнадцатиричной и других системах счисления:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( parseInt('12px') ) // 12, ошибка на символе 'p' <br>
					alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке <br>
					alert( parseInt('a123') ); // NaN <br>
					alert( parseInt('FF', 16) ); // 255
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.toString(sys)</p>
			</div>
			<div class="second_column table_column">
				<p>
					toString(основание системы) <br>
					Записать число в другой системе исчесления.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var n = 255; <br>
					alert( n.toString(16) ); // ff
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Tips:</h2>
				<p>
					Проверка на число: <br>
					- Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.
					Таким образом, правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку '', так как они корректно преобразуются в числа. <br>
					- Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений.
					Так устроена функция parseFloat: она преобразует аргумент к строке, то есть true/false/null становятся "true"/"false"/"null", а затем считывает из неё число, при этом пустая строка даёт NaN. <br>
					- В результате отсеивается всё, кроме строк-чисел и обычных чисел
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					function isNumeric(n) { <br>
  						return !isNaN(parseFloat(n)) && isFinite(n); }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.floor(n)</p>
			</div>
			<div class="second_column table_column">
				<p>Округляет вниз</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( Math.floor(3.1) );  // 3
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.ceil(n)</p>
			</div>
			<div class="second_column table_column">
				<p>Округляет вверх</p>
			</div>
			<div class="third_column table_column">
				<p>alert( Math.ceil(3.1) );   // 4</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.round(n)</p>
			</div>
			<div class="second_column table_column">
				<p>Округляет до ближайшего целого</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( Math.round(3.1) );  // 3 <br>
					До заданной точности: <br>
					var n = 3.456; <br>
					alert( Math.round(n * 100) / 100 ); // 3.456 -> 345.6 -> 346 -> 3.46
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.toFixed(precision)</p>
			</div>
			<div class="second_column table_column">
				<p>- возвращает строку</p>
			</div>
			<div class="third_column table_column">
				<p>
					var n = 12.34; <br>
					alert( n.toFixed(1) ); // "12.3"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.acos(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает арккосинус x (в радианах)</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.asin(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает арксинус x (в радианах)</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.atan(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает арктангенс x (в радианах)</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.atan2(y, x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает угол до точки (y, x). Описание функции: Atan2.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.sin(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Вычисляет синус x</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.cos(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Вычисляет косинус x</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.tan(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает тангенс x</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.sqrt(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает квадратный корень из x.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.log(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает натуральный (по основанию e) логарифм x.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.pow(x, exp)</p>
			</div>
			<div class="second_column table_column">
				<p>Возводит число в степень, возвращает X exp</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.abs(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает абсолютное значение числа</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.exp(x)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает e x, где e – основание натуральных логарифмов.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.max(a, b, c...)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает наибольший из списка аргументов</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Math.min(a, b, c...)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает наименьший из списка аргументов</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Math.random()</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает псевдослучайное число в интервале [0,1) – то есть между 0 (включительно) и 1 (не включая). Генератор случайных чисел инициализуется текущим временем.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>n.toLocaleString()</p>
			</div>
			<div class="second_column table_column">
				<p>Для красивого вывода чисел</p>
			</div>
			<div class="third_column table_column">
				<p> 
					var number = 123456789; <br>
					alert( number.toLocaleString() ); // 123 456 789
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------------string Methods------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="string_methods">
			<h1>String Methods</h1>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.length</p>
			</div>
			<div class="second_column table_column">
				<p>Свойство. Определяет длину, кол-во символов</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "Привет, мир!"; <br>
					alert( str.length ); 12
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.toUpperCase() </p>
			</div>
			<div class="second_column table_column">
				<p>Метод. возвращает строку в верхнем регистре:</p>
			</div>
			<div class="third_column table_column">
				<p>
					var hello = "Привет, мир!"; <br>
					alert( hello.toUpperCase() ); "ПРИВЕТ, МИР!"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.toLowerCase() </p>
			</div>
			<div class="second_column table_column">
				<p>возвращает строку в нижнем регистре:</p>
			</div>
			<div class="third_column table_column">
				<p>
					var hello = "ПРИВЕТ, МИР!"; <br>
					alert( hello.toUpperCase() );  <br>
					“привет, мир!”
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>str1.localeCompare(str2)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Сравнение строк: <br>
					Метод str1.localeCompare(str2) возвращает -1, если str1 < str2, 1, если str1 > str2и 0, если они равны.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "Ёлки"; <br>
					alert( str.localeCompare("Яблони") ); // -1
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.charAt(position)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-возвращает строку, состоящую из выбранного символа. <br>
					-Первый символ имеет позицию 0: <br>
					-если символа нет – charAt выдает пустую строку, а его аналог : скобки [ ] – undefined:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "jQuery"; <br>
					alert( str.charAt(0) ); // "j" <br>
					alert( str.[0] ); // "j" <br>
					alert( "".charAt(0) ); // пустая строка <br>
					alert( "" [0] ); // undefined
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.indexOf(str,pos)</p>
			</div>
			<div class="second_column table_column">
				<p>
					indexOf(подстрока[, начальная_позиция]). <br>
					-Метод для поиска подстроки, возвращает позицию на которой находится подстрока или -1, если ничего не найдено. <br>
					-Необязательный второй аргумент позволяет искать, начиная с указанной позиции<br>

					if ( ~str.indexOf(...) ) - читается как "если найдено"
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "Widget with id"; <br>
					alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str  <br>
					alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1  <br>
					alert( str.indexOf("widget") ); // -1, не найдено, так как поиск учитывает регистр  <br>
					var str = "Widget with id";  <br>

					alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2 <br>

					Tips: поиск всех вхождений <br>
					var str = "Ослик Иа-Иа посмотрел на виадук"; // ищем в этой строке <br>
					var target = "Иа"; // цель поиска <br>

					var pos = 0; <br>
					while (true) { <br>
					  var foundPos = str.indexOf(target, pos); <br>
					  if (foundPos == -1) break; <br>

					  alert( foundPos ); // нашли на этой позиции <br>
					  pos = foundPos + 1; // продолжить поиск со следующей <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.lastIndexOf(str,pos)</p>
			</div>
			<div class="second_column table_column">
				<p>Аналогичный метод, ищет с конца строки</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.substring(start, end)</p>
			</div>
			<div class="second_column table_column">
				<p>
					substring(start [, end]) <br>
					- возвращает подстроку с позиции start до, но не включая end. <br>
					- Если аргумент end отсутствует, то идет до конца строки: <br>
					-Отрицательные аргументы интерпретируются как равные нулю. <br>
					-Слишком большие значения усекаются до длины строки: <br>
					-если start > end, то аргументы меняются местами, т.е. возвращается участок строки между start и end:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "stringify"; <br>
					alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1. <br>
					var str = "stringify"; <br>
					alert(str.substring(2)); // ringify, символы с позиции 2 до конца <br>
					alert( "testme".substring(-2) ); // "testme", -2 становится 0 <br>
					alert( "testme".substring(4, -1) ); // "test" (0, 4)
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.substring(start, length)</p>
			</div>
			<div class="second_column table_column">
				<p>
					substr(start [, length]) <br>
					- возвращает подстроку с позиции start , на кол-во символов length <br>
					- Если аргумент length отсутствует, то идет до конца строки: <br>
				</p> 
			</div>
			<div class="third_column table_column">
				<p>
					var str = "stringify"; <br>
					str = str.substr(2,4); // ring, со 2-й позиции 4 символа<br>
					alert(str)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.slice(start [, end])</p>
			</div>
			<div class="second_column table_column">
				<p>
					- возвращает подстроку с позиции start до, но не включая end. <br>
					- Если аргумент end отсутствует, то идет до конца строки: <br>
					- Отрицательные значения отсчитываются от конца строки:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "stringify"; <br>
					alert(str.slice(0,1)); // "s", символы с позиции 0 по 1 не включая 1. <br>
					alert( "testme".slice(-2) ); // "me", от 2 позиции с конца <br>
					alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.replace()</p>
			</div>
			<div class="second_column table_column">
				<p>
					The replace() method searches a string for a specified value, or a regular expression, and returns a new string where the specified values are replaced.
					<br>
					 If you are replacing a value (and not a regular expression), only the first instance of the value will be replaced. To replace all occurrences of a specified value, use the global (g) modifier 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "Visit Microsoft!"; <br> 
					var res = str.replace("Microsoft", "W3Schools"); <br> <br>

					var str = "Mr Blue has a blue house and a blue car"; <br>
					var res = str.replace(/blue/g, "red"); // global replacement
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.trim()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Returns the omitted string with no leading and trailing spaces.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var str = "    Visit Microsoft!       "; <br>
					str.trim();<br>
					// str == "Visit Microsoft!"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>str.includes(s)</p>
			</div>
			<div class="second_column table_column">
				<p>проверяет, включает ли одна строка в себя другую, возвращает true/false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>str.endsWith(s)</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает true, если строка str заканчивается подстрокой s.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>str.startsWith(s)</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает true, если строка str начинается со строки s.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>str.repeat(times)</p>
			</div>
			<div class="second_column table_column">
				<p>повторяет строку str times раз.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------object Methods------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="object_methods">
			<h1>Object Methods</h1>
		</div>


		<div class="tips_table_row zebra1">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					-Объект, как асицотивный массив - структура данных, в которой можно хранить любые данные в формате ключ-значение. <br>
					-Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства (иногда говорят «по ключу»). <br>
					- Свойство – переменная объекта <br>
					- Метод объекта - Свойство-функция объекта <br>
					- Для обращения к свойствам используется запись «через точку», вида person.name, альтернатива - person['name']. имя свойства обязано быть строкой. <br>
					- Удаление осуществляется оператором delete: <br>
					- нужно проверить, есть ли в объекте свойство с определенным ключом. "prop" in obj <br> 
					- в JavaScript можно обратиться к любому свойству объекта, даже если его нет. – вернётся undefined <br>
					- Доступ к свойству через переменную, всегда через квадратные скобки! person[key] <br>

					В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него. При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных: <br>

					у нас есть переменные, например, name и isAdmin, и мы хотим использовать их в объекте. <br>
					При объявлении объекта в этом случае достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем. <br>
					В качестве имени свойства можно использовать выражение <br>
					В 2015 появились «методы объекта»: <br>
					1.	- Более короткий синтаксис объявления. <br>
					2.	"prop() { … }" <br>
					- Наличие в методах специального внутреннего свойства [[HomeObject]] <br>
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					1. var person = new Object(); <br>
					2. var person = {}; // пустые фигурные скобки <br>
						 <br>
					var menuSetup = {  <br>
					  width: 300, <br>
					  height: 200, <br>
					  title: "Menu" <br>
					}; <br>
					 <br>
					person.name = 'Вася'; <br>
					person.age = 25; <br>
						
					person['name'] = 'Вася'; // то же что и person.name = 'Вася' <br>
						 <br>
					alert( person.name + ': ' + person.age ); // "Вася: 25" <br>

					delete person.age; <br>

					if ("name" in person) { <br>
					  alert( "Свойство name существует!" ); <br>
					} <br>

					var person = {}; <br>
					alert( person.lalala ); // undefined, нет свойства с ключом lalala <br>
					 <br>
					alert( person[key] ); // выведет person['age'] <br>
					 <br>
					let name = "Вася"; <br>
					let isAdmin = true; <br>

					let user = { <br>
					  name, <br>
					  isAdmin <br>
					}; <br>
						 <br>
					let user = { <br>
					  [propName]: "Вася" <br>
					}; <br>
						 <br>
					let user = { <br>
					  name, <br>
					  // вместо "sayHi: function() {...}" пишем "sayHi() {...}" <br>
					  sayHi() { <br>
					    alert(this.name); <br>
					  } <br>
					}; <br>

					let user = { <br>
					  name, <br>
					  surname, <br>
					  get fullName() { <br>
					    return `${name} ${surname}`; <br>
					  } <br>
					}; <br> <br>
					
					var objectC = {...objectA}; - clone <br>
					var objectC = {...objectA, ...objectB}; -combine <br> <br>

					let newObject = JSON.parse(JSON.stringify(obj)); <br>
					Глубокая копия, но возможны проблемы с полями undefined, null... <br> <br>

					const office = { <br>
						manager: { <br>
							name: "Cris", <br>
							subordinates: [<br>
								{<br>
									name: "Nick",<br>
									age: 20<br>
								},<br>
								{<br>
									name: "Chuck",<br>
									age: 18<br>
								}<br>
							],<br>
						},<br>
						employees: [<br>
							{<br>
								name: "Nick",<br>
								age: 20<br>
							},<br>
							{<br>
								name: "Chuck",<br>
								age: 18<br>
							}<br>
						]<br>
					}<br><br>

					const vataObj = { <br>
						...office,<br>
						manager: {<br>
							...office.manager,<br>
							subordinates: [...offece.manageer.subordinates]<br>
						}<br>
					}<br>
					Глубокая копия Объекта!
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>for..in</p>
			</div>
			<div class="second_column table_column">
				<p>
					for (key in obj) { <br>
					  /* ... делать что-то с obj[key] ... */ <br>
					} - Для перебора всех свойств из объекта <br>

					если имя свойства – нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались. Если нужно, чтобы порядок перебора числовых ключей соответствовал их объявлению в объекте, то используют трюк: числовые ключи заменяют на похожие, но содержащие не только цифры. Например, добавляют в начало +<br>

					Для глубокого копирования используется переводл к строкам формата JSON: <br>	
					const copy = JSON.parse(JSON.stringify(obj));
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var counter = 0; // Кол-во ключей <br>
					for (var key in menu) { <br>
					  counter++; <br>
					} <br>

					var clone = {}; // Клонируем Объект <br>
					for (var key in user) { <br>
					  clone[key] = user[key]; <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.keys(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>
					возвращает массив свойств объекта. Чтобы работать с ключами в виде массива
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var user = { <br>
						  name: "Петя", <br>
						  age: 30 <br>
						} <br>
						var keys = Object.keys(user); <br>
						alert( keys ); // name, age
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>this</p>
			</div>
			<div class="second_column table_column">
				<p>
					This – контекст, используется Для доступа к текущему объекту из метода. <br>
					Использование this гарантирует, что функция работает именно с тем объектом, в контексте которого вызвана
					Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this: <br>

					Значение this при вызове без контекста - undefined
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var user = { <br>
					  name: 'Василий', <br>
					  sayHi: function() { <br>
					    alert( this.name ); <br>
					  } <br>
					}; <br>
					user.sayHi(); // sayHi в контексте user <br>
					var user = { <br>
					  name: 'Василий', <br>
					  sayHi: function() { <br>
					    showName(this); // передать текущий объект в showName <br>
					  } <br>
					}; <br>
					function showName(namedObj) { <br>
					  alert( namedObj.name ); <br>
					} <br>
					user.sayHi(); // Василий <br>
					function func() { <br>
					  alert( this.firstName ); <br>
					} <br>
					user.f = func; <br>
					admin.g = func; <br>
					// this равен объекту перед точкой: <br>
					user.f(); // Вася <br>
					admin.g(); // Админ
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Converting to string/number</p>
			</div>
			<div class="second_column table_column">
				<p>
					Встроенный метод?.toString <br>
					используется для преобразования примитиву, к строке <br>
					alert( [1, 2] ); // toString для массивов выводит список элементов "1,2" <br>
					alert( new Date ); // toString для дат выводит дату в виде строки <br>
					alert( function() {} ); // toString для функции выводит её код <br>
					<br>
					Встроенный метод? .valueOf <br> 
					Используется для числового преобразования <br>
					У большинства встроенных объектов такого valueOf нет, поэтому численное и строковое преобразования для них работают одинаково. <br>
					Исключением является объект Date, который поддерживает оба типа преобразований: <br>
					alert( new Date() ); // toString: Дата в виде читаемой строки <br>
					alert( +new Date() ); // valueOf: кол-во миллисекунд, прошедших с 01.01.1970
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var user = { <br>
					  firstName: 'Василий', <br>
					  toString: function() { <br>
					    return 'Пользователь ' + this.firstName; <br>
					  } <br>
					}; <br>
					alert( user );  // Пользователь Василий <br>
					<br>
					var room = { <br>
					  number: 777, <br>
					  valueOf: function() { return this.number; }, <br>
					  toString: function() { return this.number; } <br>
					}; <br>
					alert( +room );  // 777, вызвался valueOf <br>
					delete room.valueOf; // valueOf удалён <br>
					alert( +room );  // 777, вызвался  <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>obj.hasOwnProperty</p>
			</div>
			<div class="second_column table_column">
				<p>
					obj.hasOwnProperty(prop) <br>
					возвращает true, если свойство prop принадлежит самому объекту obj, если родителю false. <br>
					Для перебора: <br>
					for (var key in rabbit) { <br>
					  rabbit.hasOwnProperty(key) } 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var animal = { <br>
					  eats: true <br>
					}; <br>
					var rabbit = { <br>
					  jumps: true, <br>
					  __proto__: animal <br>
					}; <br>
					alert( rabbit.hasOwnProperty('jumps') ); // true: jumps принадлежит rabbit <br>
					alert( rabbit.hasOwnProperty('eats') ); // false: eats не принадлежит <br>
					for (var key in rabbit) { <br>
					  if (!rabbit.hasOwnProperty(key)) continue; // пропустить "не свои" свойства <br>
					  alert( key + " = " + rabbit[key] ); // выводит только "jumps"
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.defineProperty</p>
			</div>
			<div class="second_column table_column">
				<p>
					Object.defineProperty(obj, prop, descriptor) <br>
					Основной метод для управления свойствами объекта  <br>
					Аргументы:  <br>
					obj - Объект, в котором объявляется свойство. <br>
					prop - Имя свойства, которое нужно объявить или модифицировать.  <br>
					descriptor - Дескриптор – объект, который описывает поведение свойства.  <br>
					В нём могут быть следующие поля: <br>
					- value – значение свойства, по умолчанию undefined <br>
					- writable – значение свойства можно менять, если true. По умолчанию false. <br>
					- configurable – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false. <br>
					- enumerable – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false. <br>
					- get – функция, которая возвращает значение свойства. По умолчанию undefined. <br>
					- set – функция, которая записывает значение свойства. По умолчанию undefined. <br>
					Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Свойство константа: <br>
					Object.defineProperty(user, "name", { <br>
					  value: "Вася", <br>
					  writable: false, // запретить присвоение "user.name=" <br>
					  configurable: false // запретить удаление "delete user.name" <br>
					}); <br>
					Свойство-функция: <br>
					Object.defineProperty(user, "fullName", { <br>
					  get: function() { <br>
					    return this.firstName + ' ' + this.surname; <br>
					  } <br>
					}); <br>
					var user = { <br>
					  firstName: "Вася", <br>
					  surname: "Петров", <br>
					   <br>
					  get fullName() { <br>
					    return this.firstName + ' ' + this.surname; <br>
					  }, <br>
					  set fullName(value) { <br>
					    var split = value.split(' '); <br>
					    this.firstName = split[0]; <br>
					    this.surname = split[1]; <br>
					  } <br>
					}; <br>
					alert( user.fullName ); // Вася Петров (из геттера) <br>
					user.fullName = "Петя Иванов"; <br>
					alert( user.firstName ); // Петя  (поставил сеттер) <br>
					alert( user.surname ); // Иванов (поставил сеттер)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.defineProperties(obj, descriptors)</p>
			</div>
			<div class="second_column table_column">
				<p>Позволяет объявить несколько свойств сразу:</p>
			</div>
			<div class="third_column table_column">
				<p>
					var user = {} <br>
					Object.defineProperties(user, {<br>
					  firstName: {<br>
					    value: "Петя"<br>
					  },<br>

					  surname: {<br>
					    value: "Иванов"<br>
					  },<br>

					  fullName: {<br>
					    get: function() {<br>
					      return this.firstName + ' ' + this.surname;<br>
					    }<br>
					  }<br>
					});<br>
					alert( user.fullName ); // Петя Иванов
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.keys(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Позволяет объявить несколько свойств сразу: <br>
					Возвращает массив – список свойств объекта. Возвращает только enumerable-свойства.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var obj = { <br>
						  a: 1,<br>
						  b: 2,<br>
						  internal: 3<br>
						};<br>

						Object.defineProperty(obj, "internal", {<br>
						  enumerable: false<br>
						});<br>

						alert( Object.keys(obj) ); // a,b<br>
						alert( Object.getOwnPropertyNames(obj) ); // a, b, internal
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.getOwnPropertyNames(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает массив – список свойств объекта. <br>
				 Возвращает  все свойства.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var obj = { <br>
						  a: 1,<br>
						  b: 2,<br>
						  internal: 3<br>
						};<br>

						Object.defineProperty(obj, "internal", {<br>
						  enumerable: false<br>
						});<br>

						alert( Object.keys(obj) ); // a,b<br>
						alert( Object.getOwnPropertyNames(obj) ); // a, b, internal
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.getOwnPropertyDescriptor(obj, prop)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Возвращает дескриптор для свойства obj[prop]. <br>
					Полученный дескриптор можно изменить и использовать defineProperty для сохранения изменений
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var obj = { <br>
					  test: 5 <br>
					}; <br>
					var descriptor = Object.getOwnPropertyDescriptor(obj, 'test'); <br>
					 <br>
					// заменим value на геттер, для этого... <br>
					delete descriptor.value; // ..нужно убрать value/writable <br>
					delete descriptor.writable; <br>
					descriptor.get = function() { // и поставить get <br>
					  alert( "Preved :)" ); <br>
					}; <br>
					
					// поставим новое свойство вместо старого <br>
							
					// если не удалить - defineProperty объединит старый дескриптор с новым <br>
					delete obj.test; <br>

					Object.defineProperty(obj, 'test', descriptor); <br>
					obj.test; // Preved :)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.preventExtensions(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>Запрещает добавление свойств в объект.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.seal(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Запрещает добавление и удаление свойств, все текущие свойства делает configurable: false.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.freeze(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Запрещает добавление, удаление и изменение свойств, все текущие свойства делает configurable: false, writable: false.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.isExtensible(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Возвращает false, если добавление свойств объекта было запрещено вызовом метода Object.preventExtensions.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.isSealed(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает true, если добавление и удаление свойств объекта запрещено, и все текущие свойства являются configurable: false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.isFrozen(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает true, если добавление, удаление и изменение свойств объекта запрещено, и все текущие свойства являются configurable: false, writable: false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.assign</p>
			</div>
			<div class="second_column table_column">
				<p>
					получает список объектов и копирует в первый target свойства из остальных. <br>
					Object.assign(target, src1, src2...)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let user = { name: "Вася" }; <br>
					let visitor = { isAdmin: false, visits: true }; <br>
					let admin = { isAdmin: true }; <br>
						
					Object.assign(user, visitor, admin);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.is</p>
			</div>
			<div class="second_column table_column">
				<p>
					Object.is(value1, value2) <br>
					функция для проверки равенства значений. <br>
					Возвращает true, если значения value1 и value2 равны, иначе false.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// Сравнение +0 и -0 <br>
					alert( Object.is(+0, -0)); // false <br>
					alert( +0 === -0 );        // true <br>

					// Сравнение с NaN <br>
					alert( Object.is(NaN, NaN) ); // true <br>
					alert( NaN === NaN );         // false
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------array Methods------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="array_methods">
			<h1>Array Methods</h1>
		</div>


		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					- Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений. это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length. <br>
					- Элементы нумеруются, начиная с нуля. <br>
					- Через alert можно вывести и массив целиком. <br>
					- В массиве может храниться любое число элементов любого типа. <br>
					- Присваивать можно свойство с любым номером, а так же именем. Но выводится будет с «дырами» <br>
					- Как и объект – переменная это ссылка на место в памяти <br>
					-  Для перебора элементов: <br>
					for (var i = 0; i < arr.length; i++) { <br>
					  alert( arr[i] ); <br>
					} <br>
					- Массивы в JavaScript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, например матриц:
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					var arr = []; <br>
					var arr = new Array("Яблоко", "Груша", "и т.п."); <br>
					var fruits = ["Яблоко", "Апельсин", "Слива"]; <br>
					alert( fruits[0] ); // Яблоко <br>
					alert( fruits[1] ); // Апельсин <br>
					alert( fruits[2] ); // Слива <br>
					alert( fruits ); // Яблоко,Апельсин,Груша <br>
					 <br>
					var a = []; <br>
					a[0] = 0; <br>
					a[5] = 5; <br>
					alert( a ); // 0,,,,,5 <br>
					 <br>
					var matrix = [ <br>
					  [1, 2, 3], <br>
					  [4, 5, 6], <br>
					  [7, 8, 9] <br>
					]; <br>
					alert( matrix[1][1] ); // центральный элемент
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.length</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Общее число элементов, хранимых в массиве <br>
					- не количество элементов массива, а последний индекс + 1 <br>
					- При уменьшении length массив укорачивается. <br>
					- очистить массив -  arr.length=0. 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var fruits = ["Яблоко", "Апельсин", "Груша"]; <br>
					alert( fruits.length ); // 3 <br>
					<br>
					var arr = []; <br>
					arr[1000] = true; <br>
					alert(arr.length); // 1001 <br>
					 <br>
					var arr = [1, 2, 3, 4, 5]; <br>
					arr.length = 2; // укоротить до 2 элементов <br>
					alert( arr ); // [1, 2]
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.pop()</p>
			</div>
			<div class="second_column table_column">
				<p>Удаляет последний элемент из массива и возвращает его:</p>
			</div>
			<div class="third_column table_column">
				<p>
					var fruits = ["Яблоко", "Апельсин", "Груша"]; <br>
					alert( fruits.pop() ); // удалили "Груша"
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.push(elem)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Добавляет элемент в конец массива: <br>
					-Можно несколько эелементов <br>
					-Вызов fruits.push(...) равнозначен fruits[fruits.length] = ....
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var fruits = ["Яблоко", "Апельсин"]; <br>

					fruits.push("Груша"); <br>
					alert( fruits ); // Яблоко, Апельсин, Груша <br>

					fruits.push("Апельсин", "Персик"); <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.shift()</p>
			</div>
			<div class="second_column table_column">
				<p>Удаляет из массива первый элемент и возвращает его:</p>
			</div>
			<div class="third_column table_column">
				<p>
					var fruits = ["Яблоко", "Апельсин", "Груша"]; <br>
					alert( fruits.shift() ); // удалили Яблоко
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.unshift(elem)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-Добавляет элемент в начало массива: <br>
					-Можно несколько эелементов
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var fruits = ["Апельсин", "Груша"]; <br>
					fruits.unshift('Яблоко'); <br>
					alert( fruits ); // Яблоко, Апельсин, Груша <br>
					fruits.unshift("Ананас", "Лимон");
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.split(s)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- превратить строку в массив, разбив ее по разделителю s <br>
					- необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен: <br>
					- Вызов split с пустой строкой разобьёт по буквам:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var names = 'Маша, Петя, Марина, Василий'; <br>
					var arr = names.split(', '); <br>
					alert(arr); <br>
					<br>
					alert( "a,b,c,d".split(',', 2) ); // a,b <br>
					<br>
					var str = "тест"; <br>
					alert( str.split('') ); // т,е,с,т
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.join(str)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- берет массив и склеивает его в строку, используя str как разделитель. <br>
					- new Array + join = Повторение строки
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = ['Маша', 'Петя', 'Марина', 'Василий']; <br>
					var str = arr.join(';'); <br> 
					alert( str ); // Маша;Петя;Марина;Василий <br>
					<br>
					alert( new Array(4).join("ля") ); // ляляля
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.splice(index)</p>
			</div>
			<div class="second_column table_column">
				<p>
					.splice(index[, deleteCount, elem1, ..., elemN]) <br>
					- Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно. Удалить  deleteCount  элементов, начиная с номера index, а затем вставить elem1, ..., elemN на их место. Возвращает массив из удалённых элементов. Так же вставлять элементы без удаления.  <br>
					- Допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = ["Я", "изучаю", "JavaScript"]; <br>
					arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент <br>
					 <br>
					var arr = ["Я", "сейчас", "изучаю", "JavaScript"];
					// удалить 3 первых элемента и добавить другие вместо них <br>
					arr.splice(0, 3, "Мы", "изучаем") <br>
					 <br>
					var arr = ["Я", "изучаю", "JavaScript"]; <br>
					// с позиции 2 <br>
					// удалить 0 <br>
					// вставить "сложный", "язык" <br>
					arr.splice(2, 0, "сложный", "язык"); <br>
					 <br>
					var arr = [1, 2, 5] <br>
					// начиная с позиции индексом -1 (перед последним элементом) <br>
					// удалить 0 элементов, <br>
					// затем вставить числа 3 и 4 <br>
					arr.splice(-1, 0, 3, 4);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.slice(begin, end)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Копирует в новый массив  участок массива от begin до end, не включая end. Исходный массив при этом не меняется <br>
					- Если не указать end – копирование будет до конца массива: <br>
					- Можно использовать отрицательные индексы, они отсчитываются с конца: <br>
					- Если вообще не указать аргументов – скопируется весь массив:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = ["Почему", "надо", "учить", "JavaScript"]; <br>
					var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)  <br>

					var arr2 = arr.slice(-2); // копировать от 2-го элемента с конца и дальше  <br>

					var fullCopy = arr.slice();  <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.sort(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- сортирует массив на месте <br>
					- по умолчанию sort() сортирует, преобразуя элементы к строке. <br>
					- arr.sort(compareNumeric); - код функции, не запуская её <br>
					- Положительное значение, если a > b, - сортирует  <br>
					- Отрицательное значение, если a < b, - не сортирует <br>
					- Если равны – можно 0, но вообще – не важно, что возвращать, если их взаимный порядок не имеет значения.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [ 1, 2, 15 ]; <br>
					arr.sort(); <br>
					alert( arr );  // 1, 15, 2 – преобразовав к строке <br>
					 <br>
					function compareNumeric(a, b) { <br>
					  if (a > b) return 1; <br>
					  if (a < b) return -1; <br>
					} <br>
					var arr = [ 1, 2, 15 ]; <br>
					arr.sort(compareNumeric); <br>
					alert(arr);  // 1, 2, 15 <br>
					function compareNumeric(a, b) { <br>
					  return a - b; <br>
					} – более крутой вариант
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.reverse()</p>
			</div>
			<div class="second_column table_column">
				<p>меняет порядок элементов в массиве на обратный.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, 2, 3]; <br>
					arr.reverse(); <br>
					alert( arr ); // 3,2,1
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.concat(val)</p>
			</div>
			<div class="second_column table_column">
				<p>
					-  arr.concat(value1, value2, … valueN) <br>
					- создаёт новый массив, в который копируются элементы из arr, а также value1, value2, ... valueN. <br>
					- Если аргумент concat – массив, то concat добавляет элементы из него.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, 2]; <br> 
					var newArr = arr.concat(3, 4); <br>
					alert( newArr ); // 1,2,3,4
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.indexOf(val)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.indexOf(searchElement[, fromIndex]) <br>
					- возвращает номер элемента searchElement в массиве arr или -1, если его нет. <br>
					- Поиск начинается со второго, необязательног аргумента fromIndex, если он указан. Если нет – с начала массива. <br>
					- Для поиска используется строгое сравнение ===.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, 0, false]; <br>
					alert( arr.indexOf(0) ); // 1 <br>
					alert( arr.indexOf(false) ); // 2 <br>
					alert( arr.indexOf(null) ); // -1
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.lastIndexOf(val)</p>
			</div>
			<div class="second_column table_column">
				<p>- Ищет с права на лево</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.forEach(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.forEach(callback[, thisArg]) <br>
					-используется для перебора массива, Он для каждого элемента массива вызывает функцию callback. Этой функции он передаёт три параметра callback(item, i, arr):  <br>
					- item – очередной элемент массива. <br>
					- i – его номер. <br>
					- arr – массив, который перебирается. <br>
					- Второй, необязательный аргумент forEach позволяет указать контекст this для callback.  <br>
					- Метод forEach ничего не возвращает
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = ["Яблоко", "Апельсин", "Груша"]; <br>

					arr.forEach(function(item, i, arr) { <br>
					  alert( i + ": " + item + " (массив:" + arr + ")" ); <br>
					});<br> <br>

					let array = [ <br>
						{id: 1, name: 'Vata1', address: 'VataHome1'}, <br>
						{id: 2, name: 'Vata2', address: 'VataHome2'}, <br>
						{id: 3, name: 'Vata3', address: 'VataHome3'} <br>
					]; <br><br>


					array.forEach((obj) => obj.vataPole = 'VataString');
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.find()</p>
			</div>
			<div class="second_column table_column">
				<p>
					The find() method returns the value of the first element in an array that pass a test (provided as a function).
					<br>
					If it finds an array element where the function returns a true value, find() returns the value of that array element (and does not check the remaining values)
					<br>
					 find() does not change the original array.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var ages = [3, 10, 18, 20]; <br> <br>

					function checkAdult(age) {<br>
					  return age >= 18;<br>
					}<br><br>

					ages.find(checkAdult); // 18
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.filter(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.filter(callback[, thisArg]) <br>
					- используется для фильтрации массива через функцию. создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, -1, 2, -2, 3]; <br>
					var positiveArr = arr.filter(function(number) { <br>
					  return number > 0; <br>
					});  <br>
					alert( positiveArr ); // 1,2,3 <br> <br>

					let array = [ <br>
						{id: 1, name: 'Vata1', address: 'VataHome1'}, <br>
						{id: 2, name: 'Vata2', address: 'VataHome2'}, <br>
						{id: 3, name: 'Vata3', address: 'VataHome3'} <br>
					]; <br><br>


					let newArray = array.filter((obj) => obj.name === 'Vata2');
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.map(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.map(callback[, thisArg]) <br>
					- используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var names = ['HTML', 'CSS', 'JavaScript']; <br>
					var nameLengths = names.map(function(name) { <br>
					  return name.length; <br>
					}); <br>
					// получили массив с длинами <br>
					alert( nameLengths ); // 4,3,10 <br> <br>

					let array = [ <br>
						{id: 1, name: 'Vata1', address: 'VataHome1'}, <br>
						{id: 2, name: 'Vata2', address: 'VataHome2'}, <br>
						{id: 3, name: 'Vata3', address: 'VataHome3'} <br>
					]; <br><br>

					let newArray2 = array.map((obj) => <br>
						{ obj.name = obj.name && obj.name.slice(0,-1); <br>
							return obj;<br>
							 });
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.every(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.every(callback[, thisArg]) <br>
					- используeтся для проверки массива.  возвращает true, если вызов callback вернёт true для каждого элемента arr.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, -1, 2, -2, 3]; <br>
					function isPositive(number) { <br>
					  return number > 0; <br>
					} <br>
					alert( arr.every(isPositive) ); // false, не все положительные
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.some(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.every(callback[, thisArg]) <br>
					- используeтся для проверки массива. возвращает true, если вызов callback вернёт trueдля какого-нибудь элемента arr.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, -1, 2, -2, 3]; <br>
					function isPositive(number) { <br>
					  return number > 0; <br>
					} <br>
					alert( arr.some(isPositive) ); // true, есть хоть одно положительное
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.reduce(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>
					- arr.reduce(callback[, initialValue]) <br>
					- используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата. <br>
					 Метод reduce используется для вычисления на основе массива какого-либо единого значения, иначе говорят «для свёртки массива». Он применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат. <br>
					Аргументы функции callback(previousValue, currentItem, index, arr): <br>
					- previousValue – последний результат вызова функции, он же «промежуточный результат». <br>
					- currentItem – текущий элемент массива, элементы перебираются по очереди слева-направо. <br>
					- index – номер текущего элемента. <br>
					- arr – обрабатываемый массив. <br>
					- Кроме callback, методу можно передать «начальное значение» – аргумент initialValue. Если он есть, то на первом вызове значение previousValue будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var arr = [1, 2, 3, 4, 5] <br>
					// для каждого элемента массива запустить функцию, <br>
					// промежуточный результат передавать первым аргументом далее <br>
					var result = arr.reduce(function(sum, current) { <br>
					  return sum + current; <br>
					}, 0); <br>
					alert( result ); // 15
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.reduceRight(fn)</p>
			</div>
			<div class="second_column table_column">
				<p>работает аналогично, но идёт по массиву справа-налево</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------Pseudo-array "Arguments"------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="pseudo-array">
			<h1>Pseudo-Array "Arguments"</h1>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					- Чтобы получить значения аргументов, которых нет в списке параметров используется «псевдо-массив» arguments. <br>
					- arguments – это не массив, нельзя использовать встроенные методы. Есть только length  <br>
					Tips:  <br>
					- В тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию, вместо работы с arguments организуют передачу данных через объект, который как правило называют options.  <br>
					- Для указания аргументов по умолчанию, в тех случаях, когда они заведомо не false, удобен оператор ||.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					function sayHi() { <br>
					  for (var i = 0; i < arguments.length; i++) { <br>
					    alert( "Привет, " + arguments[i] ); <br>
					  } <br>
					} <br>
					sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок' <br>
						 <br>
					Tips:  <br>
					function showWarning(width, height, title, contents) { <br>
					  width = width || 200; // если не указана width, то width = 200 <br>
					  height = height || 100; // если нет height, то height = 100 <br>
					  title = title || "Предупреждение"; <br>
					} <br>
					function showWarning(options) { <br>
					  var width = options.width || 200; // по умолчанию <br>
					  var height = options.height || 100; <br>
					  var contents = options.contents || "Предупреждение"; <br>
					}
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------Date------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="date_object">
			<h1>Date Object</h1>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>new Date()</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Создает объект Date с текущей датой и временем: <br>
					-  +Date – переводится в милисекунды
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var now = new Date(); <br>
					alert( now ); <br>
					alert(+new Date) - милисекунды
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>new Date(milliseconds)</p>
			</div>
			<div class="second_column table_column">
				<p>Создает объект Date, значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0.</p>
			</div>
			<div class="third_column table_column">
				<p>
					// 24 часа после 01.01.1970 GMT+0 <br>
					var Jan02_1970 = new Date(3600 * 24 * 1000); <br>
					alert( Jan02_1970 );
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>new Date(datestring)</p>
			</div>
			<div class="second_column table_column">
				<p>Если единственный аргумент – строка, используется вызов Date.parse (см. далее) для чтения даты из неё.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					new Date(year, month, date, hours, minutes, seconds, ms)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента. Отсутствующие параметры, начиная с hours считаются равными нулю, а date – единице. <br>

					- Год year должен быть из 4 цифр. <br>
					- Отсчет месяцев month начинается с нуля 0.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00 <br>
					new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0 <br>

					var date = new Date(2011, 0, 1, 2, 3, 4, 567); <br>
					alert( date ); // 1.01.2011, 02:03:04.567
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.getFullYear() <br>
					.getMonth() <br>
					.getDate() <br>
					.getHours() <br>
					.getMinutes() <br>
					.getSeconds() <br>
					.getMilliseconds() <br>
						 <br>
					.getDay()
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Для доступа к компонентам даты-времени объекта Date используются следующие методы: <br>
					- Получить год (из 4 цифр) <br>
					- Получить месяц, от 0 до 11. <br>
					- Получить число месяца, от 1 до 31. <br>
					- Получить соответствующие компоненты. <br>
					- Получить номер дня в неделе. Неделя в JavaScript начинается с воскресенья, так что результат будет числом от 0(воскресенье) до 6(суббота). <br>
					 <br>
					Все методы, указанные выше, возвращают результат для местной временной зоны.
					 <br>
					Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT+0 (UTC):  <br>getUTCFullYear(), getUTCMonth(), getUTCDay(). То есть, сразу после "get" вставляется "UTC".
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// текущая дата <br>
					var date = new Date(); <br>
		
					// час в текущей временной зоне <br>
					alert( date.getHours() ); <br>

					// сколько сейчас времени в Лондоне? <br>
					// час в зоне GMT+0 <br>
					alert( date.getUTCHours() );
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.getTime()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, то есть того же вида, который используется в конструкторе new Date(milliseconds).
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.getTimezoneOffset()</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает разницу между местным и UTC-временем, в минутах.</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( new Date().getTimezoneOffset() ); // Для GMT-1 выведет 60
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					.setFullYear(y) <br>
					.setmonth(m) <br>
					.setDate(d) <br>
					.setHours(h) <br>
					.setMinutes(m) <br>
					.setSeconds(s) <br>
					.setMilliseconds(ms) <br>
					.setTime(ms)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					setFullYear(year [, month, date]) – устанавливает год; месяц и день необязательно. <br>
					setMonth(month [, date]) – устанавливает месяц; день необязательно.  <br>
					setDate(date) – устанавливает день;  <br>
					setHours(hour [, min, sec, ms]) – устанавливает часы; минуты, секунды и милисекунды необязательно.  <br>
					setMinutes(min [, sec, ms]) – устанавливает минуты; секунды и милисекунды необязательно.  <br>
					setSeconds(sec [, ms]) – устанавливает секунды; милисекунды необязательно.  <br>
					setMilliseconds(ms) – устанавливает миллисекунды.
					setTime(milliseconds) - устанавливает всю дату по миллисекундам с 01.01.1970 UTC. <br>
					 <br>
					Все они, кроме setTime(), обладают также UTC-вариантом, например: setUTCHours().
					 <br>
					Автоисправление – очень удобное свойство объектов Date. Оно заключается в том, что можно устанавливать заведомо некорректные компоненты (например 32 января), а объект сам себя поправит. Неправильные компоненты даты автоматически распределяются по остальным.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					today.setHours(0); <br>
					alert( today ); // сегодня, но час изменён на 0 <br>
				
					today.setHours(0, 0, 0, 0); <br>
					alert( today ); // сегодня, ровно 00:00:00.
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.toLocaleString(loc, options)</p>
			</div>
			<div class="second_column table_column">
				<p>Это делается вызовом date.toLocaleString(loc, options), в котором можно задать много настроек. Он позволяет указать, какие параметры даты нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var date = new Date(2014, 11, 31, 12, 30, 0); <br>
					var options = { <br>
					  era: 'long', <br>
					  year: 'numeric', <br>
					  month: 'long', <br>
					  day: 'numeric', <br>
					  weekday: 'long', <br>
					  timezone: 'UTC', <br>
					  hour: 'numeric', <br>
					  minute: 'numeric', <br>
					  second: 'numeric' <br>
					}; <br>

					alert( date.toLocaleString("ru", options) ); // среда, 31 декабря 2014 г. н.э. 12:30:00 <br>
					alert( date.toLocaleString("en-US", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					.toString() <br>
					.toDateString() <br>
					.toTimeString() <br>
					.toUTCString() <br>
					.toISOString()
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком. Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var d = new Date(); <br>
					alert( d.toString() ); // вывод, похожий на 'Wed Jan 26 2011 16:40:50 GMT+0300' <br>

					var d = new Date(); <br>
					alert( d.toISOString() ); // вывод, похожий на '2011-01-26T13:51:50.417Z'
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Date.parse(str)</p>
			</div>
			<div class="second_column table_column">
				<p>
					разбирает строку str в таком формате и возвращает соответствующее ей количество миллисекунд. Если это невозможно, Date.parse возвращает NaN. <br>
					Этот формат выглядит так: YYYY-MM-DDTHH:mm:ss.sssZ, где: <br>
					- YYYY-MM-DD – дата в формате год-месяц-день. <br>
					- Обычный символ T используется как разделитель. <br>
					- HH:mm:ss.sss – время: часы-минуты-секунды-миллисекунды. <br>
					- Часть 'Z' обозначает временную зону – в формате +-hh:mm, br либо символ Z, обозначающий UTC. По стандарту её можно не указывать, тогда UTC, но в Safari с этим ошибка, так что лучше указывать всегда. <br> 
					Также возможны укороченные варианты, например YYYY-MM-DD или YYYY-MM или даже только YYYY.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var msUTC = Date.parse('2012-01-26T13:51:50.417Z'); // зона UTC <br>
					alert( msUTC ); // 1327571510417 (число миллисекунд)

					var ms = Date.parse('2012-01-26T13:51:50.417-07:00'); <br>
					alert( ms ); // 1327611110417 (число миллисекунд)
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>performance.now()</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Date.now()</p>
			</div>
			<div class="second_column table_column">
				<p>
					возвращает дату сразу в виде миллисекунд. <br>
					Технически, он аналогичен вызову +new Date(), но в отличие от него не создаёт промежуточный объект даты, а поэтому – во много раз быстрее.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------Map------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="map_object">
			<h1>Map Object</h1>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Map</p>
			</div>
			<div class="second_column table_column">
				<p>
					Map – коллекция для хранения записей вида ключ:значение. <br>
					В отличие от объектов, в которых ключами могут быть только строки, в Map ключом может быть произвольное значение, например: <br>
					Аргументом new Map должен быть итерируемый объект (не обязательно именно массив). Везде утиная типизация, максимальная гибкость.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let map = new Map(); <br>
					let map = new Map([ <br>
					  ['1',  'str1'], <br>
					  [1,    'num1'], <br>
					  [true, 'bool1'] <br>
					]);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>get/set</p>
			</div>
			<div class="second_column table_column">
				<p>
					для сохранения и чтения значений. <br>
					ключи и значения сохраняются «как есть», без преобразований типов. <br>
					В качестве ключей map можно использовать и объекты:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					map.set('1', 'str1');   // ключ-строка <br>
					map.set(1, 'num1');     // число <br>
					map.set(true, 'bool1'); // булевое значение <br>
					 <br>
					// в обычном объекте это было бы одно и то же, <br>
					// map сохраняет тип ключа <br>
					alert( map.get(1)   ); // 'num1' <br>
					alert( map.get('1') ); // 'str1' <br>
					 <br>
					map <br>
					  .set('1', 'str1') <br>
					  .set(1, 'num1') <br>
					  .set(true, 'bool1'); <br>
					 <br>
					let user = { name: "Вася" }; <br>
					 <br>
					// для каждого пользователя будем хранить количество посещений <br>
					let visitsCountMap = new Map(); <br>
						 <br>
					// объект user является ключом в visitsCountMap <br>
					visitsCountMap.set(user, 123); <br>
						 <br>
					alert( visitsCountMap.get(user) ); // 123
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.size</p>
			</div>
			<div class="second_column table_column">
				<p>хранит общее количество записей в map.</p>
			</div>
			<div class="third_column table_column">
				<p>alert( map.size ); // 3</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.delete(key)</p>
			</div>
			<div class="second_column table_column">
				<p>удаляет запись с ключом key, возвращает true, если такая запись была, иначе false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.clear()</p>
			</div>
			<div class="second_column table_column">
				<p>удаляет все записи, очищает map</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.has(key)</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает true, если ключ есть, иначе false</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.keys()</p>
			</div>
			<div class="second_column table_column">
				<p>
					возвращает итерируемый объект для ключей, <br>
					Перебор осуществляется в порядке вставки.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let recipeMap = new Map([ <br>
					  ['огурцов',   '500 гр'], <br>
					  ['помидоров', '350 гр'], <br>
					  ['сметаны',   '50 гр'] <br>
					]); <br>
					// цикл по ключам <br>
					for(let fruit of recipeMap.keys()) { <br>
					  alert(fruit); // огурцов, помидоров, сметаны <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.values()</p>
			</div>
			<div class="second_column table_column">
				<p>
					-возвращает итерируемый объект для значений <br>
					-Перебор осуществляется в порядке вставки.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let recipeMap = new Map([ <br>
					  ['огурцов',   '500 гр'], <br>
					  ['помидоров', '350 гр'], <br>
					  ['сметаны',   '50 гр'] <br>
					]); <br>
					// цикл по значениям <br>
					for(let amount of recipeMap.values()) { <br>
					  alert(amount); // 500 гр, 350 гр, 50 гр <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.entries()</p>
			</div>
			<div class="second_column table_column">
				<p>
					-возвращает итерируемый объект для записей [ключ, значение], он используется по умолчанию в for..of. <br>
					-Перебор осуществляется в порядке вставки
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let recipeMap = new Map([ <br>
					  ['огурцов',   '500 гр'], <br>
					  ['помидоров', '350 гр'], <br>
					  ['сметаны',   '50 гр'] <br>
					]); <br>
					// цикл по записям [ключ,значение] <br>
					for(let entry of recipeMap) { // то же что и <br> recipeMap.entries() <br>
					  alert(entry); // огурцов,500 гр , и т.д., массивы по 2 значения <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.forEach( (value, key, map)</p>
			</div>
			<div class="second_column table_column">
				<p>стандартный метод forEach, аналогичный встроенному в массивы:</p>
			</div>
			<div class="third_column table_column">
				<p>
					let recipeMap = new Map([ <br> 
					  ['огурцов',   '500 гр'], <br> 
					  ['помидоров', '350 гр'], <br> 
					  ['сметаны',   '50 гр'] <br> 
					]); <br> 
					recipeMap.forEach( (value, key, map) => { <br> 
					  alert(`${key}: ${value}`); // огурцов: 500 гр, и т.д. <br> 
					});
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>WeakMap</p>
			</div>
			<div class="second_column table_column">
				<p>
					особый вид Map не препятствующий сборщику мусора удалять свои элементы. <br>
					То есть, если некий объект присутствует только в  WeakMap – он удаляется из памяти. <br>

					- Только объекты в качестве ключей. <br>
					- Нет свойства size. <br>
					- Нельзя перебрать элементы итератором или forEach. <br>
					- Нет метода clear().
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------SET------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="set_object">
			<h1>Set Object</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>set</p>
			</div>
			<div class="second_column table_column">
				<p>коллекция для хранения множества значений, причём каждое значение может встречаться лишь один раз.</p>
			</div>
			<div class="third_column table_column">
				<p>
					let set = new Set(); <br>
					let vasya = {name: "Вася"}; <br>
					let petya = {name: "Петя"}; <br>
					let dasha = {name: "Даша"}; <br>

					// посещения, некоторые пользователи заходят много раз <br>
					set.add(vasya); <br>
					set.add(petya); <br>
					set.add(dasha); <br>
					set.add(vasya); <br>
					set.add(petya); <br>

					// set сохраняет только уникальные значения <br>
					alert( set.size ); // 3 <br>

					set.forEach( user => alert(user.name ) ); // Вася, Петя, Даша
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.add(item)</p>
			</div>
			<div class="second_column table_column">
				<p>добавляет в коллекцию item, возвращает set (чейнится).</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.delete(item)</p>
			</div>
			<div class="second_column table_column">
				<p>удаляет item из коллекции, возвращает true, если он там был, иначе false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.has(item)</p>
			</div>
			<div class="second_column table_column">
				<p>возвращает true, если item есть в коллекции, иначе false.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.clear()</p>
			</div>
			<div class="second_column table_column">
				<p>очищает set.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					.keys() <br>
					.values() <br>
					.entries() <br>
						<br>
					.forEach()
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Перебор аналогично Map. <br>
					Либо <br>
					.forEach(value,valueAgain,set) => {} <br>
					P.S. в set , value идёт 2 раза к ряду
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let set = new Set(["апельсины", "яблоки", "бананы"]);<br>
					// то же, что: for(let value of set) <br>
					set.forEach((value, valueAgain, set) => { <br>
					  alert(value); // апельсины, затем яблоки, затем бананы <br>
					});
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>WeakSet</p>
			</div>
			<div class="second_column table_column">
				<p>
					особый вид Set не препятствующий сборщику мусора удалять свои элементы. <br>
					То есть, если некий объект присутствует только в WeakSet– он удаляется из памяти. <br>
					- Только объекты в качестве ключей. <br>
					- Нет свойства size. <br>
					- Нельзя перебрать элементы итератором или forEach. <br>
					- Нет метода clear().
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- ---------------------------------------------------------Видимость и Замыкания------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="visibility_of_var">
			<h1>Видимость и Замыкания</h1>
		</div>
		
		<div class="zebra1 theory_row">
			<h2>Theory:</h2>
			<p>
				Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны. Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные. <br>
				 «Понимать замыкания» в JavaScript означает понимать следующие вещи: <br>
				1.	- Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window. <br>
				2.	- При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, в котором она была создана. <br>
				3.	- При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».
			</p>
		</div>

		<div class="tips_table_row zebra2">
			<div class="first_column table_column">
				<p>window</p>
			</div>
			<div class="second_column table_column">
				<p>
					-В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object). <br>
					-Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами объекта  window. <br>
					Выполнение скрипта происходит в две фазы: <br>
					1.	На первой фазе происходит инициализация, подготовка к запуску. <br>
					Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window. <br>
					Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined. <br>
					2.	На второй фазе – собственно, выполнение.
					Присваивание (=) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они undefined.
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra1">
			<div class="first_column table_column">
				<p>LexicalEnvironment</p>
			</div>
			<div class="second_column table_column">
				<p>
					Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске. <br>

					При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные. Процесс инициализации выполняется в том же порядке, что и для глобального объекта, который, вообще говоря, является частным случаем лексического окружения. <br>
					В отличие от window, объект LexicalEnvironment является внутренним, он скрыт от прямого доступа. <br>
					Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window. <br>
					Переменную во внешней области видимости можно не только читать, но и изменять.
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="first_column table_column">
				<p>[[Scope]]</p>
			</div>
			<div class="second_column table_column">
				<p>
					Каждый раз При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана. <br>
					Заметим, что если переменная не найдена во внешнем объекте переменных, то она ищется в ещё более внешнем (через [[Scope]] внешней функции), то есть, такой пример тоже будет работать. <br>
					Исключение: При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.
				</p>
			</div>
		</div>


		<div class="tips_table_row zebra1">
			<div class="first_column table_column">
				<p>Module</p>
			</div>
			<div class="second_column table_column">
				<p>
					Если подключить скрипт к странице «как есть», то возможен конфликт с переменными, которые она использует. <br>
					Чтобы проблемы не было, всего-то нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу. <br>
					Модуль при помощи замыканий – это оборачивание пакета функционала в единую внешнюю функцию, которая тут же выполняется. <br>
					Файл, оформленный как модуль: <br>
					(function() {<br> 
					All your code… <br>
					}()); <br>
					В начале и в конце стоят скобки, так как иначе была бы ошибка. br Ошибка при его запуске произойдет потому, что браузер, видя ключевое слово function в основном потоке кода, попытается прочитать Function Declaration, а здесь имени нет. Дело в том, что «на месте» разрешено вызывать только Function Expression. <br>

					Аналог:  <br>
					 ;(function() { <br>
					All your code… <br>
					}()); <br>
						 <br>
					!function() {  <br>
					All your code…  <br>
					}();  <br>
						 <br>
					+function() {  <br>
					All your code…  <br>
					}();
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------OOP Functional------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="oop_functional">
			<h1>OOP Functional</h1>
		</div>
		

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Theory:</h2>
				<p>
					объектно-ориентированное программирование (ООП), которое позволяет группировать функции и данные в единой сущности – «объекте». <br>
					При объектно-ориентированной разработке мы описываем происходящее на уровне объектов, которые создаются, меняют свои свойства, взаимодействуют друг с другом и (в случае браузера) со страницей, в общем, живут. <br>
					Например, «пользователь», «меню», «компонент интерфейса»… При объектно-ориентированном подходе каждый объект должен представлять собой интуитивно понятную сущность, у которой есть методы и данные <br>
					Классом в объектно-ориентированной разработке называют шаблон/программный код, предназначенный для создания объектов и методов. <br>
					Один из важнейших принципов ООП – отделение внутреннего интерфейса от внешнего. <br>
					- Внутренний интерфейс – это свойства и методы, доступ к которым может быть осуществлен только из других методов объекта, их также называют «приватными» (есть и другие термины, встретим их далее).  <br>
					- Внешний интерфейс – это свойства и методы, доступные снаружи объекта, их называют «публичными». <br>
					Локальные переменные, включая параметры конструктора, можно считать приватными свойствами. <br>
					Свойства, записанные в this, можно считать публичными. <br>
					- Для большего контроля над присвоением и чтением значения вместо свойства делают «функцию-геттер» и «функцию-сеттер», геттер возвращает значение, сеттер – устанавливает.
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					function CoffeeMachine(power) {  <br>
					  this.waterAmount = 0; <br>

					  var WATER_HEAT_CAPACITY = 4200;  <br>
					
					  var self = this; <br>
						 <br>
					  function getBoilTime() { <br>
					      return self.waterAmount * WATER_HEAT_CAPACITY * 80 / power; <br>
					    } <br>

					  function onReady() { <br>
					    alert( 'Кофе готов!' ); <br>
					  } <br>

					  this.run = function() { <br>
					    setTimeout(onReady, getBoilTime()); <br>
					  }; <br>

					} <br>

					var coffeeMachine = new CoffeeMachine(100000); <br>
					coffeeMachine.waterAmount = 200; <br>

					coffeeMachine.run();
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>setter</p>
			</div>
			<div class="second_column table_column">
				<p>
					Для лучшего контроля над свойством его делают приватным, а запись значения осуществляется через специальный метод, который называют «сеттер» (setter method). <br>

					- Если свойство предназначено только для чтения, то может быть только геттер, только для записи – только сеттер.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					 // "умная" установка свойства <br>
					  this.setWaterAmount = function(amount) {<br>
					    if (amount < 0) {<br>
					      throw new Error("Значение должно быть положительным");<br>
					    }<br>
					    if (amount > capacity) {<br>
					      throw new Error("Нельзя залить воды больше, чем " + capacity);<br>
					    }<br>
					    waterAmount = amount;<br>
					  };
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>getter</p>
			</div>
			<div class="second_column table_column">
				<p>
					Для того, чтобы дать возможность внешнему коду узнать его значение, создадим специальную функцию – «геттер» (getter method).
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					this.getWaterAmount = function() { <br>
					    return waterAmount; <br>
					  };
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>setter-getter</p>
			</div>
			<div class="second_column table_column">
				<p>В качестве альтернативы к паре геттер/сеттер применяют единую функцию, которая без аргументов ведёт себя как геттер, а с аргументом – как сеттер.</p>
			</div>
			<div class="third_column table_column">
				<p>
					this.waterAmount = function(amount) { <br>
				    // вызов без параметра, значит режим геттера, возвращаем свойство <br>
				    if (!arguments.length) return waterAmount;<br>

				    // иначе режим сеттера <br>
				    if (amount < 0) { <br>
				      throw new Error("Значение должно быть положительным");<br>
				    }<br>
				    if (amount > capacity) {<br>
				      throw new Error("Нельзя залить воды больше, чем " + capacity);<br>
				    }<br>

				    waterAmount = amount;<br>
				  };
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Functional inheritance</p>
			</div>
			<div class="second_column table_column">
				<p>
					Наследование – это создание новых «классов» на основе существующих. <br>

					  Machine.call(this); // отнаследовать <br>

					Наследование реализовано вызовом Machine.call(this) в начале конструктора CoffeeMachine. <br>
					Он вызывает функцию Machine, передавая ей в качестве контекста this текущий объект. Machine, в процессе выполнения, записывает в this различные полезные свойства и методы, в нашем случае this.enable и this.disable. <br>
					Наследник не имеет доступа к приватным свойствам родителя. <br>
					Чтобы наследник имел доступ к свойству, оно должно быть записано в this. При этом, чтобы обозначить, что свойство является внутренним, его имя начинают с подчёркивания _. brПодчёркивание в начале свойства – общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют защищёнными.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function Machine() { <br>
					  var enabled = false; <br>

					  this.enable = function() { <br>
					    enabled = true; <br>
					  }; <br>

					  this.disable = function() { <br>
					    enabled = false; <br>
					  }; <br>
					} <br>

					function CoffeeMachine(power) { <br>
					  Machine.call(this); // отнаследовать <br>

					  var waterAmount = 0; <br>

					  this.setWaterAmount = function(amount) { <br>
					    waterAmount = amount; <br>
					  }; <br>

					} <br>

					var coffeeMachine = new CoffeeMachine(10000); <br>

					coffeeMachine.enable(); <br>
					coffeeMachine.setWaterAmount(100); <br>
					coffeeMachine.disable(); <br>

					this._power = power;
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------OOP prototype------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="oop_prototype">
			<h1>OOP Prototype</h1>
		</div>
		
		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>__proto__</p>
			</div>
			<div class="second_column table_column">
				<p>
					прототип – это «резервное хранилище свойств и методов» объекта, автоматически используемое при поиске. <br>
					Объект, на который указывает ссылка __proto__, называется «прототипом». В данном случае получилось, что animal является прототипом для rabbit. <br>
					Также говорят, что объект rabbit «прототипно наследует» от animal. <br>
					В JavaScript невозможно унаследовать от двух и более объектов. Ссылка __proto__ – только одна. В этом случае используется отдельный класс - примеси, с которого копируются свойства в нужный прототип.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var animal = { <br>
					  eats: true <br>
					}; <br>
					var rabbit = { <br>
					  jumps: true <br>
					}; <br>

					rabbit.__proto__ = animal; <br>
						 <br>
					// в rabbit можно найти оба свойства <br>
					alert( rabbit.jumps ); // true <br>
					alert( rabbit.eats ); // true <br>
						 <br>
					for(var key in sayHiMixin) User.prototype[key] = sayHiMixin[key];
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>prototype</p>
			</div>
			<div class="second_column table_column">
				<p>
					При работе с конструктором: <br>
					Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype. <br>
					При создании объекта через new, в его прототип __proto__ записывается ссылка из prototypeфункции-конструктора.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Var animal = { <br>
					  eats: true <br>
					}; <br>

					function Rabbit(name) { <br>
					  this.name = name; <br>
					} <br>

					Rabbit.prototype = animal; <br>

					var rabbit = new Rabbit(“Кроль”); //  rabbit.__proto__ == animal <br>

					alert( rabbit.eats ); // true
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>super</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов super.parentProperty позволяет из метода объекта получить свойство его прототипа. <br>
					При обращении через super используется [[HomeObject]] текущего метода, и от него берётся __proto__. Поэтому super работает только внутри новых методов, и не работает через обычные свойства-функции
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					let animal = { <br>
					  walk() { <br>
					    alert("I'm walking"); <br>
					  } <br>
					}; <br>
						 <br>
					let rabbit = { <br>
					  __proto__: animal, <br>
					  walk() { <br>
					    alert(super.walk); // walk() { … } <br>
					    super.walk(); // I'm walking <br>
					  } <br>
					};
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="first_column table_column">
				<p>Class inheritance</p>
			</div>
			<div class="second_column table_column">
				<div> <img src="img/proto.png" alt="proto" width="410px" height="300px"> </div>
				<p>
					Поэтому говорят, что "все объекты наследуют от Object", а если более точно, то от Object.prototype. <br>
					Объект Object.prototype – вершина иерархии, единственный, у которого __proto__ равно null.
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.getPrototypeOf(obj)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает obj.__proto__</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.setPrototypeOf(obj, proto)</p>
			</div>
			<div class="second_column table_column">
				<p>Устанавливает obj.__proto__ = proto</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Object.create(proto, descriptors)</p>
			</div>
			<div class="second_column table_column">
				<p>Создаёт пустой объект с __proto__, равным первому аргументу, второй необязательный аргумент может содержать дескрипторы свойств</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Object.create(null);</p>
			</div>
			<div class="second_column table_column">
				<p>
					var data = Object.create(null); <br>
					Объект, создаваемый при помощи Object.create(null) не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var data = Object.create(null); <br>
					data.text = "Привет"; <br>

					alert(data.text); // Привет <br>
					alert(data.toString); // undefined
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------Constructor/class------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="constructor_class">
			<h1>Constructor/class</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Constructor</p>
			</div>
			<div class="second_column table_column">
				<p>
					Объекты могут быть созданы при помощи функций-конструкторов: <br>
					чтобы выделить функции, задуманные как конструкторы, их называют с большой буквы: Animal, а не animal. <br>
					- Любая функция может быть вызвана с new, при этом она получает новый пустой объект в качестве this, в который она добавляет свойства. Если функция не решит возвратить свой объект, то её результатом будет this. <br>
					Детальнее – функция, запущенная через new, делает следующее: <br>
					1.	Создаётся новый пустой объект. <br>
					2.	Ключевое слово this получает ссылку на этот объект. <br>
					3.	Функция выполняется. Как правило, она модифицирует this (т.е. этот новый объект), добавляет методы, свойства. <br>
					4.	Возвращается this. <br>
					Как правило, конструкторы ничего не возвращают. Их задача – записать всё, что нужно, в this, который автоматически станет результатом. <br>
					Но если явный вызов return всё же есть, то применяется простое правило: <br>
					- При вызове return с объектом, будет возвращён он, а не this. <br>
					- При вызове return с примитивным значением, оно будет отброшено. <br>
					Иными словами, вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this. <br>

					Методы и свойства, которые не привязаны к конкретному экземпляру объекта, называют «статическими». Их записывают прямо в саму функцию-конструктор. <br>
					"Фабричный статический метод" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					function Animal(name) { <br>
					  this.name = name; <br>
					  this.canWalk = true; <br>
					} <br>
					var animal = new Animal("ёжик"); <br>
					 <br>

					function User(name) { <br>
					  this.name = name; <br>

					  this.sayHi = function() { <br>
					    alert( "Моё имя: " + this.name ); <br>
					  }; <br>
					} <br>
							 <br>
					var ivan = new User("Иван"); <br>

					ivan.sayHi(); // Моё имя: Иван <br>

						 <br>
					function Article() { <br>
					  Article.count++; <br>
					} <br>
							 <br>
					Article.count = 0; // статическое свойство-переменная <br>
					Article.DEFAULT_FORMAT = "html"; // статическое свойство-константа <br>
						 <br>
					Фабричный метод:  <br>
					function User() { <br>
					  this.sayHi = function() { <br>
					    alert(this.name) <br>
					  }; <br>
					} <br>
							 <br>
					User.createAnonymous = function() { <br>
					  var user = new User; <br>
					  user.name = 'Аноним'; <br>
					  return user; <br>
					} <br>
							 <br>
					User.createFromData = function(userData) { <br>
					  var user = new User; <br>
					  user.name = userData.name; <br>
					  user.age = userData.age; <br>
					  return user; <br>
					} <br>

					// Использование <br>

					var guest = User.createAnonymous(); <br>
					guest.sayHi(); // Аноним <br>
					 <br>
					var knownUser = User.createFromData({ <br>
					  name: 'Вася', <br>
					  age: 25 <br>
					}); <br>
					knownUser.sayHi(); // Вася
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>class</p>
			</div>
			<div class="second_column table_column">
				<p>
					Новая конструкция class – удобный «синтаксический сахар» для задания конструктора вместе с прототипом.
					class Название [extends Родитель]  { <br>
					  constructor <br>
					  методы <br>
					} <br>

					Функция constructor запускается при создании new User, остальные методы записываются в User.prototype. <br>
					- User нельзя вызывать без new, будет ошибка. <br>
					- Объявление класса с точки зрения области видимости ведёт себя как let. В частности, оно видно только в текущем блоке и только в коде, который находится ниже объявления (Function Declaration видно и до объявления). <br>
					
					Методы, объявленные внутри class, также имеют ряд особенностей: <br>
					-Метод sayHi является именно методом, то есть имеет доступ к super. <br>
					-Все методы класса работают в строгом режиме use strict, даже если он не указан. <br>
					-Все методы класса не перечислимы. То есть в цикле for..in по объекту их не будет.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					class User { <br>

					  constructor(name) { <br>
					    this.name = name; <br>
					  } <br>
					  sayHi() { <br>
					    alert(this.name); <br>
					  } <br>
					} <br>

					let User = class { <br>
					  sayHi() { alert('Привет!'); } <br>
					}; <br>

					new User().sayHi();
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>get/set</p>
			</div>
			<div class="second_column table_column">
				<p>
					В классах, как и в обычных объектах, можно объявлять геттеры и сеттеры через get/set, а также использовать […] для свойств с вычисляемыми именами: <br>
					class не позволяет задавать свойства-значения. предполагается, что в прототипе должны быть только методы. Если свойство-значение, всё же, необходимо, то можно создать геттер, который будет нужное значение возвращать.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					class User { <br>
					  constructor(firstName, lastName) { <br>
					    this.firstName = firstName; <br>
					    this.lastName = lastName; <br>
					  } <br>

					  // геттер <br>
					  get fullName() { <br>
					    return `${this.firstName} ${this.lastName}`; <br>
					  } <br>

					  // сеттер <br>
					  set fullName(newValue) { <br>
					    [this.firstName, this.lastName] = newValue.split(' '); <br>
					  } <br>

					  // вычисляемое название метода <br>
					  ["test".toUpperCase()]() { <br>
					    alert("PASSED!"); <br>
					  } <br>

					}; <br>

					let user = new User("Вася", "Пупков"); <br>
					alert( user.fullName ); // Вася Пупков <br>
					user.fullName = "Иван Петров"; <br>
					alert( user.fullName ); // Иван Петров <br>
					user.TEST(); // PASSED!
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>static</p>
			</div>
			<div class="second_column table_column">
				<p>Класс, как и функция, является объектом. Статические свойства класса User – это свойства непосредственно User, то есть доступные из него «через точку».</p>
			</div>
			<div class="third_column table_column">
				<p>
					class User { <br>
					  constructor(firstName, lastName) { <br>
					    this.firstName = firstName; <br>
					    this.lastName = lastName; <br>
					  } <br>

					  static createGuest() { <br>
					    return new User("Гость", "Сайта"); <br>
					  } <br>
					}; <br>

					let user = User.createGuest(); <br>

					alert( user.firstName ); // Гость <br>

					alert( User.createGuest ); // createGuest ... (функция)
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>extends</p>
			</div>
			<div class="second_column table_column">
				<p>
					Наследование: <br>
					class Child extends Parent { <br>
					  ... <br>
					} <br>

					class Animal { } <br>
					class Rabbit extends Animal { } <br>
					alert( Rabbit.prototype.__proto__ == Animal.prototype ); // true
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					class Animal { <br>
					  constructor(name) {<br>
					    this.name = name;<br>
					  }<br>

					  walk() {<br>
					    alert("I walk: " + this.name);<br>
					  }<br>
					}<br>

					class Rabbit extends Animal {<br>
					  walk() {<br>
					    super.walk();<br>
					    alert("...and jump!");<br>
					  }<br>
					}
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------JSON------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="json">
			<h1>JSON</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>JSON.parse(str)</p>
			</div>
			<div class="second_column table_column">
				<p>
					превратит строку с данными в формате JSON в JavaScript-объект/массив/значение. <br>

					Для интеллектуального восстановления из строки у JSON.parse(str, reviver) есть второй параметр reviver, который является функцией function(key, value). <br>
					Если она указана, то в процессе чтения объекта из строки JSON.parse передаёт ей по очереди все создаваемые пары ключ-значение и может возвратить либо преобразованное значение, либо undefined, если его нужно пропустить.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var numbers = "[0, 1, 2, 3]"; <br>

					numbers = JSON.parse(numbers); <br>

					alert( numbers[1] ); // 1 <br>

					// дата в строке - в формате UTC <br>
					var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}'; <br>
					var event = JSON.parse(str, function(key, value) { <br>
					  if (key == 'date') return new Date(value); <br>
					  return value; <br>
					}); <br>
					alert( event.date.getDate() ); // теперь сработает!
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>JSON.stringify(value, replacer, space)</p>
			</div>
			<div class="second_column table_column">
				<p>
					преобразует («сериализует») значение в JSON-строку. <br>

					При сериализации объекта вызывается его метод toJSON.
					Если такого метода нет – перечисляются его свойства, кроме функций.. <br>

					Дата превратилась в строку. Это не случайно: у всех дат есть встроенный метод toJSON. Его результат в данном случае – строка в таймзоне UTC. <br>

					Во втором параметре JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации. <br>

					Для более сложных ситуаций вторым параметром можно передать функцию function(key, value), которая возвращает сериализованное value либо undefined, если его не нужно включать в результат:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var event = { <br>
					  title: "Конференция", <br>
					  date: "сегодня" <br>
					}; <br>

					var str = JSON.stringify(event); <br>
					alert( str ); // {"title":"Конференция","date":"сегодня"} <br>

					// Обратное преобразование. <br>
					event = JSON.parse(str); <br>

					var user = { <br>
					  name: "Вася", <br>
					  age: 25, <br>
					  window: window <br>
					}; <br>

					alert( JSON.stringify(user, ["name", "age"]) ); <br>
					// {"name":"Вася","age":25}
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------Errors------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="errors">
			<h1>Errors</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>try..catch</p>
			</div>
			<div class="second_column table_column">
				<p>
					при ошибке в try скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch. <br>
					try { <br>
					  // код ... <br>
					} catch (err) { <br>
					  // обработка ошибки <br>
					} <br>
					Работает она так: <br>
					1.	Выполняется код внутри блока try. <br>
					2.	Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение доходит до конца tryи потом прыгает через catch. <br>
					3.	Если в нём возникнет ошибка, то выполнение try на ней прерывается, и управление прыгает в начало блока catch(err).
					При этом переменная err (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					try { <br>
					  alert('Начало блока try'); <br>

					  lalala; // ошибка, переменная не определена!<br>

					  alert('Конец блока try'); <br>

					} catch(e) {<br>

					  alert('Ошибка ' + e.name + ":" + e.message + "\n" + e.stack); <br>
					}<br>

					alert("Потом код продолжит выполнение...");
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Error object: err</p>
			</div>
			<div class="second_column table_column">
				<p>
					name - Тип ошибки. Например, при обращении к несуществующей переменной: "ReferenceError". <br>
					message - Текстовое сообщение о деталях ошибки. <br>
					stack - Везде, кроме IE8-, есть также свойство stack, которое содержит строку с информацией о последовательности вызовов, которая привела к ошибке.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>throw</p>
			</div>
			<div class="second_column table_column">
				<p>
					Оператор throw генерирует ошибку. <br>
					Синтаксис: throw &lt;объект ошибки&gt;. <br>
					Технически в качестве объекта ошибки можно передать что угодно, это может быть даже не объект, а число или строка, но всё же лучше, чтобы это был объект, желательно – совместимый со стандартным, то есть чтобы у него были как минимум свойства name и message. <br>
					В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой. <br>
					В JavaScript встроен ряд конструкторов для стандартных ошибок: SyntaxError, ReferenceError, RangeError и некоторые другие. Можно использовать и их, но только чтобы не было путаницы.
				</p>
			</div>
			<div class="third_column table_column">
				<p> 
					var data = '{ "age": 30 }'; // данные неполны <br>

					try { <br>

					  var user = JSON.parse(data); // <-- выполнится без ошибок <br>

					  if (!user.name) { <br>
					    throw new SyntaxError("Данные некорректны"); <br>
					  } <br>

					  alert( user.name ); <br>

					} catch (e) { <br>
					  alert( "Извините, в данных ошибка" ); <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>finally</p>
			</div>
			<div class="second_column table_column">
				<p>
					•	Секцию finally используют, чтобы завершить начатые операции при любом варианте развития событий. <br>
					try { <br>
					   .. пробуем выполнить код .. <br>
					} catch(e) { <br>
					   .. перехватываем исключение .. <br>
					} finally { <br>
					   .. выполняем всегда .. <br>
					}
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					try { <br>
					  alert( 'try' ); <br>
					  if (confirm('Сгенерировать ошибку?')) BAD_CODE(); <br>
					} catch (e) { <br>
					  alert( 'catch' ); <br>
					} finally { <br>
					  alert( 'finally' ); <br>
					}
				</p>
			</div>
		</div>


		<!-- ---------------------------------------------------DOM------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="dom">
			<h1>DOM</h1>
		</div>
	

		<div class="zebra1 theory_row">
			<h2>Theory:</h2>
			<p>
				-DOM нужен для того, чтобы манипулировать страницей – читать информацию из HTML, создавать и изменять элементы. <br>
				-DOM-модель – это внутреннее представление HTML-страницы в виде дерева. <br>
				-Все элементы страницы, включая теги, текст, комментарии, являются узлами DOM. <br>
				Узел DOM – это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.
				Нестандартные свойства и методы видны только в JavaScript и никак не влияют на отображение соответствующего тега.
				<br>
				<img src="img/dom1.png" alt="dom1"> <br>
				&lt;HTML&gt; = document.documentElement <br>
				&lt;BODY&gt; = document.body <br>
				- Дочерние элементы (или дети) – элементы, которые лежат непосредственно внутри данного. Например, внутри &lt;HTML&gt; обычно лежат &lt;HEAD&gt; и &lt;BODY&gt;.  <br>
				- Потомки – все элементы, которые лежат внутри данного, вместе с их детьми, детьми их детей и так далее. То есть, всё поддерево DOM. <br>
				Псевдо-массив childNodes хранит все дочерние элементы, включая текстовые. <br>
				    for (var i = 0; i &lt; document.body.childNodes.length; i++) { <br>
				      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT <br>
				    } <br>
				Доступ к элементам слева и справа данного можно получить по ссылкам previousSibling / nextSibling. <br>
				Родитель доступен через parentNode. Если долго идти от одного элемента к другому, то рано или поздно дойдёшь до корня DOM, то есть до document.documentElement, а затем и document.
				<br>
				<img src="img/dom2.png" alt="dom2"> <br>
				- children – только дочерние узлы-элементы, то есть соответствующие тегам. <br>
				- firstElementChild, lastElementChild – соответственно, первый и последний дети-элементы. <br>
				- previousElementSibling, nextElementSibling – соседи-элементы. <br>
				- parentElement – родитель-элемент. <br>
				    for (var i = 0; i < document.body.children.length; i++) { <br>
				      alert( document.body.children[i] ); // DIV, UL, DIV, SCRIPT <br>
				    } <br>
				TABLE <br>
				-table.rows – коллекция строк TR таблицы. <br>
				-table.caption/tHead/tFoot – ссылки на элементы таблицы CAPTION, THEAD, TFOOT. <br>
				-table.tBodies – коллекция элементов таблицы TBODY, по спецификации их может быть несколько. <br>
				THEAD/TFOOT/TBODY <br>
				-tbody.rows – коллекция строк TR секции. <br>
				TR <br>
				-tr.cells – коллекция ячеек TD/TH <br>
				-tr.sectionRowIndex – номер строки в текущей секции THEAD/TBODY <br>
				-tr.rowIndex – номер строки в таблице <br>
				TD/TH <br>
				-td.cellIndex – номер ячейки в строке
			</p>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.nodeType</p>
			</div>
			<div class="second_column table_column">
				<p>
					Тип узла содержится в его свойстве nodeType. <br>
					1 – element <br>
					3 – text
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var childNodes = document.body.childNodes; <br>

				    for (var I = 0; I < childNodes.length; i++) { <br>

				      // отфильтровать не-элементы <br>
				      if (childNodes[i].nodeType != 1) continue; <br>

				      alert( childNodes[i] );
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.contains(child)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Метод для проверки на вложенность <br>
					Возвращает true, если parent содержит child или parent == child.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var result = parent.contains(child);
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.compareDocumentPosition(node)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Метод compareDocumentPosition – более мощный, чем contains, он предоставляет одновременно информацию и о содержании и об относительном порядке элементов. <br>

					Возвращаемое значение – битовая маска <br>

					Биты	Число	Значение <br>
					000000	0	nodeA и nodeB -- один и тот же узел <br>
					000001	1	Узлы в разных документах (или один из них не в документе) <br>
					000010	2	nodeB предшествует nodeA (в порядке обхода документа) <br>
					000100	4	nodeA предшествует nodeB <br>
					001000	8	nodeB содержит nodeA <br>
					010000	16	nodeA содержит nodeB <br>
					100000	32	Зарезервировано для браузера
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var result = nodeA.compareDocumentPosition(nodeB);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.tagName <br>
					.nodeName
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Существует целых два свойства: nodeName и tagName, которые содержат название(тег) элемента узла. <br>
					Название HTML-тега всегда находится в верхнем регистре.
					- Свойство tagName есть только у элементов Element (в IE8- также у комментариев, но это ошибка в браузере). <br>
					- Свойство nodeName определено для любых узлов Node, для элементов оно равно tagName, а для не-элементов обычно содержит строку с типом узла.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					alert( document.body.firstChild.nodeName ); // #comment <br>
				    alert( document.body.firstChild.tagName ); // undefined (в IE8- воскл. знак "!") <br>

				    // для документа <br>
				    alert( document.nodeName ); // #document, т.к. корень DOM -- не элемент <br>
				    alert( document.tagName ); // undefined
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.createElement(tag)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Создает новый элемент с указанным тегом: <br>
					document.createElement(tag)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var div = document.createElement('div');
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.createTextNode(text)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Создает новый *текстовый* узел с данным текстом: <br>
					document.createTextNode(text)
				</p>
			</div>
			<div class="third_column table_column">
				<p>var textElem = document.createTextNode('Тут был я');</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.appendChild(elem)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Добавляет elem в конец дочерних элементов parentElem. <br>
					parentElem.appendChild(elem)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var newLi = document.createElement('li'); <br>
						  newLi.innerHTML = 'Привет, мир!'; <br>
						list.appendChild(newLi); 
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.insertBefore(elem, nextSibling)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вставляет elem в коллекцию детей parentElem, перед элементом nextSibling. <br>
					parentElem.insertBefore(elem, nextSibling) <br>
					если вторым аргументом указать null, то insertBefore сработает как appendChild:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var newLi = document.createElement('li'); <br>
					  newLi.innerHTML = 'Привет, мир!'; <br>
					list.insertBefore(newLi, list.children[1]);
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					.insertAdjacentHTML(where, html); <br>

					.insertAdjacentElement(where, newElem) <br>

					.insertAdjacentText(where, text)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					elem.insertAdjacentHTML(where, html); <br>
					позволяет вставлять произвольный HTML в любое место документа, в том числе и между узлами! <br>
					- elem.insertAdjacentElement(where, newElem) – вставляет в произвольное место не строку HTML, а элемент newElem. <br>
					- elem.insertAdjacentText(where, text) – создаёт текстовый узел из строки text и вставляет его в указанное место относительно elem. <br>
					html - Строка HTML, которую нужно вставить <br>
					where - Куда по отношению к elem вставлять строку. Всего четыре варианта: <br>
					1.	beforeBegin – перед elem. <br>
					2.	afterBegin – внутрь elem, в самое начало. <br>
					3.	beforeEnd – внутрь elem, в конец. <br>
					4.	afterEnd – после elem.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var ul = document.body.children[0]; <br>
					  var li5 = ul.children[2]; <br>

					  li5.insertAdjacentHTML("beforeBegin", "&lt;li>3&lt;/li>&lt;li>4&lt;/li>");
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.append(...nodes) <br>

					.prepend(...nodes) <br>

					.after(...nodes) <br>

					.before(...nodes) <br>
 
					.replaceWith(...nodes)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					    // добавим элемент в конец &lt;body&gt; <br>
					    var p = document.createElement('p'); <br>
					    document.body.append(p); <br>

					    var em = document.createElement('em');<br>
					    em.append('Мир!');<br>

					    // вставить в параграф текстовый и обычный узлы<br>
					    p.append("Привет, ", em);<br>

					    // добавить элемент после <p> <br>
					    p.after(document.createElement('hr'))
				</p>
			</div>
			<div class="third_column table_column">
				<p></p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.cloneNode(true)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов elem.cloneNode(true) создаст «глубокую» копию элемента – вместе с атрибутами, включая подэлементы. Если же вызвать с аргументом false, то копия будет сделана без дочерних элементов.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  // создать копию узла <br>
 					 var div2 = div.cloneNode(true);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.removeChild(elem)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Удаляет elem из списка детей parentElem. <br>
					parentElem.removeChild(elem) <br>
					метод вставки автоматически удаляют вставляемый элемент со старого места.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.replaceChild(newElem, elem)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Среди детей parentElem удаляет elem и вставляет на его место newElem. <br>
					parentElem.replaceChild(newElem, elem) <br>
					метод вставки автоматически удаляют вставляемый элемент со старого места.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p> .remove()</p>
			</div>
			<div class="second_column table_column">
				<p>
					elem.remove() <br>
					удаляет элемент напрямую, не требуя ссылки на родителя
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					.innerHTML
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство innerHTML. Оно позволяет получить HTML-содержимое элемента в виде строки. В innerHTML можно и читать и писать. <br>
					Значение, возвращаемое innerHTML – всегда валидный HTML-код. При записи можно попробовать записать что угодно, но браузер исправит ошибки:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					    alert( document.body.innerHTML ); // читаем текущее содержимое <br>
					    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое <br>

					    document.body.innerHTML = '&lt;b&gt;тест'; // незакрытый тег <br>
					    alert( document.body.innerHTML ); // &lt;b&gt;тест&lt;/b&gt; (исправлено)
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.outerHTML</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство outerHTML содержит HTML элемента целиком. <br>
					Изменить outerHTML элемента невозможно.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var div = document.body.children[0]; <br>
  					alert( div.outerHTML ); // &lt;div&gt;Привет &lt;b&gt;Мир&lt;/b&gt;&lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.data</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство innerHTML есть только у узлов-элементов. <br>
					Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					    for (var i = 0; i < document.body.childNodes.length; i++) { <br>
      						alert( document.body.childNodes[i].data );
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.textContent</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство textContent содержит только текст внутри элемента, за вычетом всех &lt;тегов&gt;.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var news = document.body.children[0]; <br>

					  // \n  Срочно в номер!\n  Марсиане атакуют людей!\n
					  alert( news.textContent );
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.hidden</p>
			</div>
			<div class="second_column table_column">
				<p>hidden работает так же, как style="display:none"</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var lastDiv = document.body.children[2]; <br>
 					 lastDiv.hidden = true;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					Properties dependent on the type of element</p>
			</div>
			<div class="second_column table_column">
				<p>
					- value – значение для INPUT, SELECT или TEXTAREA
					- id – идентификатор
					- href – адрес ссылки
					- …многие другие…
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var input = document.body.children[0]; <br>
					  alert( input.type ); // "text" <br>
					  alert( input.id ); // "elem" <br>
					  alert( input.value ); // значение
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.getElementById("id")</p>
			</div>
			<div class="second_column table_column">
				<p>
					document.getElementById("идентификатор"). <br>
					Если элементу назначен специальный атрибут id, то можно получить его прямо по переменной с именем из значения id.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div id="content"&gt;Выделим этот элемент&lt;/div&gt; <br>
					&lt;script&gt; <br>
					  var elem = document.getElementById('content'); <br>
					&lt;/script&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.getElementsByTagName(tag)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Метод elem.getElementsByTagName(tag) ищет все элементы с заданным тегом tag внутри элемента elem и возвращает их в виде списка. <br>
					в отличие от getElementById, который существует только в контексте document, метод getElementsByTagName может искать внутри любого элемента.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var elements = tableElem.getElementsByTagName('input'); <br>
 
					  for (var i = 0; i < elements.length; i++) { <br>
					    var input = elements[i]; <br>
					    alert( input.value + ': ' + input.checked ); <br>
					  }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.getElementsByName(name)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов document.getElementsByName(name) позволяет получить все элементы с данным атрибутом name.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var elems = document.getElementsByName('age');
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.getElementsByClassName(className)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов elem.getElementsByClassName(className) возвращает коллекцию элементов с классом className. Находит элемент и в том случае, если у него несколько классов, а искомый – один из них. <br>
					Как и getElementsByTagName, этот метод может быть вызван и в контексте DOM-элемента, и в контексте документа.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var articles = document.getElementsByClassName('article'); <br>
  					alert( articles.length ); // 2, найдёт оба элемента
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.querySelectorAll(css)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов elem.querySelectorAll(css) возвращает все элементы внутри elem, удовлетворяющие CSS-селектору css. <br>
					Псевдо-класс тоже работает
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  var elements = document.querySelectorAll('ul > li:last-child'); <br>

					  for (var i = 0; i < elements.length; i++) { <br>
					    alert( elements[i].innerHTML ); // "тест", "пройден" <br>
					  }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.querySelector(css)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Вызов elem.querySelector(css) возвращает не все, а только первый элемент, соответствующий CSS-селектору css.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.matches(css)</p>
			</div>
			<div class="second_column table_column">
				<p>Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem селектору css. Он возвращает true либо false.</p>
			</div>
			<div class="third_column table_column">
				<p>
					for (var i = 0; i < elems.length; i++) { <br>
					    if (elems[i].matches('a[href$="zip"]')) { <br>
					      alert( "Ссылка на архив: " + elems[i].href ); <br>
					    }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.closest(css)</p>
			</div>
			<div class="second_column table_column">
				<p>
					Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  // ближайший элемент сверху подходящий под селектор li <br>
					  alert(numberSpan.closest('li').className) // subchapter <br>

					  // ближайший элемент сверху подходящий под селектор .chapter <br>
					  alert(numberSpan.closest('.chapter').tagName) // LI <br>

					  // ближайший элемент сверху, подходящий под селектор span <br>
					  // это сам numberSpan, так как поиск включает в себя сам элемент <br>
					  alert(numberSpan.closest('span') === numberSpan) // true
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.hasAttribute(name)</p>
			</div>
			<div class="second_column table_column">
				<p>проверяет наличие атрибута</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.getAttribute(name)</p>
			</div>
			<div class="second_column table_column">
				<p>получает значение атрибута</p>
			</div>
			<div class="third_column table_column">
				<p>
					    alert( elem.getAttribute('About') ); // (1) 'Elephant', атрибут получен
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.setAttribute(name, value)</p>
			</div>
			<div class="second_column table_column">
				<p>устанавливает атрибут</p>
			</div>
			<div class="third_column table_column">
				<p>
					elem.setAttribute('Test', 123); // (2) атрибут Test установлен
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.removeAttribute(name)</p>
			</div>
			<div class="second_column table_column">
				<p>удаляет атрибут</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.attributes</p>
			</div>
			<div class="second_column table_column">
				<p>
					Также все атрибуты элемента можно получить с помощью свойства elem.attributes, которое содержит псевдо-массив объектов типа Attr. <br> 
					В отличие от свойств, атрибуты: <br>
					- Всегда являются строками. <br>
					- Их имя нечувствительно к регистру (ведь это HTML) <br>
					- Видны в innerHTML (за исключением старых IE)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					    var attrs = elem.attributes; // (4) можно получить коллекцию атрибутов <br>
					    for (var i = 0; i < attrs.length; i++) { <br>
					      alert( attrs[i].name + " = " + attrs[i].value );
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.classList.contains("class") <br>

					.classList.add("class") <br>

					.classList.remove("class") <br>

					.classList.toggle("class")
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство classList – это объект для работы с классами. <br>
					- elem.classList.contains("class") – возвращает true/false, в зависимости от того, есть ли у элемента класс class. <br>
					- elem.classList.add/remove("class") – добавляет/удаляет класс class <br>
					- elem.classList.toggle("class") – если класса class нет, добавляет его, если есть – удаляет.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					var classList = document.body.classList; <br>

				    classList.remove('page'); // удалить класс <br>
				    classList.add('post'); // добавить класс <br>

				    for (var i = 0; i < classList.length; i++) { // перечислить классы <br>
				      alert( classList[i] ); // main, затем post <br>
				    } <br>

				    alert( classList.contains('post') ); // проверить наличие класса
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.dataset</p>
			</div>
			<div class="second_column table_column">
				<p>Для работы с атрибутами data-*</p>
			</div>
			<div class="third_column table_column">
				<p>
					 alert( elem.dataset.about ); // data-about <br>
  					alert( elem.dataset.userLocation ); // data-user-location
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.style</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойство element.style возвращает объект, который дает доступ к стилю элемента на чтение и запись. <br>

					Для свойств, названия которых состоят из нескольких слов, используется вотТакаяЗапись:<br>

					background-color  => elem.style.backgroundColor<br>

					z-index           => elem.style.zIndex<br>

					border-left-width => elem.style.borderLeftWidth<br>


					Чтобы сбросить поставленный стиль, присваивают в style пустую строку: elem.style.width="".<br>


					Стиль в style находится в формате браузера, а не в том, в котором его присвоили.<br>


					Свойство style содержит лишь тот стиль, который указан в атрибуте элемента, без учёта каскада CSS.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					element.style.width="100px" <br>

					document.body.style.margin = '20px'; <br>

					document.body.style.color = '#abc'; <br>
					    alert( document.body.style.color ); // rgb(170, 187, 204) <br>


					document.body.style.backgroundColor = prompt('background color?', 'green');
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.style.cssText</p>
			</div>
			<div class="second_column table_column">
				<p>
					войство style.cssText позволяет поставить стиль целиком в виде строки. <br>

					При установке style.cssText все предыдущие свойства style удаляются.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					div.style.cssText="color: red !important; \ <br>
					    background-color: yellow; \ <br>
					    width: 100px; \ <br>
					    text-align: center; \ <br>
					    blabla: 5; \ <br>
					  ";
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.getComputedStyle</p>
			</div>
			<div class="second_column table_column">
				<p>
					window.getComputedStyle <br>
					getComputedStyle(element[, pseudo]) <br>
					Для того, чтобы получить текущее используемое значение свойства.  <br>
					element - Элемент, значения для которого нужно получить <br>
					pseudo - Указывается, если нужен стиль псевдо-элемента, например "::before". Пустая строка или отсутствие аргумента означают сам элемент.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					    var computedStyle = getComputedStyle(document.body); <br>
					    alert( computedStyle.marginTop ); // выведет отступ в пикселях <br>
					    alert( computedStyle.color ); // выведет цвет
				</p>
			</div>
		</div>

		<!-- ---------------------------------------------------sizes------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="sizes_coordinates">
			<h1>Sizes/Coordinates</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.offsetParent</p>
			</div>
			<div class="second_column table_column">
				<p>В offsetParent находится ссылка на родительский элемент в смысле отображения на странице.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.offsetLeft/Top</p>
			</div>
			<div class="second_column table_column">
				<p>Свойства offsetLeft/Top задают смещение относительно offsetParent</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.offsetWidth/Height</p>
			</div>
			<div class="second_column table_column">
				<p>Эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки border.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.clientTop/Left</p>
			</div>
			<div class="second_column table_column">
				<p>
					Далее внутри элемента у нас рамки border. <br>
					Для них есть свойства-метрики clientTop и clientLeft.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.clientWidth/Height</p>
			</div>
			<div class="second_column table_column">
				<p>
					Эти свойства – размер элемента внутри рамок border. <br>
					Они включают в себя ширину содержимого width вместе с полями padding, но без прокрутки. <br>
					Если padding нет, то clientWidth/Height в точности равны размеру области содержимого, внутри рамок и полосы прокрутки.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.scrollWidth/Height</p>
			</div>
			<div class="second_column table_column">
				<p>
					Эти свойства – аналоги clientWidth/clientHeight, но с учетом прокрутки. <br>
					Свойства clientWidth/clientHeight относятся только к видимой области элемента, а scrollWidth/scrollHeight добавляют к ней прокрученную (которую не видно) по горизонтали/вертикали.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.scrollLeft/Top</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойства scrollLeft/scrollTop – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.clientWidth/Height</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойства clientWidth/Height для элемента document.documentElement – это как раз ширина/высота видимой области окна.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.scrollBy(x,y)</p>
			</div>
			<div class="second_column table_column">
				<p>прокручивает страницу относительно текущих координат.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.scrollTo(pageX,pageY)</p>
			</div>
			<div class="second_column table_column">
				<p>прокручивает страницу к указанным координатам относительно документа.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.scrollIntoView(top)</p>
			</div>
			<div class="second_column table_column">
				<p>
					вызывается на элементе и прокручивает страницу так, чтобы элемент оказался вверху, если параметр top равен true, и внизу, если top равен false. Причем, если параметр top не указан, то он считается равным true. <br>
					Чтобы запретить прокрутку страницы, достаточно поставить document.body.style.overflow = "hidden".
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					-
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.getBoundingClientRect()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Метод elem.getBoundingClientRect() возвращает координаты элемента, под которыми понимаются размеры «воображаемого прямоугольника», который охватывает весь элемент. <br>
					Координаты возвращаются в виде объекта со свойствами: <br>
					- top – Y-координата верхней границы элемента, <br>
					- left – X-координата левой границы, <br>
					- right – X-координата правой границы, <br>
					- bottom – Y-координата нижней границы. <br>
					Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.elementFromPoint(x, y)</p>
			</div>
			<div class="second_column table_column">
				<p>Возвращает элемент, который находится на координатах (x, y) относительно окна.</p>
			</div>
			<div class="third_column table_column">
				<p>
					var elem = document.elementFromPoint(centerX, centerY);
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.screenX/Y</p>
			</div>
			<div class="second_column table_column">
				<p>
					Координаты относительно экрана screenX/screenY отсчитываются от его левого-верхнего угла. Имеется в виду именно весь экран, а не окно браузера.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<!-- ---------------------------------------------------Events------------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="events">
			<h1>Events</h1>
		</div>

		<div class="zebra2 theory_row">
			<h2>Theory:</h2>
			<p>
				События мыши: <br>
				- click – происходит, когда кликнули на элемент левой кнопкой мыши <br>
				- contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши <br>
				- mouseover – возникает, когда на элемент наводится мышь <br>
				- mousedown и mouseup – когда кнопку мыши нажали или отжали <br>
				- mousemove – при движении мыши <br>
				События на элементах управления: <br>
				- submit – посетитель отправил форму &ltform&gt <br>
				- focus – посетитель фокусируется на элементе, например нажимает на &ltinput&gt <br>
				Клавиатурные события: <br>
				- keydown – когда посетитель нажимает клавишу <br>
				- keyup – когда посетитель отпускает клавишу <br>
				События документа: <br>
				- DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен. <br>
				События CSS: <br>
				- transitionend – когда CSS-анимация завершена.
				Также есть и много других событий.
			</p>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.addEventListener <br>
					.removeEventListener
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Методы addEventListener и removeEventListener являются современным способом назначить или удалить обработчик, и при этом позволяют использовать сколько угодно любых обработчиков. <br>
					element.addEventListener(event, handler[, phase]); <br>
					// передать те же аргументы, что были у addEventListener <br>
					element.removeEventListener(event, handler[, phase]); <br>

					event - Имя события, например click  <br>
					handler - Ссылка на функцию, которую надо поставить обработчиком.  <br>
					phase - Необязательный аргумент, «фаза», на которой обработчик должен сработать. Этот аргумент редко нужен, мы его рассмотрим позже.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					elem.addEventListener( "click" , function() {alert('Спасибо!')}); <br>
					// .... <br>
					elem.removeEventListener( "click", function() {alert('Спасибо!')});
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Event object</p>
			</div>
			<div class="second_column table_column">
				<p>
					Свойства объекта event: <br>
					event.type - Тип события, в данном случае click <br>
					event.currentTarget - Элемент, на котором сработал обработчик. Значение – в точности такое же, как и у this, но бывают ситуации, когда обработчик является методом объекта и его this при помощи bind привязан к этому объекту, тогда мы можем использовать event.currentTarget. <br>
					event.clientX / event.clientY - Координаты курсора в момент клика (относительно окна) <br>
					Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным»элементом и доступен как event.target. <br>
					Отличия от this (=event.currentTarget): <br>
					- event.target – это исходный элемент, на котором произошло событие, в процессе всплытия он неизменен. <br>
					- this – это текущий элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					  elem.onclick = function(event) { <br>
					    // вывести тип события, элемент и координаты клика <br>
					    alert(event.type + " на " + event.currentTarget); <br>
					    alert(event.clientX + ":" + event.clientY); <br>
					  }
				</p>
			</div>
		</div>


		<footer>
			<h4>All Rights Reserved (c)</h4>
		</footer>
	</section>
</main>

<script src="scripts/search_javascript.js"></script>
<script src="scripts/script.js"></script>

</body>
</html>