<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="description" content="My Programming Directory">
	<meta name="keywords" content="HTML , CSS , JS , Bootstrap">
	<meta name="author" content="George Levchenko">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>My Code Directory</title>
	<link href="https://fonts.googleapis.com/css?family=Poppins" rel="stylesheet">
	<link href="https://fonts.googleapis.com/css?family=Dokdo" rel="stylesheet">
	<link rel="stylesheet" href="img/css/fontello.css">
	<link rel="stylesheet" href="styles/style_index.css">
	<link rel="stylesheet" href="styles/style_angular.css">
</head>
<body>

<header>
	<h1 class="logo_big">Pro<span class="bold_black">-G-</span>running</h1>
	<h1 class="logo_small">Pro<span class="bold_black">-G-</span></h1>
</header>

<nav class="not_responsive">
	<ul class="left_side_nav  not_responsive">
		<li id="menu"><a href="#">&#9776</a></li>
		<li class="home_page not_responsive"><a href="index.html"><i class="icon-home"></i></a></li>
		<li class="html_page not_responsive"><a href="html.html">HTML</a></li>
		<li class="css_page not_responsive"><a href="css.html">CSS</a></li>
		<li class="bootstrap_page not_responsive"><a href="bootstrap.html">BootsTrap</a></li>
		<li class="javascript_page not_responsive"><a href="javascript.html">JavaScript</a></li>
		<li class="typescript_page not_responsive"><a href="typescript.html">TypeScript</a></li>
		<li class="angular_page not_responsive" style="background: #000"><a href="#">Angular</a></li>
	</ul>

	<ul class="right_side_nav  not_responsive">
		<li class="practice_page not_responsive"><a href="practice.html">Practice</a></li>
		<li class="search_field" id="search_field_li">
			<input type="text" placeholder=" Enter Angular theme" id="search_field" onkeyup="searchAngular()">
			<i class="icon-search"></i>
		</li>
	</ul>
</nav>

<main>
	<section class="left_side_anchors">
		<ul>
			<li><a href="#bootstrapping">Bootstrapping</a></li>
			<li><a href="#ng_modules">NgModules</a></li>
			<li><a href="#components">Components</a></li>
			<li><a href="#styles_property">Styles</a></li>
			<li><a href="#lifecycle_hooks">Lifecycle Hooks</a></li>
			<li><a href="#syntax">Template Syntax</a></li>
			<li><a href="#template_forms">Template-Driven Forms</a></li>
			<li><a href="#reactive_forms">Reactive Forms</a></li>
			<li><a href="#components_relationship">Components Relationship</a></li>
			<li><a href="#directives">Directives</a></li>
			<li><a href="#pipes">Pipes</a></li>
			<li><a href="#services">Services</a></li>
			<li><a href="#observables">Observables</a></li>
            <li><a href="#rxjs">RxJS</a></li>
			<li><a href="#http">HTTP</a></li>
			<li><a href="#routing">Routing</a></li>
			<li><a href="#guards">Guards</a></li>
			<li><a href="#"></a></li>
		</ul>
	</section>
	<section class="main_text">

		<div class="table_row first_row zebra1">
			<div>
				<h2>Theme</h2>
			</div>
			<div>
				<h2>Description</h2>
			</div>
			<div>
				<h2>Example</h2>
			</div>
		</div>

		<!-- ---------------------------------------------------------Bootstrapping------------------------------------------------------- -->

		<div class="anchor_row zebra3" id="bootstrapping">
			<h1>Bootstrapping</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>angular.json</p>
			</div>
			<div class="second_column table_column">
				<p>
					CLI configuration defaults for all projects in the workspace,
					 including configuration options for build, serve, and test tools that the CLI uses
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					{ <br>
					"$schema": "./node_modules/@angular/cli/lib/config/schema.json", <br>
					"version": 1, <br>
					"newProjectRoot": "projects", <br>
					"projects": { <br>
					"practiceCLI": { <br>
					"root": "", <br>
					"sourceRoot": "src", <br>
					"projectType": "application", <br>
					"prefix": "app", <br>
					"schematics": {}, <br>
					"architect": { <br>
					"build": { <br>
					"builder": "@angular-devkit/build-angular:browser", <br>
					"options": { <br>
					"outputPath": "dist/practiceCLI", <br>
					"index": "src/index.html", <br>
					"main": "src/main.ts", <br>
					"polyfills": "src/polyfills.ts", <br>
					"tsConfig": "src/tsconfig.app.json", <br>
					"assets": [ <br>
					"src/favicon.ico", <br>
					"src/assets" <br>
					], <br>
					"styles": [ <br>
					"src/styles.css" <br>
					], <br>
					"scripts": [] <br>
					}, <br>
					"configurations": { <br>
					"production": { <br>
					"fileReplacements": [ <br>
					{ <br>
					"replace": "src/environments/environment.ts", <br>
					"with": "src/environments/environment.prod.ts" <br>
					} <br>
					], <br>
					"optimization": true, <br>
					"outputHashing": "all", <br>
					"sourceMap": false, <br>
					"extractCss": true, <br>
					"namedChunks": false, <br>
					"aot": true, <br>
					"extractLicenses": true, <br>
					"vendorChunk": false, <br>
					"buildOptimizer": true, <br>
					"budgets": [ <br>
					{ <br>
					"type": "initial", <br>
					"maximumWarning": "2mb", <br>
					"maximumError": "5mb" <br>
					} <br>
					] <br>
					} } }, <br>
					"serve": { <br>
					"builder": "@angular-devkit/build-angular:dev-server", <br>
					"options": { <br>
					"browserTarget": "practiceCLI:build" <br>
					}, <br>
					"configurations": { <br>
					"production": { <br>
					"browserTarget": "practiceCLI:build:production" <br>
					} } }, <br>
					"extract-i18n": { <br>
					"builder": "@angular-devkit/build-angular:extract-i18n", <br>
					"options": { <br>
					"browserTarget": "practiceCLI:build" <br>
					} }, <br>
					"test": { <br>
					"builder": "@angular-devkit/build-angular:karma", <br>
					"options": { <br>
					"main": "src/test.ts", <br>
					"polyfills": "src/polyfills.ts", <br>
					"tsConfig": "src/tsconfig.spec.json", <br>
					"karmaConfig": "src/karma.conf.js", <br>
					"styles": [ <br>
					"src/styles.css" <br>
					], <br>
					"scripts": [], <br>
					"assets": [ <br>
					"src/favicon.ico", <br>
					"src/assets" <br>
					] <br>
					} }, <br>
					"lint": { <br>
					"builder": "@angular-devkit/build-angular:tslint", <br>
					"options": { <br>
					"tsConfig": [ <br>
					"src/tsconfig.app.json", <br>
					"src/tsconfig.spec.json" <br>
					], <br>
					"exclude": [ <br>
					"**/node_modules/**" <br>
					] <br>
					} } } }, <br>
					"practiceCLI-e2e": { <br>
					"root": "e2e/", <br>
					"projectType": "application", <br>
					"prefix": "", <br>
					"architect": { <br>
					"e2e": { <br>
					"builder": "@angular-devkit/build-angular:protractor", <br>
					"options": { <br>
					"protractorConfig": "e2e/protractor.conf.js", <br>
					"devServerTarget": "practiceCLI:serve" <br>
					}, <br>
					"configurations": { <br>
					"production": { <br>
					"devServerTarget": "practiceCLI:serve:production" <br>
					} } }, <br>
					"lint": { <br>
					"builder": "@angular-devkit/build-angular:tslint", <br>
					"options": { <br>
					"tsConfig": "e2e/tsconfig.e2e.json", <br>
					"exclude": [ <br>
					"**/node_modules/**" <br>
					] <br>
					} } } } }, <br>
					"defaultProject": "practiceCLI" <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>package.json</p>
			</div>
			<div class="second_column table_column">
				<p>
					Configures npm package dependencies that are available to all projects in the workspace. 
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					{ <br>
					"name": "practice-cli",<br>
					"version": "0.0.0",<br>
					"scripts": {<br>
					"ng": "ng",<br>
					"start": "ng serve",<br>
					"build": "ng build",<br>
					"test": "ng test",<br>
					"lint": "ng lint",<br>
					"e2e": "ng e2e"<br>
					},<br>
					"private": true,<br>
					"dependencies": {<br>
					"@angular/animations": "~7.1.0",<br>
					"@angular/common": "~7.1.0",<br>
					"@angular/compiler": "~7.1.0",<br>
					"@angular/core": "~7.1.0",<br>
					"@angular/forms": "~7.1.0",<br>
					"@angular/platform-browser": "~7.1.0",<br>
					"@angular/platform-browser-dynamic": "~7.1.0",<br>
					"@angular/router": "~7.1.0",<br>
					"core-js": "^2.5.4",<br>
					"rxjs": "~6.3.3",<br>
					"tslib": "^1.9.0",<br>
					"zone.js": "~0.8.26"<br>
					},<br>
					"devDependencies": {<br>
					"@angular-devkit/build-angular": "~0.11.0",<br>
					"@angular/cli": "~7.1.3",<br>
					"@angular/compiler-cli": "~7.1.0",<br>
					"@angular/language-service": "~7.1.0",<br>
					"@types/node": "~8.9.4",<br>
					"@types/jasmine": "~2.8.8",<br>
					"@types/jasminewd2": "~2.0.3",<br>
					"codelyzer": "~4.5.0",<br>
					"jasmine-core": "~2.99.1",<br>
					"jasmine-spec-reporter": "~4.2.1",<br>
					"karma": "~3.1.1",<br>
					"karma-chrome-launcher": "~2.2.0",<br>
					"karma-coverage-istanbul-reporter": "~2.0.1",<br>
					"karma-jasmine": "~1.1.2",<br>
					"karma-jasmine-html-reporter": "^0.2.2",<br>
					"protractor": "~5.4.0",<br>
					"ts-node": "~7.0.0",<br>
					"tslint": "~5.11.0",<br>
					"typescript": "~3.1.6"<br>
					}<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>tsconfig.json</p>
			</div>
			<div class="second_column table_column">
				<p>Default TypeScript configuration for apps in the workspace, including TypeScript and Angular template compiler options.</p>
			</div>
			<div class="third_column table_column">
				<p>
					{ <br>
					"compileOnSave": false,<br>
					"compilerOptions": {<br>
					"baseUrl": "./",<br>
					"outDir": "./dist/out-tsc",<br>
					"sourceMap": true,<br>
					"declaration": false,<br>
					"module": "es2015",<br>
					"moduleResolution": "node",<br>
					"emitDecoratorMetadata": true,<br>
					"experimentalDecorators": true,<br>
					"importHelpers": true,<br>
					"target": "es5",<br>
					"typeRoots": [<br>
					"node_modules/@types"<br>
					],<br>
					"lib": [<br>
					"es2018",<br>
					"dom"<br>
					] } }
				</p>
			</div>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>tslint.json</p>
			</div>
			<div class="second_column table_column">
				<p>Default TSLint configuration for apps in the workspace. <br>
					TSLint is an extensible static analysis tool that checks TypeScript code for readability,
					 maintainability, and functionality errors.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					{ <br>
					"rulesDirectory": [<br>
					"codelyzer"<br>
					],<br>
					"rules": {<br>
					"arrow-return-shorthand": true,<br>
					"callable-types": true,<br>
					"class-name": true,<br>
					"comment-format": [<br>
					true,<br>
					"check-space"<br>
					],<br>
					"curly": true,<br>
					"deprecation": {<br>
					"severity": "warn"<br>
					},<br>
					"eofline": true,<br>
					"forin": true,<br>
					"import-blacklist": [<br>
					true,<br>
					"rxjs/Rx"<br>
					],<br>
					"import-spacing": true,<br>
					"indent": [<br>
					true,<br>
					"spaces"<br>
					],<br>
					"interface-over-type-literal": true,<br>
					"label-position": true,<br>
					"max-line-length": [<br>
					true,<br>
					140<br>
					],<br>
					"member-access": false,<br>
					"member-ordering": [<br>
					true,<br>
					{<br>
					"order": [<br>
					"static-field",<br>
					"instance-field",<br>
					"static-method",<br>
					"instance-method"<br>
					]<br>
					}<br>
					],<br>
					"no-arg": true,<br>
					"no-bitwise": true,<br>
					"no-console": [<br>
					true,<br>
					"debug",<br>
					"info",<br>
					"time",<br>
					"timeEnd",<br>
					"trace"<br>
					],<br>
					"no-construct": true,<br>
					"no-debugger": true,<br>
					"no-duplicate-super": true,<br>
					"no-empty": false,<br>
					"no-empty-interface": true,<br>
					"no-eval": true,<br>
					"no-inferrable-types": [<br>
					true,<br>
					"ignore-params"<br>
					],<br>
					"no-misused-new": true,<br>
					"no-non-null-assertion": true,<br>
					"no-redundant-jsdoc": true,<br>
					"no-shadowed-variable": true,<br>
					"no-string-literal": false,<br>
					"no-string-throw": true,<br>
					"no-switch-case-fall-through": true,<br>
					"no-trailing-whitespace": true,<br>
					"no-unnecessary-initializer": true,<br>
					"no-unused-expression": true,<br>
					"no-use-before-declare": true,<br>
					"no-var-keyword": true,<br>
					"object-literal-sort-keys": false,<br>
					"one-line": [<br>
					true,<br>
					"check-open-brace",<br>
					"check-catch",<br>
					"check-else",<br>
					"check-whitespace"<br>
					],<br>
					"prefer-const": true,<br>
					"quotemark": [<br>
					true,<br>
					"single"<br>
					],<br>
					"radix": true,<br>
					"semicolon": [<br>
					true,<br>
					"always"<br>
					],<br>
					"triple-equals": [<br>
					true,<br>
					"allow-null-check"<br>
					],<br>
					"typedef-whitespace": [<br>
					true,<br>
					{<br>
					"call-signature": "nospace",<br>
					"index-signature": "nospace",<br>
					"parameter": "nospace",<br>
					"property-declaration": "nospace",<br>
					"variable-declaration": "nospace"<br>
					}<br>
					],<br>
					"unified-signatures": true,<br>
					"variable-name": false,<br>
					"whitespace": [<br>
					true,<br>
					"check-branch",<br>
					"check-decl",<br>
					"check-operator",<br>
					"check-separator",<br>
					"check-type"<br>
					],<br>
					"no-output-on-prefix": true,<br>
					"use-input-property-decorator": true,<br>
					"use-output-property-decorator": true,<br>
					"use-host-property-decorator": true,<br>
					"no-input-rename": true,<br>
					"no-output-rename": true,<br>
					"use-life-cycle-interface": true,<br>
					"use-pipe-transform-interface": true,<br>
					"component-class-suffix": true,<br>
					"directive-class-suffix": true <br>
					} }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>main.ts</p>
			</div>
			<div class="second_column table_column">
				<p>
					Application starts from this file. <br>
					Bootstraps the app, using the root component from the specified NgModule(root).
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; <br>

					platformBrowserDynamic().bootstrapModule(AppModule);

				</p>
			</div>
		</div>

		<!-- -------------------------------------------------NgModules------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="ng_modules">
			<h1>NgModules</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@NgModule</p>
			</div>
			<div class="second_column table_column">
				<p>
					Defines a module that contains components, directives, pipes, and providers. <br>
					An Angular app needs at least one module that serves as the root module.
					As you add features to your app, you should add them in modules. <br>

					NgModules are classes decorated with @NgModule. <br>

					import { NgModule } from '@angular/core';
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// imports <br>
					import { BrowserModule } from '@angular/platform-browser'; <br>
					import { NgModule } from '@angular/core'; <br>
					import { FormsModule } from '@angular/forms'; <br>
					import { HttpClientModule } from '@angular/common/http'; <br>
					import { AppComponent } from './app.component'; <br>
					import { ItemDirective } from './item.directive'; <br> <br>

					// @NgModule decorator with its metadata <br>
					@NgModule({ <br>
					declarations: [ AppComponent, ItemDirective ], <br>
					imports: [ BrowserModule, FormsModule, HttpClientModule ], <br>
					providers: [], bootstrap: [AppComponent] <br>
					})  <br>
					export class AppModule { }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Properties</p>
			</div>
			<div class="second_column table_column">
				<p>
					declarations: [] - List of components, directives, and pipes that belong to this module. <br><br>
					imports: [] - List of modules to import into this module.
					Everything from the imported modules is available to declarations of this module. <br><br>
					exports: [] - List of components, directives, and pipes visible
					to modules that import this module.<br><br>
					providers: [] - List of dependency injection providers visible both
					to the contents of this module and to importers of this module. <br><br>
					entryComponents: [] - List of components not referenced in any reachable template,
					for example dynamically created from code. <br><br>
					bootstrap: [] - List of components to bootstrap when this module is bootstrapped.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					declarations: [MyRedComponent, MyBlueComponent, MyDatePipe], <br><br>
					imports: [BrowserModule, SomeOtherModule], <br><br>
					exports: [MyRedComponent, MyDatePipe], <br><br>
					providers: [MyService, { provide: ... }], <br><br>
					entryComponents: [SomeComponent, OtherComponent], <br><br>
					bootstrap: [MyAppComponent]
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					Frequently Used NgModules
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					BrowserModule - When you want to run your app in a browser (extends CommonModule).
					It should be imported once in a root module. <br><br>
					CommonModule - When you want to use NgIf, NgFor.
					(not necessary if BrowserModule imported) <br><br>
					FormsModule - When you want to build template driven forms (includes NgModel). <br><br>
					ReactiveFormsModule - When you want to build reactive forms. <br><br>
					RouterModule - When you want to use RouterLink, .forRoot(), and .forChild(). <br><br>
					HttpClientModule - When you want to talk to a server.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { BrowserModule } from '@angular/platform-browser'; <br>
					import { NgModule } from '@angular/core'; <br>
					import { FormsModule } from '@angular/forms'; <br>
					import { HttpClientModule } from '@angular/common/http'; <br>
					<br>
					@NgModule({ <br>
					imports: [ BrowserModule, FormsModule, HttpClientModule ] <br>
					})
				</p>
			</div>
		</div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>
                    Feature Modules
                </p>
            </div>
            <div class="second_column table_column">
                <p>
					A feature module is an organizational best practice, as opposed to a concept of the core Angular API. A feature module delivers a cohesive set of functionality focused on a specific application need such as a user workflow, routing, or forms. While you can do everything within the root module, feature modules help you partition the app into focused areas. A feature module collaborates with the root module and with other modules through the services it provides and the components, directives, and pipes that it shares.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    import { NgModule } from '@angular/core'; <br>
                    import { RouterModule, Routes } from '@angular/router'; <br><br>

                    import { HeroListComponent } from './hero-list/hero-list.component';<br>
                    import { HeroDetailComponent } from './hero-detail/hero-detail.component';<br><br>

                    const heroesRoutes: Routes = [<br>
                    { path: 'heroes', component: HeroListComponent },<br>
                    { path: 'hero/:id', component: HeroDetailComponent }<br>
                    ];<br><br>

                    @NgModule({<br>
                    imports: [<br>
                    RouterModule.forChild(heroesRoutes)<br>
                    ],<br>
                    exports: [<br>
                    RouterModule<br>
                    ]<br>
                    })<br><br>
                    export class HeroesRoutingModule { }
                </p>
            </div>
        </div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					Types of Feature Modules
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Domain feature modules – components module. <br><br>

					Routed feature modules – linked module, doesn’t include anywhere, access only by link. <br><br>

					Routing modules – routing logic. <br><br>

					Service feature modules – global services. <br><br>

					Widget feature modules – export-oriented module.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					<img src="img/Modules.png" alt="Types of Modules" style="width: 95%; height: 95%;"> <br>

					https://angular.io/guide/module-types
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					Lazy Loading Feature Modules
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					There are three main steps to setting up a lazy loaded feature module: <br>
					1.	Create the feature module.<br>
					2.	Create the feature module’s routing module.<br>
					3.	Configure the routes.<br><br>

					https://angular.io/guide/lazy-loading-ngmodules#lazy-loading-feature-modules
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					const routes: Routes = [ <br>
					{ path: 'customers', loadChildren: './customers/customers.module#CustomersModule' }, <br>
					{ path: 'orders', loadChildren: './orders/orders.module#OrdersModule' }, <br>
					{ path: '', redirectTo: '', pathMatch: 'full' } <br>
					];
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					.forRoot() <br>
					.forChild()
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					https://angular.io/guide/singleton-services#forroot <br>

					https://angular.io/guide/lazy-loading-ngmodules#forroot-and-forchild
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { CoreModule } from './core/core.module'; <br>
					/* . . . */ <br><br>

					@NgModule({<br>
					imports: [ BrowserModule, ContactModule, CoreModule.forRoot(<br>
					{userName: 'Miss Marple'}), AppRoutingModule ],<br>
					/* . . . */ })<br><br>
					export class AppModule { }<br>

					static forRoot(config: UserServiceConfig): ModuleWithProviders {<br>
					return {<br>
					ngModule: CoreModule,<br>
					providers: [ {provide: UserServiceConfig, useValue: config } ]<br>
					}; }
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Components------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="components">
			<h1>Components</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Component</p>
			</div>
			<div class="second_column table_column">
				<p>
					Declares that a class is a component and provides metadata about the component.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Component } from '@angular/core'; <br><br>

					@Component({...})<br>
					class MyComponent() {}

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Properties</p>
			</div>
			<div class="second_column table_column">
				<p>
					selector: '' - selector that identifies this component in a template. <br><br>
					template / templateUrl: '' - Inline template or external template URL of the component's view. <br><br>
					styles / styleUrls : [''] - List of inline CSS styles or external stylesheet URLs
					for styling the component’s view. <br><br>
					providers: [] - List of dependency injection providers for this directive and its children. <br><br>
					viewProviders: [] - List of dependency injection providers scoped to this component's view. <br><br>

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					selector: 'app-hero', <br>
					template: 'Hello {{name}}', <br>
					templateUrl: 'my-component.html', <br>
					styles: ['.primary {color: red}'], <br>
					styleUrls: ['my-component.css'], <br>
					providers: [MyService, { provide: ... }], <br>
					viewProviders: [MyService, { provide: ... }] <br>

				</p>
			</div>
		</div>

		<div class="theory_row zebra1">
			<h2>Tips:</h2>
			<p>
				Model-View-Controller (MVC) - In Angular, the component plays the part of the controller,
				and the template represents the view. Helps to get and set DOM (Document Object Model) values dynamically.
			</p>
		</div>

		<!-- -------------------------------------------------Styles------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="styles_property">
			<h1>Styles</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Scope</p>
			</div>
			<div class="second_column table_column">
				<p>The styles specified in @Component metadata apply only within the template of that component.</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Setup</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Styles in component metadata: add a styles array property to the @Component decorator. <br><br>
					- Style files in component metadata: load styles from external CSS files
					by adding a styleUrls property to a component's @Component decorator.<br><br>
					- Template inline styles:
					embed CSS styles directly into the HTML template by putting them inside &lt;style&gt;tags.<br><br>
					- Template link tags: write &lt;link&gt; tags into the component's HTML template.<br><br>
					- CSS @imports:  import CSS files into the CSS files using the standard CSS @import rule.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					styles: ['h1 { font-weight: normal; }'] <br> <br>

					styleUrls: ['./hero-app.component.css'] <br>
					template: `<br>
					&lt;style&gt;<br>
					button {<br>
					background-color: white;<br>
					border: 1px solid #777;<br>
					}<br>
					&lt;/style&gt;<br>
					&lt;h3&gt;Controls&lt;/h3&gt;<br><br>

					template: ` <br>
					&lt;link rel="stylesheet" href="../assets/hero-team.component.css"&gt;<br>
					&lt;h3&gt;Team&lt;/h3&gt;<br><br>

					@import './hero-details-box.css';
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>:host</p>
			</div>
			<div class="second_column table_column">
				<p>
					Use the :host pseudo-class selector to target styles in the element
					that hosts the component (as opposed to targeting elements inside the component's template). <br>
					-The host element is in a parent component's template. <br>
					-Use the function form to apply host styles conditionally
					by including another selector inside parentheses after :host.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					:host { display: block; border: 1px solid black; } <br>

					:host(.active) { border-width: 3px; } <br>
					Targets the host element again, but only when it also has the active CSS class.
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					:host-context()
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Sometimes it's useful to apply styles based on some condition outside of a component's view.
					The :host-context() selector looks for a CSS class in any ancestor of the component host element,
					up to the document root. The :host-context() selector is useful when combined with another selector.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					:host-context(.theme-light) h2 { background-color: #eef; } <br>
					applies a background-color style to all &lt;h2&gt; elements inside the component,
					only if some ancestor element has the CSS class theme-light.
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Lifecycle Hooks------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="lifecycle_hooks">
			<h1>Lifecycle Hooks</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					constructor(myService: MyService, ...) <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called before any other lifecycle hook.
					Use it to inject dependencies, but avoid any serious work here.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					ngOnChanges(changeRecord) <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after every change to input properties and before processing content or child views. <br>
					The ngOnChanges() method takes an object that maps each changed property name
					to a SimpleChange object holding the current and previous property values.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					ngOnChanges(changes: SimpleChanges) { <br>
					for (let propName in changes) {<br>
					let chng = changes[propName];<br>
					let cur = JSON.stringify(chng.currentValue);<br>
					let prev = JSON.stringify(chng.previousValue);<br>
					this.changeLog.push(`${propName}: currentValue = ${cur}, previousValue = ${prev}`);<br>
					} } <br> <br>

					ngOnChanges(changes: SimpleChanges){ <br>
						if(changes.justValue && !changes.justValue.currentValue){ <br>
							console.log(changes.justValue.currentValue);	<br>
						}<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					ngOnInit() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after the constructor, initializing input properties,
					and the first call to ngOnChanges. <br>
					Commonly used to:<br>
					- To perform complex initializations shortly after construction. <br>
					- To set up the component after Angular sets the input properties.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					ngDoCheck() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called every time that the input properties of a component or a directive are checked. <br>
					Use it to extend change detection by performing a custom check. <br>
					Use the DoCheck hook to detect and act upon changes that Angular doesn't catch on its own.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					ngAfterContentInit() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after ngOnInit when the component's or directive's content has been initialized. <br>
					The following AfterContent hooks take action based on changing values in a content child,
					which can only be reached by querying for them via the property decorated with@ContentChild.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					ngAfterContentChecked() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after every check of the component's or directive's content. <br>
					The following AfterContent hooks take action based on changing values in a content child, <br>
					which can only be reached by querying for them via the property decorated with@ContentChild.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>ngAfterViewInit() <br>
					{ ... }</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after ngAfterContentInit when the component's views
					and child views / the view that a directive is in has been initialized. <br>
					The following hooks take action based on changing values within the child view,
					which can only be reached by querying for the child view via the property decorated with @ViewChild.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					ngAfterViewChecked() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called after every check of the component's views
					and child views / the view that a directive is in. <br>
					The following hooks take action based on changing values within the child view,
					which can only be reached by querying for the child view via the property decorated with @ViewChild.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					ngOnDestroy() <br>
					{ ... }
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Called once, before the instance is destroyed. <br>
					Commonly used to: <br>
					- Put cleanup logic. <br>
					- This is the time to notify another part of the application that the component is going away. <br>
					- This is the place to free resources that won't be garbage collected automatically.
					Unsubscribe from Observables and DOM events. Stop interval timers.
					Unregister all callbacks that this directive registered with global or application services.
				</p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<!-- -------------------------------------------------Syntax------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="syntax">
			<h1>Template Syntax</h1>
		</div>

		<div class="theory_row zebra1">
			<h2>Theory:</h2>
			<p>
				<b>HTML attribute vs. DOM property:</b> <br>
				The HTML attribute and the DOM property are not the same thing, even when they have the same name. <br>
				Attributes initialize DOM properties and then they are done.
				Property values can change; attribute values can't. <br>
				A few HTML attributes have 1:1 mapping to properties. id is one example. <br>
				Some HTML attributes don't have corresponding properties. colspan is one example. <br>
				Some DOM properties don't have corresponding attributes. textContent is one example. <br>
				In the world of Angular, the only role of attributes is to initialize element and directive state.
				When you write a data binding, you're dealing exclusively with properties and events of the target object.
				HTML attributes effectively disappear.
			</p>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>{{ … }}</p>
			</div>
			<div class="second_column table_column">
				<p>
					Interpolation -  is a special syntax that Angular converts into a property binding: <br><br>

					- Binding to the property, not attribute <br>
					- The text between the braces is a template expression that Angular first evaluates and then converts to a string.<br>
					- The expression can invoke methods of the host component such as getVal()<br>
					- Finally, it assigns this composite interpolated result to an element or directive property.<br><br>

					Template Expression context:<br>
					- refer to properties of the Component, where it’s called<br>
					- refer to properties of the template's context such as a template input variable (let hero)
					or a template reference variable (#heroInput).<br>
					- Template expressions cannot refer to anything in the global namespace (except undefined).
					They can't refer to window or document. They can't call console.log or Math.max.<br><br>

					Template Expression restriction:<br>
					- assignments (=, +=, -=, ...)<br>
					- new<br>
					- chaining expressions with ; or ,<br>
					- increment and decrement operators (++ and --)<br>
					- no support for the bitwise operators | and &<br><br>

					Guideline:<br>
					- No visible side effects (A template expression should not change any application state other
					than the value of the target property.)<br>
					- Quick execution (Angular executes template expressions after every change detection cycle.)<br>
					- Simplicity<br>
					- Idempotence (always returns exactly the same thing until one of its dependent values changes.)<br>
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p&gt;My current hero is {{currentHero.name}}&lt;/p&gt; <br><br>

					&lt;img src="{{heroImageUrl}}" style="height:30px"&gt;<br><br>

					&lt;p&gt;The sum of 1 + 1 is {{1 + 1}}&lt;/p&gt;<br><br>

					&lt;p&gt;The sum of 1 + 1 is not {{1 + 1 + getVal()}}&lt;/p&gt;<br><br>

					&lt;div *ngFor="let hero of heroes"&gt;{{hero.name}}&lt;/div&gt;<br><br>

					&lt;input #heroInput&gt; {{heroInput.value}}

				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>( | )</p>
			</div>
			<div class="second_column table_column">
				<p>
					The pipe operator. <br>
					- Pipes are simple functions that accept an input value and return a transformed value.<br>
					- The pipe operator passes the result of an expression on the left to a pipe function on the right.<br>
					- You can chain expressions through multiple pipes<br>
					- And you can also apply parameters to a pipe
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div&gt;Title through uppercase pipe: {{title | uppercase}}&lt;/div&gt;<br><br>

					&lt;div&gt; Title through a pipe chain: {{title | uppercase | lowercase}} &lt;/div&gt;<br><br>

					&lt;div&gt;Birthdate: {{currentHero?.birthdate | date:'longDate'}}&lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>(?.)</p>
			</div>
			<div class="second_column table_column">
				<p>
					The safe navigation operator. <br>
					- It is a fluent and convenient way to guard against null and undefined values in property paths. <br>
					- The expression bails out when it hits the first null value.
					The display is blank, but the app keeps rolling without errors. <br>
					- It works perfectly with long property paths such as a?.b?.c?.d.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					The null hero's name is {{nullHero?.name}}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>(!)</p>
			</div>
			<div class="second_column table_column">
				<p>
					The non-null assertion operator. <br>
					- The type checker also throws an error if it can't determine whether a variable will be null
					or undefined at runtime. You may know that can't happen but the type checker doesn't know.
					You tell the type checker that it can't happen by applying this post-fix operator.<br>
					- it does not guard against null or undefined.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div *ngIf="hero"&gt; The hero's name is {{hero!.name}} &lt;/div&gt; <br>
					it prevents TypeScript from reporting that hero.name might be null or undefined.

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					$any( )
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					The $any type cast function. <br>
					- A binding expression will be reported as a type error and it is not possible
					or difficult to fully specify the type. You will use it to silence the error.<br>
					- The $any cast function can be used in conjunction with this to allow access
					to undeclared members of the component.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div&gt; The hero's marker is {{$any(hero).marker}} &lt;/div&gt; <br>
					In this example, when the Angular compiler turns your template into TypeScript code,
					it prevents TypeScript from reporting that marker is not a member of the Hero interface. <br><br>

					&lt;div&gt; Undeclared members is {{$any(this).member}} &lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>#var</p>
			</div>
			<div class="second_column table_column">
				<p>
					Template reference variables - is often a reference to a DOM element within a template.
					It can also be a reference to an Angular component or directive or a web component. <br>
					- You can refer to a template reference variable anywhere in the template.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;input #phone placeholder="phone number"&gt; <br>
					&lt;button (click)="callPhone(phone.value)"&gt;Call&lt;/button&gt; <br><br>

					&lt;form (ngSubmit)="onSubmit(heroForm)" #heroForm="ngForm"&gt;<br>
					…<br>
					&lt;button type="submit" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt; &lt;/form&gt;<br>
					&lt;div [hidden]="!heroForm.form.valid"&gt; {{submitMessage}} &lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>[target property]="value"</p>
			</div>
			<div class="second_column table_column">
				<p>
					Property binding: <br>
					Target:<br>
					Element property <br>
					Component property<br>
					Directive property<br><br>

					- Angular looks first to see if the name is a property of a known directive (ngClass)<br>
					- The target name is always the name of a property,
					even when it appears to be the name of something else. (src) <br>
					- The template expression should evaluate to the type of value expected
					by the target property. (number, string, boolean, object)<br>
					- Property without brackets - fixed string, not a template expression.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;input [value]="firstName"&gt; <br>
					Binds property value to the result of expression firstName.<br><br>

					&lt;img [src]="heroImageUrl"&gt;<br>
					binding the src property of an image element to a component's heroImageUrl property<br><br>

					&lt;button [disabled]="isUnchanged"&gt;Cancel is disabled&lt;/button&gt;<br>
					disabling a button when the component says that it isUnchanged:<br><br>

					&lt;app-hero-detail [hero]="currentHero"&gt;&lt;/app-hero-detail&gt;<br>
					setting the model property of a custom component (a great way for parent and child components to communicate):<br><br>

					&lt;div [ngClass]="{'special': isSpecial}"&gt;&lt;/div&gt;<br>
					setting a property of a directive<br><br>

					&lt;app-hero-detail prefix="You are my"&gt;&lt;/app-hero-detail&gt;<br>
					Fixed string
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>[attr.role]="value"</p>
			</div>
			<div class="second_column table_column">
				<p>
					Attribute binding: <br>
					You must use attribute binding when there is no element property to bind.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [attr.role]="myAriaRole"&gt; <br>
					Binds attribute role to the result of expression myAriaRole. <br><br>

					&lt;tr&gt;&lt;td [attr.colspan]="1 + 1"&gt;One-Two&lt;/td&gt;&lt;/tr&gt;<br><br>

					&lt;button [attr.aria-label]="actionName"&gt;{{actionName}} with Aria&lt;/button&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>[class.class-name]="true/false"</p>
			</div>
			<div class="second_column table_column">
				<p>
					Class binding: <br>
					You can add and remove CSS class names from an element's class attribute.<br>
					Best to use, when you need to work with single class.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [class.extra-sparkle]="isDelightful"&gt; <br>
					Binds the presence of the CSS class extra-sparkle on the element
					to the truthiness of the expression isDelightful. <br><br>

					&lt;div [class.special]="isSpecial"&gt;The class binding is special&lt;/div&gt; True/add class <br>
					&lt;div class="special" [class.special]="!isSpecial"&gt;This one is not so special&lt;/div&gt; False/ remove class
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>[style.style-property.units]="value"</p>
			</div>
			<div class="second_column table_column">
				<p>
					Style binding: <br>
					You can set inline styles with a style binding. <br>
					Units are optional. <br>
					Best to use, when you need to work with single style.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [style.width.px]="mySize"&gt; <br>
					Binds style property width to the result of expression mySize in pixels. <br> <br>

					&lt;button [style.color]="isSpecial ? 'red' : 'green'"&gt;  <br> <br>

					&lt;button [style.font-size.em]="isSpecial ? 3 : 1" &gt;Big&lt;/button&gt; <br>
					&lt;button [style.font-size.%]="!isSpecial ? 150 : 50" &gt;Small&lt;/button&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>(click)="function-name($event)"</p>
			</div>
			<div class="second_column table_column">
				<p>
					Event binding: <br>
					Target:<br>
					Element property<br>
					Component property<br>
					Directive property<br><br>

					Uses from an element to a component way.<br>
					A template statement responds to an event raised by a binding target
					such as an element, component, or directive.<br><br>

					Template Statements  restriction:<br>
					- assignments (=, +=, -=, ...)<br>
					- new<br>
					- increment and decrement operators (++ and --)<br>
					- no support for the bitwise operators | and &<br>
					- the template expression operators<br><br>

					Template Statements context:<br>
					- refers to  an event handling method of the component instance.<br>
					- may also refer to properties of the template's own context:
					the template $event object, a template input variable (let hero),
					and a template reference variable (#heroForm) are passed to an event handling method of the component.<br>
					- cannot refer to anything in the global namespace. They can't refer to windowor document.
					They can't call console.log  or  Math.max.<br><br>

					-The binding conveys information about the event, including data values, through an event object named $event. If the target event is a native DOM element event, then $event is a DOM event object, with properties such as target and target.value. <br> <br>

					- DOM events carry a payload of information that may be useful to the component.
					These payload stores in $event object. <br>
					- The properties of an $event object vary depending on the type of DOM event. <br>
					- All standard DOM event objects have a target property,
					a reference to the element that raised the event. <br>
					- event.target.value -  returns the current contents of that element. (&lt;input&gt;) <br>
					- event.key - will receive every entered key <br>
					- Using template reference variables (#var) is a best practice.
					These variables provide direct access to an element from within the template.<br>
					- The shortest way to generate some event for updating bindings is - (keyup)="0".<br>
					- (keyup.enter) - Angular calls the event handler only when the user presses Enter.<br>
					- (blur) event will work when focus goes off<br>
					- event can be bind to many template statements<br>
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;button (click)="readRainbow($event)"&gt; <br>
					Calls method readRainbow when a click event is triggered
					on this button element (or its children) and passes in the event object.<br><br>

					&lt;button (click)="deleteHero()"&gt;Delete hero&lt;/button&gt;<br><br>

					&lt;button (click)="onSave($event)"&gt;Save&lt;/button&gt;<br><br>

					&lt;button *ngFor="let hero of heroes"(click)="deleteHero(hero)"&gt;{{hero.name}}&lt;/button&gt;<br><br>

					&lt;form #heroForm (ngSubmit)="onSubmit(heroForm)"&gt; ... &lt;/form&gt;<br><br>

					&lt;button (click)="onSave()"&gt;Save&lt;/button&gt;<br><br>

					&lt;app-hero-detail (deleteRequest)="deleteHero()"&gt;&lt;/app-hero-detail&gt;<br><br>

					&lt;div (myClick)="clicked=$event" clickable&gt;click me&lt;/div&gt;<br>
					Element events may be the more common targets, but Angular looks first to see
					if the name matches an event property of a known directive,
					`myClick` is an event on the custom `ClickDirective`<br><br>

					&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt; <br> <br>

					$event:<br>
					&lt;input (keyup)="onKey($event)"&gt;<br>
					&lt;p&gt;{{values}}&lt;/p&gt;<br><br>

					values = '';<br>
					onKey(event: any) { // without type info<br>
					this.values += event.target.value + ' | '; }<br>

					onKey(event: KeyboardEvent) { // with type info<br>
					this.values += (&lt;HTMLInputElement&gt;event.target).value + ' | '; } <br>
					The $event is now a specific KeyboardEvent.
					The OnKey method more clearly expresses what it expects from the template and how it interprets the event. <br><br>

					&lt;input #box (keyup)="onKey(box.value)"&gt; &lt;p&gt;{{values}}&lt;/p&gt; <br>

					values = ''; onKey(value: string) { this.values += value + ' | '; } <br>
					The template reference variable named box, declared on the &lt;input&gt;
					element, refers to the &lt;input&gt; element itself. <br><br>


					&lt;input #box (keyup)="0"&gt; &lt;p&gt;{{box.value}}&lt;/p&gt; <br>
					code binds the keyup event to the number 0, the shortest template statement possible. <br><br>

					&lt;input #box (keyup.enter)="onEnter(box.value)"&gt; &lt;p&gt;{{value}}&lt;/p&gt;<br><br>

					value = ''; onEnter(value: string) { this.value = value; } } <br><br>

					&lt;input #box (keyup.enter)="update(box.value)" (blur)="update(box.value)"&gt; <br>
					Using enter and blur event. <br><br>

					(blur)="addHero(newHero.value); newHero.value='' "&gt; <br>
					Event bind to two template statements.
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					[(title)]="name"
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Two-way property binding. <br>

					You often want to both display a data property and update that property when the user makes changes.
					On the element side that takes a combination of setting a specific element property
					and listening for an element change event. <br>

					When the element has a settable property called x and a corresponding event named xChange.
					It would be convenient to use two-way binding with HTML form elements like &lt;input&gt; and &lt;select&gt;.
					However, no native HTML element follows the x value and xChange event pattern.
					That’s why, on HTML elements we use directive NgModule
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					[(title)]="name" <br>
					Equivalent to: &lt;my-cmp [title]="name" (titleChange)="name=$event"&gt; <br><br>


					&lt;app-sizer [(size)]="fontSizePx"&gt;&lt;/app-sizer&gt;<br>
					…or<br>
					&lt;app-sizer [size]="fontSizePx" (sizeChange)="fontSizePx=$event"&gt;&lt;/app-sizer&gt;<br><br>

					@Input() size: number | string;<br>
					@Output() sizeChange = new EventEmitter&lt;number&gt;();<br><br>

					dec() { this.resize(-1); }<br>
					inc() { this.resize(+1); }<br><br>

					resize(delta: number) {<br>
					this.size = Math.min(40, Math.max(8, +this.size + delta));<br>
					this.sizeChange.emit(this.size);<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
					[(ngModel)]
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in attribute directive. <br>
					- Two-way data binding to an HTML form element <br>
					- FormsModule is required to use ngModel <br>
					- You can't apply [(ngModel)] to a non-form native element or a third-party custom component. <br>
					- If you need to do something more or something different, you can write the expanded form.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { FormsModule } from '@angular/forms'; <br><br>

					&lt;input [(ngModel)]="currentHero.name"&gt;<br>
					The same as:<br>
					&lt;input [value]="currentHero.name" (input)="currentHero.name=$event.target.value" &gt;<br>
					The same as expend form:<br>
					&lt;input [ngModel]="currentHero.name" (ngModelChange)="currentHero.name=$event"&gt;<br><br>

					&lt;input [ngModel]="currentHero.name" (ngModelChange)="setUppercaseName($event)"&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>[ngClass]</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in attribute directive. <br>
					Add and remove a set of CSS classes.<br>
					- Best to use, when you need to work with many classes.<br>
					- Bind ngClass to a key:value control object. Each key of the object is a CSS class name;
					its value is true if the class should be added, false if it should be removed.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [ngClass]="currentClasses"&gt;
					This div is initially saveable, unchanged, and special&lt;/div&gt; <br><br>

					currentClasses: {}; <br> 
					 setCurrentClasses() { this.currentClasses = { <br>
					'saveable': this.canSave,<br>
					'modified': !this.isUnchanged,<br>
					'special': this.isSpecial }; }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>[ngStyle]</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in attribute directive. <br>
					Add and remove a set of HTML styles <br>
					- Best to use, when you need to work with many styles <br>
					- Bind  ngStyle to a key:value control object. Each key of the object is a style name;
					its value is whatever is appropriate for that style..
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [ngStyle]="currentStyles"&gt;
					This div is initially italic, normal weight, and extra large (24px). &lt;/div&gt; <br><br>

					currentStyles: {};<br>
					 setCurrentStyles() { this.currentStyles = { <br>
					'font-style': this.canSave ? 'italic' : 'normal',<br>
					'font-weight': !this.isUnchanged ? 'bold' : 'normal',<br>
					'font-size': this.isSpecial ? '24px' : '12px' }; }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>*ngIf</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in structural directive. <br>
					- conditionally add or remove an element from the DOM. <br>
					- NgIf – false is better for memory than hide/display,
					because it’s destroys component and all elements from DOM <br>
					- The ngIf directive is often used to guard against null. (Show/hide is useless as a guard.
					Angular will throw an error if a nested expression tries to access a property of null.)
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;app-hero-detail *ngIf="isActive"&gt;&lt;/app-hero-detail&gt; <br>
					Bind the directive to a condition expression like isActive in this example. <br>
					When the isActive expression returns a truthy value, <br>
					NgIf adds the HeroDetailComponent to the DOM. When the expression is falsy, <br>
					NgIf removes the HeroDetailComponent from the DOM,
					destroying that component and all of its sub-components. <br> <br>

					&lt;div *ngIf="currentHero"&gt;Hello, {{currentHero.name}}&lt;/div&gt; <br>
					 &lt;div
					*ngIf="nullHero"&gt;Hello, {{nullHero.name}}&lt;/div&gt; <br>
					The currentHero name will appear only when there is a currentHero.
					The nullHero will never be displayed.
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>*ngFor</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in structural directive. <br>
					- repeat a template for each item in a list.<br>
					- You define a block of HTML that defines how a single item should be displayed.<br>
					You tell Angular to use that block as a template for rendering each item in the list.<br>
					- You can capture the index in a template input variable and use it in the template.<br>
					- You can avoid cascade of DOM manipulations,
					when you did a small change to one item, an item removed, or an item added in a large list.
					Use TrackBy Add  - a method to the component that returns the value NgForOf should track.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div *ngFor="let hero of heroes"&gt;{{hero.name}}&lt;/div&gt; <br><br>

					&lt;app-hero-detail *ngFor="let hero of heroes" [hero]="hero"&gt;&lt;/app-hero-detail&gt;<br><br>

					&lt;div *ngFor="let hero of heroes; let i=index"&gt;{{i + 1}} - {{hero.name}}&lt;/div&gt;<br><br>


					&lt;div *ngFor="let hero of heroes; trackBy: trackByHeroes"&gt; ({{hero.id}}) {{hero.name}} &lt;/div&gt;<br>
					To component:<br>
					trackByHeroes(index: number, hero: Hero): number { return hero.id; }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>[ngSwitch]</p>
			</div>
			<div class="second_column table_column">
				<p>
					Built-in structural directive. <br>
					- A set of directives that switch among alternative views.
					It can display one element from among several possible elements, based on a switch condition.
					Angular puts only the selected element into the DOM.<br>
					- NgSwitch is actually a set of three, cooperating directives: NgSwitch, NgSwitchCase, and NgSwitchDefault.<br>
					- NgSwitch is the controller directive. Bind it to an expression that returns the switch value.<br>
					- Bind to [ngSwitch]. You'll get an error if you try to set *ngSwitch
					because NgSwitch is an attribute directive, not a structural directive.<br>
					- Bind to *ngSwitchCase and *ngSwitchDefault.
					The NgSwitchCase and NgSwitchDefault directives are structural directives because they add or remove elements from the DOM.<br>
					- NgSwitchCase adds its element to the DOM when its bound value equals the switch value.<br>
					- NgSwitchDefault adds its element to the DOM when there is no selected NgSwitchCase.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div [ngSwitch]="currentHero.emotion"&gt; <br>
					&lt;app-happy-hero *ngSwitchCase="'happy'" [hero]="currentHero"&gt;&lt;/app-happy-hero&gt;<br>
					&lt;app-sad-hero *ngSwitchCase="'sad'" [hero]="currentHero"&gt;&lt;/app-sad-hero&gt;<br>
					&lt;app-confused-hero *ngSwitchCase="'confused'" [hero]="currentHero"&gt;&lt;/app-confused-hero&gt;<br>
					&lt;app-unknown-hero *ngSwitchDefault [hero]="currentHero"&gt;&lt;/app-unknown-hero&gt; &lt;/div&gt;<br><br>

					&lt;div *ngSwitchCase="'confused'"&gt;Are you as confused as {{currentHero.name}}?&lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>&lt;ng-container&gt;</p>
			</div>
			<div class="second_column table_column">
				<p>
					The Angular &lt;ng-container&gt; is a grouping element that doesn't interfere with styles or layout
					because Angular doesn't put it in the DOM.<br>
					Better than div/span as a container<br><br>


				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;div&gt; Pick your favorite hero <br>
					(&lt;label&gt;&lt;input type="checkbox" checked (change)="showSad = !showSad"&gt;show sad&lt;/label&gt;)
					<br>
					&lt;/div&gt; <br>
					&lt;select [(ngModel)]="hero"&gt;<br>
					&lt;ng-container *ngFor="let h of heroes"&gt;<br>
					&lt;ng-container *ngIf="showSad || h.emotion !== 'sad'"&gt;<br>
					&lt;option [ngValue]="h"&gt;{{h.name}} ({{h.emotion}})&lt;/option&gt;<br>
					&lt;/ng-container&gt;<br>
					&lt;/ng-container&gt;<br>
					&lt;/select&gt;
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Template-Driven Forms------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="template_forms">
			<h1>Template-Driven Forms</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Template-Driven</p>
			</div>
			<div class="second_column table_column">
				<p>
					Template-driven - forms are useful for adding a simple form to an app,
					such as an email list signup form. They're easy to add to an app, but they don't scale as well as reactive forms.
					If you have very basic form requirements and logic that can be managed solely in the template,
					use template-driven forms. <br><br>

					&lt;form #heroForm="ngForm"&gt;<br>
					&lt;div class="form-group"&gt;
					&lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control"
					id="name" required [(ngModel)]="model.name" name="name" #name="ngModel"&gt;
					&lt;/div&gt; <br><br>

					- Each input element has an id property that is used by the label element's
					for attribute to match the label to its input control. <br>
					- Each input element has a name property that is required by Angular forms to register the control with the form.<br>
					- Each input element has a #value alias to get access to this field <br> <br>

					https://angular.io/guide/forms#summary
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					App.module: <br>
					import { FormsModule } from '@angular/forms';<br>
					@NgModule({<br>
					imports: [FormsModule]<br><br>

					hero.component.html:<br>
					&lt;div class="container"&gt; <br>
					&lt;div [hidden]="submitted"&gt; &lt;h1&gt;Hero Form&lt;/h1&gt;<br>
					&lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; <br>
					&lt;div class="form-group"&gt;<br>
					&lt;label for="name"&gt;Name&lt;/label&gt;<br>
					&lt;input type="text" class="form-control" id="name" required<br>
					[(ngModel)]="model.name" name="name" #name="ngModel"&gt;<br>
					&lt;div [hidden]="name.valid || name.pristine" class="alert alert-danger"&gt; <br>
					Name is required<br>
					&lt;/div&gt;<br>
					&lt;/div&gt;<br><br>

					&lt;div class="form-group"&gt;<br>
					&lt;label for="alterEgo"&gt;Alter Ego&lt;/label&gt;<br>
					&lt;input type="text" class="form-control" id="alterEgo"<br>
					[(ngModel)]="model.alterEgo" name="alterEgo"&gt;<br>
					&lt;/div&gt;<br><br>

					&lt;div class="form-group"&gt;<br>
					&lt;label for="power"&gt;Hero Power&lt;/label&gt;<br>
					&lt;select class="form-control" id="power" required<br>
					[(ngModel)]="model.power" name="power" #power="ngModel"&gt;<br>
					&lt;option *ngFor="let pow of powers" [value]="pow"&gt;{{pow}}&lt;/option&gt;<br>
					&lt;/select&gt;<br>
					&lt;div [hidden]="power.valid || power.pristine" class="alert alert-danger"&gt;<br>
					Power is required<br>
					&lt;/div&gt;<br>
					&lt;/div&gt;<br><br>

					&lt;button type="submit" class="btn btn-success" [disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt; <br>
					&lt;button type="button" class="btn btn-default" (click)="newHero(); heroForm.reset()"&gt;New Hero&lt;/button&gt;<br>
					&lt;/form&gt;<br>
					&lt;/div&gt;<br><br>

					export class HeroFormComponent {<br><br>

					powers = ['Really Smart', 'Super Flexible',<br>
					'Super Hot', 'Weather Changer'];<br>

					model = new Hero(18, 'Dr IQ', this.powers[0], 'Chuck Overstreet');<br>

					submitted = false;<br>

					onSubmit() { this.submitted = true; }<br>

					newHero() {<br>
					this.model = new Hero(42, '', '');<br>
					} }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Control State</p>
			</div>
			<div class="second_column table_column">
				<p>
					The control has been visited: <br>
					ng-touched / ng-untouched <br><br>
					The control's value has changed: <br>
					ng-dirty / ng-pristine <br><br>
					The control's value is valid: <br>
					ng-valid / ng-invalid
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;label for="name"&gt;Name&lt;/label&gt; &lt;input type="text" class="form-control"
					id="name" required [(ngModel)]="model.name" name="name" #name="ngModel"&gt; <br>
					&lt;div [hidden]="name.valid || name.pristine" class="alert alert-danger"&gt;
					Name is required &lt;/div&gt; <br><br>

					&lt;button type="submit" class="btn btn-success"
					[disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Validation</p>
			</div>
			<div class="second_column table_column">
				<p>
					To add validation to a template-driven form,
					you add the same validation attributes as you would with native HTML form validation.
					Angular uses directives to match these attributes with validator functions in the framework.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;input id="name" name="name" class="form-control"
					required minlength="4" appForbiddenName="bob" [(ngModel)]="hero.name" #name="ngModel" &gt; <br>
					&lt;div *ngIf="name.invalid &amp;&amp; (name.dirty || name.touched)" class="alert alert-danger"&gt; <br>
					&lt;div *ngIf="name.errors.required"&gt; Name is required. &lt;/div&gt;<br>
					&lt;div *ngIf="name.errors.minlength"&gt; Name must be at least 4 characters long. &lt;/div&gt;<br>
					&lt;div *ngIf="name.errors.forbiddenName"&gt; Name cannot be Bob. &lt;/div&gt; &lt;/div&gt;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Submit</p>
			</div>
			<div class="second_column table_column">
				<p>
					The user should be able to submit this form after filling it in.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;form (ngSubmit)="onSubmit()" #heroForm="ngForm"&gt; <br>

					&lt;button type="submit" class="btn btn-success"
					[disabled]="!heroForm.form.valid"&gt;Submit&lt;/button&gt;
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Reactive Forms------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="reactive_forms">
			<h1>Reactive Forms</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>
					Reactive (model-driven)
				</p>
			</div>
			<div class="second_column table_column">
				<p>
					Reactive forms - are more robust: they're more scalable, reusable, and testable.
					If forms are a key part of your application,
					or you're already using reactive patterns for building your application, use reactive forms.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					App.module: <br>
					import { ReactiveFormsModule } from '@angular/forms';<br><br>

					@NgModule({ <br>
					imports: [ // other imports ... ReactiveFormsModule ],

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>FormControl</p>
			</div>
			<div class="second_column table_column">
				<p>
					new FormControl(‘’) – Manages the value and validity status of an individual form control.
					It corresponds to an HTML form control such as &lt;input&gt; or &lt;select&gt;. <br> <br>
					setValue() -  method to set a new value for an individual control.
					The setValue() method strictly adheres to the structure of the form group and replaces the entire value for the control.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					template: <br>
					&lt;label&gt; Name: &lt;input type="text" [formControl]="name"&gt; &lt;/label&gt; <br>
					&lt;p&gt; Value: {{ name.value }} &lt;/p&gt; <br><br>

					Component:<br>
					import { FormControl } from '@angular/forms';<br><br>

					export class NameEditorComponent { name = new FormControl('');<br>
					updateName() { this.name.setValue('Nancy'); }<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>FormGroup</p>
			</div>
			<div class="second_column table_column">
				<p>
					new FormGroup(‘’) – Manages the value and validity state of a group of AbstractControl instances.
					The group's properties include its child controls.
					The top-level form in your component is FormGroup. <br><br>

					Just as a form group contains a group of controls,
					the profile form FormGroup is bound to the form element with the FormGroup directive,
					creating a communication layer between the model and the form containing the inputs.
					The formControlName input provided by the FormControlName directive
					binds each individual input to the form control defined in FormGroup. <br><br>

					To create a nested group in component’s template,
					add a nested  element (div) with formGroupName attribute to the form group instance.<br><br>

					patchValue() - method to replace any properties defined in the object that have changed in the form model.
					PatchValue() only updates properties that the form model defines. <br><br>

					The strict checks of the setValue() method help catch nesting errors in complex forms,
					while patchValue() fails silently on those errors.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					template: <br>
					&lt;form [formGroup]="profileForm"&gt;<br>
					&lt;label&gt; First Name: &lt;input type="text" formControlName="firstName"&gt; &lt;/label&gt;<br>
					&lt;label&gt; Last Name: &lt;input type="text" formControlName="lastName"&gt; &lt;/label&gt;<br>
					&lt;div formGroupName="address"&gt; &lt;h3&gt;Address&lt;/h3&gt;<br>
					&lt;label&gt; Street: &lt;input type="text" formControlName="street"&gt; &lt;/label&gt;<br>
					&lt;label&gt; City: &lt;input type="text" formControlName="city"&gt; &lt;/label&gt;<br>
					&lt;label&gt; State: &lt;input type="text" formControlName="state"&gt; &lt;/label&gt;<br>
					&lt;label&gt; Zip Code: &lt;input type="text" formControlName="zip"&gt; &lt;/label&gt; &lt;/div&gt;<br>
					&lt;/form&gt;<br>
					&lt;p&gt; &lt;button (click)="updateProfile()"&gt;Update Profile&lt;/button&gt; &lt;/p&gt;<br><br>


					Component:<br>
					import { FormGroup, FormControl } from '@angular/forms';<br><br>

					export class ProfileEditorComponent {<br>
					profileForm = new FormGroup({<br>
					firstName: new FormControl(''),<br>
					lastName: new FormControl(''),<br>
					address: new FormGroup({<br>
					street: new FormControl(''),<br>
					city: new FormControl(''),<br>
					state: new FormControl(''),<br>
					zip: new FormControl('')
					}) }); } <br><br>

					updateProfile() { this.profileForm.patchValue( <br>
					{ firstName: 'Nancy', address: { street: '123 Drew Street' } }); <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>FormBuilder</p>
			</div>
			<div class="second_column table_column">
				<p>
					The FormBuilder service provides convenient methods for generating controls. <br><br>

					Use the group() method with the same object to define the properties in the model.
					The value for each control name is an array containing the initial value as the first item in the array.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { FormBuilder } from '@angular/forms'; <br><br>

					export class ProfileEditorComponent {<br><br>

					constructor(private fb: FormBuilder) { }<br><br>

					profileForm = this.fb.group({ <br>
					firstName: [''],<br>
					lastName: [''],<br>
					address: this.fb.group({<br>
					street: [''],<br>
					city: [''],<br>
					state: [''],<br>
					zip: ['']<br>
					}),<br>
					}); <br> <br>

					this.firstName = this.studentsForm.controls.firstName.value; <br> <br>

					const form = this.studentsForm.value; <br>
    				const num = form.firstName + form.lastName + form.age;
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>FormArray</p>
			</div>
			<div class="second_column table_column">
				<p>
					FormArray is an alternative to FormGroup for managing any number of unnamed controls.
					However, you don't need to define a key for each control by name,
					so this is a great option if you don't know the number of child values in advance. <br> <br>

					A getter provides easy access to the aliases in the form array instance
					compared to repeating the profileForm.get() method to get each instance.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { FormArray } from '@angular/forms'; <br><br>

					&lt;div formArrayName="aliases"&gt;<br>
					&lt;h3&gt;Aliases&lt;/h3&gt;<br>
					&lt;button (click)="addAlias()"&gt;Add Alias&lt;/button&gt;<br>
					&lt;div *ngFor="let address of aliases.controls; let i=index"&gt; &lt;!-- The repeated alias template --&gt;<br>
					&lt;label&gt; Alias: &lt;input type="text" [formControlName]="i"&gt; &lt;/label&gt;<br>
					&lt;/div&gt; &lt;/div&gt;<br><br>


					profileForm = this.fb.group({<br>
					aliases: this.fb.array([<br>
					this.fb.control('')<br>
					])<br>
					});<br>
					get aliases() { return this.profileForm.get('aliases') as FormArray; }<br> <br>

					addAlias() { this.aliases.push(this.fb.control('')); } <br> <br>

					 this.aliasesBook = this.profileForm.get('aliases') as FormArray;<br>
   					this.alias = this.aliasesBook.at(0).value;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Control Status</p>
			</div>
			<div class="second_column table_column">
				<p>
					Angular automatically mirrors many control properties onto the form control element as CSS classes.
					You can use these classes to style form control elements according to the state of the form. <br>
					.ng-valid<br>
					.ng-invalid<br>
					.ng-pending<br>
					.ng-pristine<br>
					.ng-dirty<br>
					.ng-untouched<br>
					.ng-touched
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					.ng-valid[required], .ng-valid.required { <br>
					border-left: 5px solid #42A948; /* green */ }<br><br>

					.ng-invalid:not(form) {<br>
					border-left: 5px solid #a94442; /* red */ }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Validation</p>
			</div>
			<div class="second_column table_column">
				<p>
					Form validation is used to validate user input to ensure it's complete and correct. <br>

					HTML5 has a set of built-in attributes that you can use for native validation,
					including required, minlength, and maxlength.<br>
					Use these HTML5 validation attributes in combination with the built-in validators
					provided by Angular's reactive forms.<br>

					There are two types of validator functions: sync validators and async validators. <br>
					- Sync validators: functions that take a control instance
					and immediately return either a set of validation errors or null.
					You can pass these in as the second argument when you instantiate a FormControl.<br>
					- Async validators: functions that take a control instance
					and return a Promise or Observable that later emits a set of validation errors or null.
					You can pass these in as the third argument when you instantiate a FormControl.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Validators } from '@angular/forms'; <br> <br>

					&lt;input id="name" class="form-control" formControlName="name" required &gt;<br>
					&lt;div *ngIf="name.invalid &amp;&amp; (name.dirty || name.touched)" class="alert alert-danger"&gt;<br>
					&lt;div *ngIf="name.errors.required"&gt; Name is required. &lt;/div&gt;<br>
					&lt;div *ngIf="name.errors.minlength"&gt; Name must be at least 4 characters long. &lt;/div&gt;<br>
					&lt;div *ngIf="name.errors.forbiddenName"&gt; Name cannot be Bob. &lt;/div&gt;<br>
					&lt;/div&gt;<br><br>

					this.heroForm = new FormGroup({<br>
					'name': new FormControl( this.hero.name, [<br>
					Validators.required,<br>
					Validators.minLength(4),<br>
					forbiddenNameValidator(/bob/i) // &lt;-- Here's how you pass in the custom validator. ]),<br><br>

					get name() { return this.heroForm.get('name'); }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Submit</p>
			</div>
			<div class="second_column table_column">
				<p>
					- Add an ngSubmit event listener to the form tag with the onSubmit() callback method. <br>
					- The onSubmit() method in the  component captures the current value of profileForm.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;form [formGroup]="profileForm" (ngSubmit)="onSubmit()"&gt; <br>
					&lt;button type="submit" [disabled]="!profileForm.valid"&gt;Submit&lt;/button&gt;  <br> <br>

					onSubmit() { console.warn(this.profileForm.value); } <br> <br>

					onSubmit() { console.warn(this.profileForm.controls.firstName.value;); }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Dynamic Forms</p>
			</div>
			<div class="second_column table_column">
				<p>
					use formGroup to dynamically render a simple form with different control types and validation.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					https://angular.io/guide/dynamic-form#dynamic-forms
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Components Relationship------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="components_relationship">
			<h1>Components Relationship</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Input</p>
			</div>
			<div class="second_column table_column">
				<p>
					An Input property is a settable property annotated with an @Input decorator.
					Values flow intothe property when it is data bound with a property binding. <br>
					-Input properties usually receive data values. <br>
					-You can only bind to another component or directive. <br>
					-You can specify the alias for the property name by passing it into the input/output decorator. <br>
					- Intercept input property changes with a setter. <br>
					- You can use optional input values with '?' operator.
					- Detect and act upon changes to input property values
					with the ngOnChanges() method of the OnChanges lifecycle hook interface.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;app-hero-detail [hero]="currentHero"
					(deleteRequest)="deleteHero($event)"&gt; &lt;/app-hero-detail&gt; <br>
					And <br>
					@Input() hero: Hero; <br><br>

					Or<br><br>

					@Component({ <br>
					inputs: ['hero'],<br>
					outputs: ['deleteRequest'],<br>
					})<br><br>


					@Input('master') masterName: string;<br>
					And<br>
					&lt;app-hero-child [master]="master"&gt; &lt;/app-hero-child&gt;<br><br>

					@Input('') unUsedVariable?: string;<br>
					And<br>
					&lt;app-hero-child [master]="master"&gt; &lt;/app-hero-child&gt;<br>
					Optional input value, that aren't sent; <br> <br>

					private _name = ''; <br>
					@Input()<br>
					set name(name: string) {<br>
					this._name = (name &amp;&amp; name.trim()) || '&lt;no name set&gt;';<br>
					}<br>
					get name(): string { return this._name; }<br>
					}<br>
					And<br>
					&lt;app-name-child *ngFor="let name of names" [name]="name"&gt;&lt;/app-name-child&gt;
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Output</p>
			</div>
			<div class="second_column table_column">
				<p>
					An Output property is an observable property annotated with an @Output decorator. <br>
					The property almost always returns an Angular EventEmitter. <br>
					Values flow out of the component as events bound with an event binding.
					Output properties expose event producers, such as EventEmitter objects. <br>
					You can only bind to another component or directive. <br>
					You can specify the alias for the property name by passing it into the input/output decorator. <br><br>

					The directive/component creates an EventEmitter and exposes it as a property. <br>
					The directive calls EventEmitter.emit(payload) to fire an event,
					passing in a message payload, which can be anything.
					Parent directives/components listen for the event by binding to this property
					and accessing the payload through the $event object. <br><br>

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;app-hero-detail [hero]="currentHero"
					(deleteRequest)="deleteHero($event)"&gt; &lt;/app-hero-detail&gt; <br><br>

					@Output() deleteRequest = new EventEmitter&lt;Hero&gt;();<br>
					Or<br>
					@Component({<br>
					inputs: ['hero'],<br>
					outputs: ['deleteRequest'],<br>
					})<br><br>

					@Output('myClick') clicks = new EventEmitter&lt;string&gt;();<br>
					clicks – internal property<br>
					or<br>
					@Directive({<br>
					outputs: ['clicks:myClick'] // propertyName:alias })<br><br>

					Child: <br>
					template:<br>
					&lt;button (click)="delete()"&gt;Delete&lt;/button&gt;<br>
					component:<br>
					deleteRequest = new EventEmitter&lt;Hero&gt;();<br>
					delete() { this.deleteRequest.emit(this.hero); }<br><br>

					Parent:<br>
					template:<br>
					&lt;app-hero-detail (deleteRequest)="deleteHero($event)"&gt;&lt;/app-hero-detail&gt; <br>
					component:<br>
					deleteHero($event){…}

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>#var</p>
			</div>
			<div class="second_column table_column">
				<p>
					By creating a template reference variable for the child element
					and then reference that variable within the parent template you can read child properties
					or invoke child methods. <br>
					- it is limited because the parent-child wiring must be done entirely within the parent template.
					The parent component itself has no access to the child. <br>
					- You can't use the local variable technique if an instance of the parent component class
					must read or write child component values or must call child component methods.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Parent: <br>
					1&lt;button (click)="timer.start()"&gt;Start&lt;/button&gt; <br>
					&lt;button (click)="timer.stop()"&gt;Stop&lt;/button&gt; <br>
					&lt;div class="seconds"&gt;{{timer.seconds}}&lt;/div&gt; <br>
					&lt;app-countdown-timer #timer&gt;&lt;/app-countdown-timer&gt;<br><br>

					Child:<br>
					intervalId = 0;<br>
					message = '';<br>
					seconds = 11;<br><br>

					clearTimer() { clearInterval(this.intervalId); }<br>

					ngOnInit() { this.start(); }<br>
					ngOnDestroy() { this.clearTimer(); }<br>

					start() { this.countDown(); }<br>
					stop() {<br>
					this.clearTimer();<br>
					this.message = `Holding at T-${this.seconds} seconds`;<br>
					}<br>

					private countDown() {<br>
					this.clearTimer();<br>
					this.intervalId = window.setInterval(() =&gt; {<br>
					this.seconds -= 1;<br>
					if (this.seconds === 0) {<br>
					this.message = 'Blast off!';<br>
					} else {<br>
					if (this.seconds &lt; 0) { this.seconds = 10; } // reset<br>
					this.message = `T-${this.seconds} seconds and counting`;<br>
					}<br>
					}, 1000); }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>&lt;ng-content&gt;</p>
			</div>
			<div class="second_column table_column">
				<p>
					- The ng-content element allows you to embed the parent html component in the child components. <br>
					- Instead of the &lt;ng-content&gt; element from the outside, any content can be transferred. <br>
					- Manage the markup that is inserted into &lt;ng-content&gt; will be managed by AppComponent. That is why this component sets the styles and html expressions for the inserted text. <br> <br>

					&lt;hero-contact&gt; element between the &lt;hero-bio&gt; tags.<br>
					Angular projects, or transcludes, the corresponding HeroContactComponent into the HeroBioComponent view,
					placing it in the &lt;ng-content&gt; slot of the HeroBioComponent template.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Child.component: <br>
					template: `&lt;ng-content&gt;&lt;/ng-content&gt;<br>
					&lt;p&gt;Hello {{name}}&lt;/p&gt;`<br><br>

					export class ChildComponent { <br>
					    name= "Eugene";<br>
					}<br><br>

					App.component:<br>
					 template: `&lt;child-comp&gt;&lt;h2&gt;Welcome {{name}}!&lt;/h2&gt;&lt;/child-comp&gt;`<br><br>

					export class AppComponent { <br>
					    name = 'Tom';<br>
					}<br><br>
					 
					Welcome Tom<br>
					Hello Eugene <br> <br> <br>

					App.component:<br>
					template: `<br>
					&lt;app-hero-bio [heroId]="1"&gt; &lt;app-hero-contact&gt; &lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;
					<br>
					&lt;app-hero-bio [heroId]="2"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;<br>
					&lt;app-hero-bio [heroId]="3"&gt; &lt;app-hero-contact&gt;&lt;/app-hero-contact&gt; &lt;/app-hero-bio&gt;`,<br><br>

					hero-bio.component: (inside)<br>
					template: `<br>
					&lt;h4&gt;{{hero.name}}&lt;/h4&gt;<br>
					&lt;ng-content&gt;&lt;/ng-content&gt;<br>
					&lt;textarea cols="25" [(ngModel)]="hero.description"&gt;&lt;/textarea&gt;`,<br>
					// app-hero-contact will be place on ng-content element <br> <br> <br>

					Parent: <br>
					&lt;childComp&gt; <br>
					&lt;h1 class="first"&gt;Some Text&lt;/h1&gt; <br>
					&lt;h1 class="second"&gt;Some Other Text&lt;/h1&gt; <br>
					&lt;/childComp&gt; <br><br>

					child:<br>
					&lt;div&gt;&lt;ng-content select=".first"&gt;&lt;/ng-content&gt;&lt;/div&gt;<br>
					&lt;div&gt;&lt;ng-content select=".second"&gt;&lt;/ng-content&gt;&lt;/div&gt;<br><br><br>

					Parent: <br>
					&lt;childComp [reference]="parentText"&gt; <br>
					&lt;/childComp&gt; <br><br>

					&lt;div #parentText&gt;Parent Text&lt;/div&gt; <br><br>

					Child: <br>
					&lt;ng-container [ngTemplateOutlet]="reference"&gt;&lt;/ng-container&gt; <br><br>

					@Input() reference: TemplateRef&lt;any&gt;;
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@ViewChild()</p>
			</div>
			<div class="second_column table_column">
				<p>
					When the parent component class requires to use the local variable technique
					if an instance of the parent component class must read or write child component values
					or must call child component methods inject the child component into the parent as a ViewChild.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Parent: <br>
					template: ` <br>
					&lt;h3&gt;Countdown to Liftoff (via ViewChild)&lt;/h3&gt; <br>
					&lt;button (click)="start()"&gt;Start&lt;/button&gt;<br>
					&lt;button (click)="stop()"&gt;Stop&lt;/button&gt;<br>
					&lt;div class="seconds"&gt;{{ seconds() }}&lt;/div&gt;<br>
					&lt;app-countdown-timer&gt;&lt;/app-countdown-timer&gt;<br>
					`,<br>
					Component:<br>
					@ViewChild(CountdownTimerComponent)<br>
					private timerComponent: CountdownTimerComponent;<br>
					start() { this.timerComponent.start(); }<br>
					stop() { this.timerComponent.stop(); }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Content Child()</p>
			</div>
			<div class="second_column table_column">
				<p>ContentChildren includes only elements that exists within the ng-content tag. <br>

					We can use decorator, ContentChild, to communicate with template variables. <br>
					To get the variables that are passed with the code through ng-content, the child component uses the ContentChild decorator. <br>
					 The name of the variable is also passed to this decorator. The decorator property itself also represents an ElementRef object.
					  And then we can manipulate this object.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					ChildComponent: <br> <br>

					import { Component, ContentChild, ElementRef } from '@angular/core';<br><br>
					       
					@Component({<br>
					    selector: 'child-comp',<br>
					    template: `&lt;ng-content&gt;&lt;/ng-content&gt;<br>
					               &lt;button (click)="change()"&gt;Change&lt;/button&gt;`<br>
					})<br><br>
					export class ChildComponent{ <br><br>
					     
					    @ContentChild("headerContent")<br>
					    header: ElementRef;<br><br>
					     
					    change() { <br>
					        console.log(this.header); <br>
					        this.header.nativeElement.textContent = "Hell to world!"; <br>
					    }<br>
					}<br><br>

					AppComponent:<br><br>

					import { Component} from '@angular/core';<br><br>
					       
					@Component({<br>
					    selector: 'my-app',<br>
					    template: `&lt;child-comp&gt;<br>
					                    &lt;h3 #headerContent&gt;Welcome {{name}}!&lt;/h3&gt;<br>
					               &lt;/child-comp&gt;`<br>
					})<br><br>
					export class AppComponent { <br><br>
					 
					    name: string = "Tom";<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Constructor</p>
			</div>
			<div class="second_column table_column">
				<p>
					Each component has a host view, and can have additional embedded views.
					An embedded view in component A is the host view of component B,
					which can in turn have embedded view. This means that there is a view hierarchy for each component,
					of which that component's host view is the root. <br>
					Because every component instance is added to an injector's container,
					you can use Angular dependency injection to reach a parent component.
					You use standard class injection to acquire a parent component whose type you know. <br>
					constructor( @Optional() public parent: ParentComponent ) { }
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					@Component({ <br>
					selector: 'parent', <br>
					template: ` <br>
					&lt;div class="a"&gt; <br>
					&lt;h3&gt;{{name}}&lt;/h3&gt; <br>
					&lt;child1&gt;&lt;/child1&gt; <br>
					&lt;child2&gt;&lt;/child2&gt; <br>
					&lt;child3&gt;&lt;/child3&gt; <br>
					&lt;/div&gt;`, <br>
					}) <br> <br>

					export class AlexComponent extends Base { <br>
					name = 'Alex'; <br>
					} <br> <br>

					@Component({<br>
					selector: 'child1',<br>
					template: `<br>
					&lt;div class="c"&gt;<br>
					&lt;h3&gt;child1&lt;/h3&gt;<br>
					{{parent ? 'Found' : 'Did not find'}} Parent via the component class. <br>
					&lt;/div&gt;`<br>
					})<br><br>

					export class CathyComponent {<br>
					constructor( @Optional() public alex: AlexComponent ) { }<br>
					}
				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Service</p>
			</div>
			<div class="second_column table_column">
				<p>
					A parent component and its children share a service
					whose interface enables bi-directional communication within the family.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Service: <br>
					  subject = new Subject(); <br><br>

						getSubject() {<br>
					    return this.subject.asObservable();<br>
					  }<br><br>

					  setSubject(value) {<br>
					    return this.subject.next(value);<br>
					  }<br><br>

					  Listening Component: <br>
					    ngOnInit(): void { <br>
						    this.observableService.getSubject().pipe(<br>
						      takeUntil (this.onDestroy$)<br>
						    ).subscribe(<br>
						      (value) => this.messageService.add(`Observables #3 value: ${value}`),<br>
						      (err) => this.messageService.add(`Observables #3 catch error: ${err}`),<br>
						      () => this.messageService.add(`Observables #3 : Test finished Successfully`)<br>
						    );<br>
						  }<br><br>

					Setting Component: <br>
					  useService(value) { <br>
					    this.observableService.setSubject(value); <br>
					  } <br><br>

					  or <br> <br>

					 this.observableService.setSubject(1); <br>
					 this.observableService.setSubject(2); <br>
					 this.observableService.setSubject(3); <br><br>

					 Template: <br>
					 &lt;input type="text" id="inputObservable" #input (keyup)="useService(input.value)"&gt; <br>
					 &lt;button (click)="useService(input.value)"&gt;Set Subject&lt;/button&gt; <br> <br> <br>

					 https://angular.io/guide/component-interaction#parent-and-children-communicate-via-a-service
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Directives------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="directives">
			<h1>Directives</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Directive </p>
			</div>
			<div class="second_column table_column">
				<p>Declares that a class is a directive and provides metadata about the directive. <br><br>

					There are three kinds of directives in Angular:<br>
					1.	Components—directives with a template.<br>
					2.	Structural directives—change the DOM layout by adding and removing DOM elements.<br>
					3.	Attribute directives—change the appearance or behavior of an element, component,
					or another directive.<br><br>

					You can apply many attribute directives to one host element.
					You can only apply one structural directive to a host element.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Directive } from '@angular/core'; <br>
					@Directive({...})<br>
					class MyDirective() {}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Properties</p>
			</div>
			<div class="second_column table_column">
				<p>
					selector: '' - <br>
					Specifies a CSS selector that identifies this directive within a template.
					Supported selectors include element, [attribute], .class, and :not().
					Does not support parent-child relationship selectors. <br> <br>
					providers: [] - <br>
					List of dependency injection providers for this directive and its children.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					selector: '.cool-button:not(a)' <br>
					providers: [MyService, { provide: ... }]
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Input</p>
			</div>
			<div class="second_column table_column">
				<p>
					@Input decorator adds metadata to the class that makes the directive's  property available for binding.
					It's called an input property because data flows from the binding expression into the directive.<br>
					- Use binding  with “variable” after directive attribute, or use just binding,
					if the name of input variable is the same as selector name.<br>
					- Use Input alias to rename the variable to proper name.<br>
					- To use more input properties, just use property bindings after selector’s name or main property.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p appHighlight [highlightColor]="'orange'"&gt;Highlighted in orange&lt;/p&gt; <br><br>

					&lt;p [appHighlight]="color"&gt;Highlight me!&lt;/p&gt; // if you have the same name of property!<br><br>

					@Input('appHighlight') highlightColor: string;<br><br>

					&lt;p [appHighlight]="color" [defaultColor]="defaultColor"&gt; Highlight me too! &lt;/p&gt;

				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@HostListener</p>
			</div>
			<div class="second_column table_column">
				<p>
					The @HostListener decorator lets you subscribe to events of the DOM element
					that hosts an attribute directive.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p appHighlight&gt;Highlight me!&lt;/p&gt; <br> <br>

					import { Directive, ElementRef, HostListener } from '@angular/core'; <br> <br>
					@Directive({ selector: '[appHighlight]' })<br> <br>

					constructor(private el: ElementRef) { }<br>
					@HostListener('mouseenter') onMouseEnter() {<br>
					this.highlight('yellow');<br>
					}<br>
					@HostListener('mouseleave') onMouseLeave() {<br>
					this.highlight(null);<br>
					}<br>
					private highlight(color: string) {<br>
					this.el.nativeElement.style.backgroundColor = color;<br>
					}}<br><br>

					Or<br><br>

					@HostListener('mouseenter') onMouseEnter() {<br>
					this.highlight(this.highlightColor || 'red');<br>
					} // when you don’t have entered color. (default value – red)<br>
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@HostBinding</p>
			</div>
			<div class="second_column table_column">
				<p>
					Allows you to bind a regular class property with the property of the element to which the directive applies.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					
					import {Directive, HostListener, HostBinding} from '@angular/core'; <br><br>
 
					@Directive({<br>
					    selector: '[bold]'<br>
					})<br><br>
					export class BoldDirective{<br><br>
					     
					    private fontWeight = "normal";<br><br>
					     
					    @HostBinding("style.fontWeight") get getFontWeight(){<br><br>
					         
					        return this.fontWeight;<br>
					    }<br><br>
					     
					    @HostBinding("style.cursor") get getCursor(){<br><br>
					        return "pointer";<br>
					    }<br><br>
					     
					    @HostListener("mouseenter") onMouseEnter() {<br><br>
					        this.fontWeight ="bold";<br>
					    }<br><br>
					 
					    @HostListener("mouseleave") onMouseLeave() {<br><br>
					        this.fontWeight = "normal";<br>
					    }<br>
					}<br><br>


					Instructions: <br>
					@HostBinding ("style.fontWeight") get getFontWeight () binds with the property
					 "style.fontWeight" the value returned by this getFontWeight getter.<br>
					  And it returns the value of the fontWeight property, which also changes when you move the mouse pointer.

				</p>
			</div>
		</div>

				<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>host</p>
			</div>
			<div class="second_column table_column">
				<p>
					
					Instead of using the HostListener and HostBinding decorators to respond to directives on user actions,
					 we can define event handlers in the Directive decorator using its host property.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import {Directive, ElementRef, Renderer2} from '@angular/core'; <br><br>
  			
					@Directive({<br>
					    selector: '[bold]',<br>
					    host: {<br>
					        '(mouseenter)': 'onMouseEnter()',<br>
					        '(mouseleave)': 'onMouseLeave()'<br>
					    }<br>
					})<br><br>
					export class BoldDirective{<br><br>
					      
					    constructor(private element: ElementRef, private renderer: Renderer2){<br><br>
					          
					        this.renderer.setStyle(this.element.nativeElement, "cursor", "pointer");<br>
					    }<br><br>
					     
					    onMouseEnter(){<br><br>
					        this.setFontWeight("bold");<br>
					    }<br><br>
					    onMouseLeave(){<br><br>
					        this.setFontWeight("normal");<br>
					    }<br><br>
					    private setFontWeight(val: string) {<br><br>
					        this.renderer.setStyle(this.element.nativeElement, "font-weight", val);<br>
					    }<br>
					}

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Custom Attribute Directive</p>
			</div>
			<div class="second_column table_column">
				<p>Example of custom attribute directive.</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p [appHighlight]="color" defaultColor="violet"&gt; <br>
					Highlight me too!<br>
					&lt;/p&gt;<br><br>

					import { Directive, ElementRef, HostListener, Input } from '@angular/core';<br><br>

					@Directive({<br>
					selector: '[appHighlight]'<br>
					})<br><br>
					export class HighlightDirective {<br><br>

					constructor(private el: ElementRef) { }<br><br>

					@Input() defaultColor: string;<br>

					@Input('appHighlight') highlightColor: string;<br>

					@HostListener('mouseenter') onMouseEnter() {<br>
					this.highlight(this.highlightColor || this.defaultColor || 'red');<br>
					}<br>

					@HostListener('mouseleave') onMouseLeave() {<br>
					this.highlight(null);<br>
					}<br>

					private highlight(color: string) {<br>
					this.el.nativeElement.style.backgroundColor = color;<br>
					} }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Custom Structural Directive </p>
			</div>
			<div class="second_column table_column">
				<p>
					Creating a directive is similar to creating a component. <br>
					- Import the Directive decorator (instead of the Component decorator). <br>
					- Import the Input, TemplateRef, and ViewContainerRef symbols; you'll need them for any structural directive. <br>
					- Apply the decorator to the directive class. <br>
					- Set the CSS attribute selector that identifies the directive when applied to an element in a template. <br> <br>

					A simple structural directive like this one creates an embedded view
					from the Angular-generated &lt;ng-template&gt;and inserts that view
					in a view container adjacent to the directive's original &lt;p&gt; host element.
					You'll acquire the &lt;ng-template&gt; contents with a TemplateRef
					and access the view container through aViewContainerRef.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p *appUnless="condition"&gt;
					(A) This paragraph is displayed because the condition is false. &lt;/p&gt; <br> <br>

					import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';<br> <br>
					 @Directive({ selector: '[appUnless]'})<br> <br>
					export class UnlessDirective { <br><br>
					private hasView = false;<br><br>
					constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef) { } <br><br>
					@Input() set appUnless(condition: boolean) {<br>
					if (!condition &amp;&amp; !this.hasView) {<br>
					this.viewContainer.createEmbeddedView(this.templateRef);<br>
					this.hasView = true; }<br>
					else if (condition &amp;&amp; this.hasView) {<br>
					this.viewContainer.clear(); this.hasView = false; }<br>
					} }
				</p>
			</div>
		</div>

		<div class="tips_table_row zebra2">
			<div class="second_column table_column">
				<h2>Tips:</h2>
				<p>
					Sets the constructor's parameter to the injected ElementRef.
					ElementRef is a wrapper around a DOM element,
					whose nativeElement property exposes the DOM element for the directive to manipulate.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Directive, ElementRef } from '@angular/core';<br><br>

					private el: HTMLElement; <br><br>

					constructor(el: ElementRef) {<br>
					this.el = el.nativeElement;<br>
					}<br><br>

					private highlight(color: string) {<br>
					this.el.style.backgroundColor = color;<br>
					}
				</p>
			</div>
		</div>
		<!-- -------------------------------------------------Pipes------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="pipes">
			<h1>Pipes</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Pipe</p>
			</div>
			<div class="second_column table_column">
				<p>
					Declares that a class is a pipe and provides metadata about the pipe. <br><br>

					•	A pipe is a class decorated with pipe metadata.<br>
					•	The pipe class implements the PipeTransform interface's transform method
					that accepts an input value followed by optional parameters and returns the transformed value. <br>
					•	There will be one additional argument to the transform method for each parameter passed to the pipe.
					<br>
					•	To tell Angular that this is a pipe, you apply the @Pipe decorator,
					which you import from the core Angular library.<br>
					•	The @Pipe decorator allows you to define the pipe name that you'll use within template expressions.
					It must be a valid JavaScript identifier.<br>
					•	You must include your pipe in the declarations array of the AppModule.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Pipe, PipeTransform } from '@angular/core';  <br>
					class MyPipe implements PipeTransform {  <br>
					transform (input parameters) { return; } <br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Syntax</p>
			</div>
			<div class="second_column table_column">
				<p>
					A pipe takes in data as input and transforms it to a desired output. <br>
					- A pipe can accept any number of optional parameters to fine-tune its output.  <br>
					- You can chain pipes together in potentially useful combinations.
					- Pipes can receive parameters. All parameters in the pipe are passed through the ':'.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p&gt;The hero's birthday is {{ birthday | date }}&lt;/p&gt; <br>
					birthday = new Date(1988, 3, 15); // April 15, 1988  <br> <br>

					&lt;p&gt;The hero's birthday is {{ birthday | date:"MM/dd/yy" }} &lt;/p&gt;  <br> <br>

					The chained hero's birthday is {{ birthday | date:'fullDate' | uppercase}} <br> <br>

					&lt;div&gt;{{welcome | slice:3}}&lt;/div&gt; <br>
               		&lt;div&gt;{{welcome | slice:6:11}}&lt;/div&gt; <br><br>
  
				    welcome: string = "Hello World!";<br><br>

					// lo World!<br>
					// World <br> <br>

					&lt;newChildComp [justValue] = '$childInput | async'&gt;&lt;/newChildComp&gt; <br> <br>

					module: <br>
					providers: [ExponentialPipe], <br> <br>
					
					Component: <br>
					pipeValue = this.expPipe.transform(2, '10');
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Built-in Pipes</p>
			</div>
			<div class="second_column table_column">
				<p>
					-CurrencyPipe: format currency <br>
					-PercentPipe: Percent Format<br>
					-UpperCasePipe: converts a string to uppercase<br>
					-LowerCasePipe: converts the string to lowercase<br>
					-DatePipe: format date<br>
					-DecimalPipe: sets the number format<br>
					-SlicePipe: truncates the string<br><br>

					When classes are used, the Pipe suffix is ​​rejected
					 (with the exception of DecimalPipe - the name "number" is used to apply it):
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Component} from '@angular/core'; <br><br>
       
						@Component({<br>
						    selector: 'my-app',<br>
						    template: `&lt;div&gt;{{welcome | uppercase}}&lt;/div&gt;<br>
						               &lt;div&gt;{{welcome | lowercase}}&lt;/div&gt;<br>
						               &lt;div&gt;{{persentage | percent}}&lt;/div&gt;<br>
						               &lt;div&gt;{{persentage | currency}}&lt;/div&gt;`<br>
						})<br><br>
						export class AppComponent { <br><br>
						 
						    welcome: string = "Hello World!";<br>
						    persentage: number = 0.14; <br>
						}<br><br>

						// HELLO WORLD!
						// hello world!
						// 14%
						// USD 0.14
				</p>
			</div>
		</div>

				<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>AsyncPipe</p>
			</div>
			<div class="second_column table_column">
				<p>	
					AsyncPipe allows you to get the result of an asynchronous operation, defaults to impure. <br>
					AsyncPipe tracks the Observable and Promise objects and returns the value obtained from these objects. <br>
					 When receiving a value, AsyncPipe signals the component to check for changes.
					  If a component is destroyed, AsyncPipe automatically unsubscribes from Observable and Promise objects,
					   which disable possible memory leaks.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Component } from '@angular/core'; <br>
					import { Observable, interval } from 'rxjs'; <br>
					import { map } from 'rxjs/operators';<br><br>
					        
					@Component({<br>
					    selector: 'my-app',<br>
					    template: `&lt;p&gt;Модель: {{ phone| async }}&lt;/p&gt;<br>
					               &lt;button (click)="showPhones()"&gt;Посмотреть модели&lt;/button&gt;`<br>
					})<br><br>
					export class AppComponent { <br><br>
					  
					    phones = ["iPhone 7", "LG G 5", "Honor 9", "Idol S4", "Nexus 6P"];<br>
					      
					    phone: Observable&lt;string&gt;;<br><br>
					    constructor() { this.showPhones(); }<br><br>
					    
					    showPhones() {<br><br>
					        this.phone = interval(500).pipe(map((i:number)=&gt; this.phones[i]));<br>
					    }<br>
					}<br><br>

					Здесь с периодичностью в 500 миллисекунд в шаблон компонента передается очередной элемент из массива phones.
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Impure Pipes</p>
			</div>
			<div class="second_column table_column">
				<p>
					There are two categories of pipes: pure and impure. Pipes are pure by default. <br>
					Angular executes an impure pipe during every component change detection cycle.
					It will not ignore changes in complex objects, as pure pipe will.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					@Pipe({ <br>
					name: 'somePipeImpure',<br>
					pure: false<br>
					})
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Custom Pipe</p>
			</div>
			<div class="second_column table_column">
				<p>Example of custom pipe.</p>
			</div>
			<div class="third_column table_column">
				<p>
					&lt;p&gt;Super power boost: {{2 | exponentialStrength: 10}}&lt;/p&gt;<br><br>

					import { Pipe, PipeTransform } from '@angular/core';<br><br>

					@Pipe({<br>
					name: 'exponentialStrength'<br>
					})<br><br>

					export class ExponentialStrengthPipe implements PipeTransform {<br><br>

					transform(value: number, exponent: string): number {<br>
					let exp = parseFloat(exponent);<br>
					return Math.pow(value, isNaN(exp) ? 1 : exp);<br>
					} } <br> <br>

					&lt;p&gt;The hero's birthday is {{ birthday | date:format }}&lt;/p&gt; <br>
					&lt;button (click)="toggleFormat()"&gt;Toggle Format&lt;/button&gt; <br><br>

					export class HeroBirthday2Component { <br>
					birthday = new Date(1988, 3, 15); // April 15, 1988 <br>
					toggle = true; // start with true == shortDate <br>
					get format() {<br>
					return this.toggle ? 'shortDate' : 'fullDate'; }<br>
					toggleFormat() {<br>
					this.toggle = !this.toggle;<br>
					} }
				</p>
			</div>
		</div>

		<!-- -------------------------------------------------Dependency Injection------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="services">
			<h1>Services</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Injectable</p>
			</div>
			<div class="second_column table_column">
				<p>
					@Injectable - Declares that a class has dependencies that should be injected
					into the constructor when the dependency injector is creating an instance of this class. <br>
					@Injectable() decorator is required for all services.<br>
					The @Injectable() decorator marks it as a service that can be injected,
					but Angular can't actually inject it anywhere until you configure an Angular dependency injector
					with a provider of that service.<br>
					Service can have their own dependencies. So, you can inject service into other service.<br><br>

					Dependencies are services or objects that a class needs to perform its function.
					DI is a coding pattern in which a class asks for dependencies from external sources
					rather than creating them itself. The DI framework provides declared dependencies to a class
					when that class is instantiated.<br><br>

					The DI framework lets you supply data to a component
					from an injectable service class, defined in its own file.<br><br>

					When a component requests a dependency, Angular tries to satisfy that dependency
					with a provider registered in that component's own injector.
					If the component's injector lacks the provider,
					it passes the request up to its parent component's injector.
					When there is no more parents – error.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Service:<br>
					import { Injectable } from '@angular/core'; <br><br>
					import { HEROES } from './heroes';

					@Injectable({ providedIn: 'root', })<br><br>

					export class HeroService {<br>
					getHeroes() { return HEROES;<br>
					} }<br><br>

					Component:<br>
					import { HeroService } from './hero.service';<br>

					heroes: Hero[];<br>
					constructor(heroService: HeroService) {<br>
					this.heroes = heroService.getHeroes();<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Scope</p>
			</div>
			<div class="second_column table_column">
				<p>
					Services are singletons within the scope of an injector. <br><br>
					You can configure injectors with providers at different levels of your app,
					by setting a metadata value in one of three places:<br>
					- In the @Injectable() decorator for the service itself.<br>
					- In the @NgModule() decorator for an NgModule.<br>
					- In the @Component() decorator.<br>

					@NgModule() - For both root-level and module-level injectors,
					a service instance lives for the life of the app or module,
					and Angular injects this one service instance in every class that needs it. <br>
					@Component() - Component-level providers configure each component instance's own injector.
					Angular can only inject the corresponding services in that component instance
					or one of its descendant component instances. For component and it’s children.
					Angular can't inject the same service instance anywhere else.
					A component-provided service may have a limited lifetime. Each new instance of the component
					gets its own instance of the service. When the component instance is destroyed,
					so is that service instance. <br><br>

					This is generally no different from configuring the injector of the NgModule itself,
					except that the service is tree-shakable if the NgModule doesn't use it.
					It can be useful for a library that offers a particular service that some components
					might want to inject optionally, and leave it up to the app whether to provide the service.

				</p>
			</div>
			<div class="third_column table_column">
				<p>

					@Injectable({ providedIn: 'root', }) <br>
					@Injectable({ providedIn: HeroModule, }) <br> <br>

					@NgModule({  <br>
					providers: [HeroService], <br>
					}) <br> <br>

					@Component({ <br>
					providers: [HeroService], <br>
					})
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Expanded Providers Object</p>
			</div>
			<div class="second_column table_column">
				<p>
					If you specify the service class itself as the provider token,
					the default behavior is for the injector to instantiate that class with new. <br><br>

					The class-provider syntax is a shorthand expression that expands into a provider configuration,
					defined by the Provider interface. Class that is given as the providers value is expanded into
					a full provider object.
					The expanded provider configuration is an object literal with two properties: <br>
					- The provide property holds the token that serves as the key for
					both locating a dependency value and configuring the injector. <br>
					- The second property is a provider definition object,
					which tells the injector how to create the dependency value.
					The provider-definition key can be useClass, as in the example.
					It can also be useExisting, useValue, or useFactory.
					Each of these keys provides a different type of dependency, as discussed below.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					providers: [Logger] <br>
					[{ provide: Logger, useClass: Logger }]
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>useClass</p>
			</div>
			<div class="second_column table_column">
				<p>
					The useClass provider key lets you create and return a new instance of the specified class. <br>
					You can use this type of provider to substitute an alternative implementation
					for a common or default class. The alternative implementation could, for example,
					implement a different strategy, extend the default class,
					or emulate the behavior of the real class in a test case.
				</p>
			</div>
			<div class="third_column table_column">
				<p>[{ provide: Logger, useClass: BetterLogger }]</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>useExisting</p>
			</div>
			<div class="second_column table_column">
				<p>
					The useExisting provider key lets you map one token to another. <br>
					In effect, the first token is an alias for the service associated with the second token,
					creating two ways to access the same service object. <br><br>

					The Angular forwardRef() function creates an indirect reference that Angular can resolve later.
					You face this dilemma when a class makes a reference to itself  in its providers array.
					The providers array is a property of the @Component() decorator function which
					must appear above the class definition.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					[ NewLogger, { provide: OldLogger, useExisting: NewLogger}] <br>
					// Alias OldLogger with reference to NewLogger<br><br>

					{ provide: MinimalLogger, useExisting: LoggerService }, <br><br>

					providers: [{ provide: Parent, useExisting: forwardRef(() => AlexComponent) }],

				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>useValue</p>
			</div>
			<div class="second_column table_column">
				<p>
					To inject an object you have already created, configure the injector with the useValue option. <br>
					<br>

					The useValue key lets you associate a fixed value with a DI token. <br><br>
					Use this technique to provide runtime configuration constants
					such as website base addresses and feature flags. You can also use a value provider
					in a unit test to provide mock data in place of a production data service.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					[{ provide: Logger, useValue: silentLogger }] <br> <br>

					// An object in the shape of the logger service<br>
					export function SilentLoggerFn() {<br>
					} const silentLogger = {<br>
					logs: ['Silent logger says "Shhhhh!". Provided via "useValue"'],<br>
					log: SilentLoggerFn<br>
					};<br><br>

					{ provide: Hero, useValue: someHeroObject }<br>
					{ provide: TITLE, useValue: 'Hero of the Month' } <br>
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>useFactory</p>
			</div>
			<div class="second_column table_column">
				<p>
					Sometimes you need to create a dependent value dynamically,
					based on information you won't have until run time.
					In cases like this you can use a factory provider.
					Factory providers can also be useful when creating an instance of a dependency
					from a third-party library that wasn't designed to work with DI. <br> <br>

					A factory provider needs a factory function. <br> <br>

					- The useFactory field tells Angular that the provider is a factory function
					whose implementation is heroServiceFactory. <br>
					- The deps property is an array of provider tokens. <br>
					The Logger and UserService classes serve as tokens for their own class providers.
					The injector resolves these tokens and injects the corresponding services
					into the matching factory function parameters.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					export let heroServiceProvider = { <br>
					provide: HeroService,<br>
					useFactory: heroServiceFactory,<br>
					deps: [Logger, UserService] <br>
					};<br><br>

					providers: [ heroServiceProvider ],<br><br>

					let heroServiceFactory = (logger: Logger, userService: UserService) =&gt; {<br>
					return new HeroService(logger, userService.user.isAuthorized);<br>
					};<br><br>

					constructor( private logger: Logger, private isAuthorized: boolean) { }<br><br>

					getHeroes() {<br>
					let auth = this.isAuthorized ? 'authorized ' : 'unauthorized';<br>
					this.logger.log(`Getting heroes for ${auth} user.`);<br>
					return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);<br>
					}
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>forwardRef()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Write an alias provider — a provide object literal with a useExisting definition,
					that creates an alternative way to inject the same component instance and
					add that provider to the providers array of the @Component() metadata for the someComponent. <br>

					Parent is the provider's class interface token. The forwardRef breaks the circular reference
					you just created by having the someComponent refer to itself.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					someComponent: <br>

					providers: [{ provide: Parent, useExisting: forwardRef(() => someComponent) }], <br> <br>

					constructor( @Optional() public parent: Parent ) { }
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Optional()</p>
			</div>
			<div class="second_column table_column">
				<p>
					The dependency is optional by annotating the constructor parameter with @Optional(). <br>

					When using @Optional(), your code must be prepared for a null value.
					If you don't register a logger provider anywhere, the injector sets the value of logger to null.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Optional } from '@angular/core'; <br><br>

					constructor(@Optional() private logger: Logger) {<br>
					if (this.logger) {<br>
					this.logger.log(some_message);<br>
					} }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Host()</p>
			</div>
			<div class="second_column table_column">
				<p>
					The @Host property decorator stops the upward search at the host component. <br>
					The host component is typically the component requesting the dependency.
					However, when this component is projected into a parentcomponent,
					that parent component becomes the host.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					constructor( <br>
					@Host() // limit to the host component's instance of the HeroCacheService<br>
					private heroCache: HeroCacheService,<br>
					)
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@Inject()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Not all dependencies are classes. Sometimes you want to inject a string, function, or object.
					Solution to choosing a provider token for non-class dependencies is to define
					and use an InjectionToken object, register the dependency provider using the InjectionToken object:
					you can inject the configuration object into any constructor that needs it,
					with the help of an @Inject()parameter decorator.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					import { InjectionToken } from '@angular/core'; <br>
					export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;('app.config');<br><br>


					providers: [{ provide: APP_CONFIG, useValue: HERO_DI_CONFIG }]<br><br>


					constructor(@Inject(APP_CONFIG) config: AppConfig) { this.title = config.title; }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>@Self()</p>
			</div>
			<div class="second_column table_column">
				<p>
					Using the @Self decorator,
					the injector only looks at the component's injector for its providers.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					constructor( <br>
					@Self() private sessionStorageService: BrowserStorageService <br>
					) {}
				</p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>@SkipSelf()</p>
			</div>
			<div class="second_column table_column">
				<p>
					The @SkipSelf decorator allows you to skip the local injector and look up in the hierarchy
					to find a provider that satisfies this dependency. <br>

					@SkipSelf tells the injector to start its search for a Parent dependency in a component above itself,
					which is what parent means. <br>

					You can extract that logic into a helper function.

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					constructor( <br>
					@SkipSelf() private localStorageService: BrowserStorageService <br>
					) { } <br> <br>

					providers: [{ provide: Parent, useExisting: forwardRef(() => someComponent) }] <br>

					constructor( @SkipSelf() @Optional() public parent: Parent ) { } <br>
					// Component needs to inject and provide Parent in the same time <br><br>

					providers: [ provideParent(someComponent, DifferentParent) ] <br>

					const provideParent = (component: any, parentType?: any) => { <br>
					return {<br>
					provide: parentType || Parent,<br>
					useExisting: forwardRef(() => component) };<br>
					};
				</p>
			</div>
		</div>


		<!-- -------------------------------------------------Observables------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="observables">
			<h1>Observables</h1>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Theory</p>
			</div>
			<div class="second_column table_column">
				<p>
					As a publisher, you create an Observable instance that defines a subscriber function.
					The subscriber function defines how to obtain or generate values or messages to be published.
					To execute the observable you have created and begin receiving notifications,
					you call its subscribe() method, passing an observer. <br><br>

					subscribe() – execute subscriber function. <br><br>

					An Observable instance begins publishing values only when someone subscribes to it.
					You subscribe by calling the subscribe() method of the instance,
					passing an observer object to receive the notifications. <br><br>

					The subscribe() call returns a Subscription object that has an unsubscribe() method,
					which you call to stop receiving notifications. <br><br>

					A handler for receiving observable notifications implements the Observer interface.
					It is an object that defines callback methods
					to handle the three types of notifications that an observable can send: <br><br>

					next - Required. A handler for each delivered value.
					Called zero or more times after execution starts.  <br><br>

					error - Optional. A handler for an error notification.
					An error halts execution of the observable instance. <br><br>

					complete - Optional. A handler for the execution-complete notification.
					Delayed values can continue to be delivered to the next handler after execution is complete. <br><br>

					An observer object can define any combination of these handlers.
					If you don't supply a handler for a notification type,
					the observer ignores notifications of that type. <br><br>

					Use the Observable constructor to create an observable stream of any type.
					The constructor takes as its argument the subscriber function
					to run when the observable’s subscribe() method executes. A subscriber function receives
					an Observer object, and can publish values to the observer's next() method.
					new Observable; <br><br>

					Any type of value can be represented with an observable, and the values are published as a stream.
					Observable&lt;number&gt;<br><br>

					Multicasting is the practice of broadcasting to a list of multiple subscribers in a single execution.
					With a multicasting observable, you don't register multiple listeners on the document,
					but instead re-use the first listener and send values out to each subscriber.
					When creating an observable you should determine how you want that observable to be used
					and whether or not you want to multicast its values. <br><br>

					“$” - Naming conventions, in the end of teh variable, for observables.
					stopwatchValue$  <br><br>

				</p>
			</div>
			<div class="third_column table_column">
				<p>
					// Create simple observable that emits three values <br>
					const myObservable = of(1, 2, 3);<br><br>

					// Create observer object<br>
					const myObserver = {<br>
					next: x => console.log('Observer got a next value: ' + x),<br>
					error: err => console.error('Observer got an error: ' + err),<br>
					complete: () => console.log('Observer got a complete notification'),<br>
					};<br><br>

					// Execute with the observer object<br>
					myObservable.subscribe(myObserver);<br><br>

					Or <br><br>

					myObservable.subscribe(<br>
					x => console.log('Observer got a next value: ' + x),<br>
					err => console.error('Observer got an error: ' + err),<br>
					() => console.log('Observer got a complete notification')<br>
					); <br> <br> <br>

					// This function runs when subscribe() is called<br>
					// synchronously deliver 1, 2, and 3, then complete <br>
					function sequenceSubscriber(observer) {<br>
					observer.next(1);<br>
					observer.next(2);<br>
					observer.next(3);<br>
					observer.complete();<br><br>

					// unsubscribe function doesn't need to do anything in this<br>
					// because values are delivered synchronously<br>
					return {unsubscribe() {}};<br>
					}<br><br>

					// Create a new Observable that will deliver the above sequence<br>
					const sequence = new Observable(sequenceSubscriber);<br><br>

					// execute the Observable and print the result of each notification<br>
					sequence.subscribe({<br>
					next(num) { console.log(num); },<br>
					complete() { console.log('Finished sequence'); }<br>
					});
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>
                    EventEmitter
                </p>
			</div>
			<div class="second_column table_column">
				<p>
                    Angular provides an EventEmitter class that is used when publishing values from a component
                    through the @Output() decorator. EventEmitter extends Observable,
                    adding an emit() method so it can send arbitrary values.
                    When you call emit(), it passes the emitted value to the next() method of any subscribed observer.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    &lt;zippy (open)="onOpen($event)" (close)="onClose($event)"&gt;&lt;/zippy&gt; <br><br>

                    @Component({ <br>
                    selector: 'zippy', <br>
                    template: `<br>
                    &lt;div class="zippy"&gt;<br>
                    &lt;div (click)="toggle()"&gt;Toggle&lt;/div&gt;<br>
                    &lt;div [hidden]="!visible"&gt;<br>
                    &lt;ng-content&gt;&lt;/ng-content&gt;<br>
                    &lt;/div&gt;<br>
                    &lt;/div&gt;`})<br><br>

                    export class ZippyComponent {<br>
                    visible = true;<br>
                    @Output() open = new EventEmitter&lt;any&gt;();<br>
                    @Output() close = new EventEmitter&lt;any&gt;();<br><br>

                    toggle() {<br>
                    this.visible = !this.visible;<br>
                    if (this.visible) {<br>
                    this.open.emit(null);<br>
                    } else {<br>
                    this.close.emit(null);<br>
                    } } }
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>HTTP </p>
			</div>
			<div class="second_column table_column">
				<p>
                    Angular’s HttpClient returns observables from HTTP method calls.
                    For instance, http.get(‘/api’) returns an observable.
                    This provides several advantages over promise-based HTTP APIs: <br>
                    - Observables do not mutate the server response
                    (as can occur through chained .then() calls on promises).
                    Instead, you can use a series of operators to transform values as needed. <br>
                    - HTTP requests are cancellable through the unsubscribe() method.<br>
                    - Requests can be configured to get progress event updates.<br>
                    - Failed requests can be retried easily.
                </p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>AsyncPipe</p>
			</div>
			<div class="second_column table_column">
				<p>
                    The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted.
                    When a new value is emitted, the pipe marks the component to be checked for changes.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    @Component({ <br>
                    selector: 'async-observable-pipe', <br>
                    template: ` <br>
                    &lt;div&gt;<br>
                    &lt;code&gt;observable|async&lt;/code&gt;: Time: {{ time | async }}<br>
                    &lt;/div&gt;<br>
                    ` })<br><br>

                    export class AsyncObservablePipeComponent {<br>
                    time = new Observable(<br>
                    observer =&gt; setInterval(() =&gt;<br>
                    observer.next(new Date().toString()), 1000)<br>
                    ); }<br><br>

                    The following example binds the time observable to the component's view.
                    The observable continuously updates the view with the current time.
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Router</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Router.events provides events as observables.
                    You can use the filter() operator from RxJS to look for events of interest,
                    and subscribe to them in order to make decisions based on the sequence of events
                    in the navigation process. <br><br>

                    The ActivatedRoute is an injected router service that makes use of observables to get information
                    about a route path and parameters. For example,
                    ActivateRoute.url contains an observable that reports the route path or paths.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    import { Router, NavigationStart } from '@angular/router';<br>
                    import { filter } from 'rxjs/operators';<br><br>

                    @Component({<br>
                    selector: 'app-routable',<br>
                    templateUrl: './routable.component.html',<br>
                    styleUrls: ['./routable.component.css']<br>
                    })<br><br>

                    export class Routable1Component implements OnInit {<br><br>

                    navStart: Observable&lt;NavigationStart&gt;;<br><br>

                    constructor(private router: Router) {<br>
                    // Create a new Observable the publishes only the NavigationStart event <br>
                    this.navStart = router.events.pipe( <br>
                    filter(evt =&gt; evt instanceof NavigationStart)<br>
                    ) as Observable&lt;NavigationStart&gt;;<br>
                    }<br><br>

                    ngOnInit() {<br>
                    this.navStart.subscribe(evt =&gt; console.log('Navigation Started!'));<br>
                    } }<br><br><br>

                    import { ActivatedRoute } from '@angular/router';<br><br>

                    @Component({<br>
                    selector: 'app-routable',<br>
                    templateUrl: './routable.component.html',<br>
                    styleUrls: ['./routable.component.css']<br>
                    })<br><br>

                    export class Routable2Component implements OnInit { <br>
                    constructor(private activatedRoute: ActivatedRoute) {}<br>

                    ngOnInit() {<br>
                    this.activatedRoute.url<br>
                    .subscribe(url =&gt; console.log('The URL changed to: ' + url));<br>
                    } }
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Reactive Forms</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Reactive forms have properties that use observables to monitor form control values.
                    The FormControl properties valueChanges and statusChanges contain observables that raise change events.
                    Subscribing to an observable form-control property
                    is a way of triggering application logic within the component class.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    import { FormGroup } from '@angular/forms';<br><br>

                    @Component({<br>
                    selector: 'my-component',<br>
                    template: 'MyComponent Template'<br>
                    })<br><br>

                    export class MyComponent implements OnInit {<br><br>
                    nameChangeLog: string[] = [];<br>
                    heroForm: FormGroup;<br><br>

                    ngOnInit() {<br>
                    this.logNameChange();<br>
                    }<br>
                    logNameChange() {<br>
                    const nameControl = this.heroForm.get('name');<br>
                    nameControl.valueChanges.forEach(<br>
                    (value: string) =&gt; this.nameChangeLog.push(value) <br>
                    ); }	}
                </p>
			</div>
		</div>

				<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Subject</p>
			</div>
			<div class="second_column table_column">
				<p>
					A special type of Observable which shares a single execution path among observers
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: simple Subject <br> <br>

					import { Subject } from 'rxjs'; <br><br>

					const sub = new Subject();<br><br>

					sub.next(1);<br>
					sub.subscribe(console.log);<br>
					sub.next(2); // OUTPUT => 2<br>
					sub.subscribe(console.log);<br>
					sub.next(3); // OUTPUT => 3,3 (logged from both subscribers)<br>

                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>BehaviorSubject</p>
			</div>
			<div class="second_column table_column">
				<p>
					A Subject that requires an initial value and emits its current value to new subscribers
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: simple BehaviorSubject <br> <br>

					import { BehaviorSubject } from 'rxjs'; <br><br>

					const subject = new BehaviorSubject(123);<br><br>

					//two new subscribers will get initial value => output: 123, 123<br>
					subject.subscribe(console.log);<br>
					subject.subscribe(console.log);<br><br>

					//two subscribers will get new value => output: 456, 456<br>
					subject.next(456);<br><br>

					//new subscriber will get latest value (456) => output: 456<br>
					subject.subscribe(console.log);<br><br>

					//all three subscribers will get new value => output: 789, 789, 789<br>
					subject.next(789);<br><br>

					// output: 123, 123, 456, 456, 456, 789, 789, 789

                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>ReplaySubject</p>
			</div>
			<div class="second_column table_column">
				<p>
					A Subject that "replays" or emits old values to new subscribers.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: simple ReplaySubject <br> <br>

					import { ReplaySubject } from 'rxjs'; <br><br>

					const sub = new ReplaySubject(3); <br><br>

					sub.next(1); <br>
					sub.next(2); <br>
					sub.subscribe(console.log); // OUTPUT => 1,2 <br>
					sub.next(3); // OUTPUT => 3<br>
					sub.next(4); // OUTPUT => 4<br>
					sub.subscribe(console.log); // OUTPUT => 2,3,4 (log of last 3 values from new subscriber)<br>
					sub.next(5); // OUTPUT => 5,5 (log from both subscribers)
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>AsyncSubject</p>
			</div>
			<div class="second_column table_column">
				<p>
					A Subject that only emits its last value upon completion
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: simple AsyncSubject
					 <br><br>

					 import { AsyncSubject } from 'rxjs'; <br><br>

					const sub = new AsyncSubject();<br><br>

					sub.subscribe(console.log);<br><br>

					sub.next(123); //nothing logged<br><br>

					sub.subscribe(console.log);<br><br>

					sub.next(456); //nothing logged<br><br>
					sub.complete(); //456, 456 logged by both subscribers
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>AsObservable</p>
			</div>
			<div class="second_column table_column">
				<p>
					When you don't want to leak the "observer-side" of a Subject out of your API.
					 (Basically to prevent leaky abstraction).
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: <br><br>

					var myAPI = { <br>
						  getData: () => { <br>
						    var subject = new Subject(); <br>
						    var source = new SomeWeirdDataSource(); <br>
						    source.onMessage = (data) => subject.next({ type: 'message', data }); <br>
						    source.onOtherMessage = (data) => subject.next({ type: 'othermessage', data }); <br>
						    return subject.asObservable(); <br>
						  } <br>
						}; <br><br>

						Now when someone gets the observable result from myAPI.getData() they can't next values in to the result: <br> <br>
 
						var result = myAPI.getData(); <br>
						result.next('LOL hax!'); // throws an error because `next` doesn't exist

					Example 2: My example<br><br>
						
					Service: <br>
					  subject = new Subject(); <br><br>

						getSubject() {<br>
					    return this.subject.asObservable();<br>
					  }<br><br>

					  setSubject(value) {<br>
					    return this.subject.next(value);<br>
					  }<br><br>
                </p>
			</div>
		</div>
        <!-- -------------------------------------------------RxJS------------------------------------------------------ -->

        <div class="anchor_row zebra3" id="rxjs">
            <h1>RxJS</h1>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>RxJS</p>
            </div>
            <div class="second_column table_column">
                <p>
                    RxJS is a library for composing asynchronous and callback-based code in a functional, reactive style.
                    <br> <br>
                    RxJS provides an implementation of the Observable type,
                    which is needed until the type becomes part of the language and until browsers support it.
                    The library also provides utility functions for creating and working with observables.
                    <br><br>
                    RxJS Operators - are functions that build on the observables foundation
                    to enable sophisticated manipulation of collections. <br>
                    1. Creation:<br>
                    - from<br>
                    - fromPromise<br>
                    - fromEvent<br>
                    - of<br>
                    2. Combination:<br>
                    - combineLatest<br>
                    - concat<br>
                    - merge<br>
                    - startWith<br>
                    - withLatestFrom<br>
                    - zip<br>
                    3. Filtering:<br>
                    - debounceTime<br>
                    - distinctUntilChanged<br>
                    - filter<br>
                    - take<br>
                    - takeUntil<br>
                    4. Transformation:<br>
                    - bufferTime<br>
                    - concatMap<br>
                    - map<br>
                    - mergeMap<br>
                    - scan<br>
                    - switchMap<br>
                    5. Utility:<br>
                    - tap<br>
                    6. Multicasting:<br>
                    - share<br><br>

                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    import { map } from 'rxjs/operators';<br><br>

                    const nums = of(1, 2, 3);<br><br>

                    const squareValues = map((val: number) => val * val); <br>
                    const squaredNums = squareValues(nums);<br><br>

                    squaredNums.subscribe(x => console.log(x));
                </p>
            </div>
        </div>


        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>.pipe()</p>
            </div>
            <div class="second_column table_column">
                <p>
                    You can use pipes to link operators together.
                    Pipes let you combine multiple functions into a single function.
                    The pipe() function takes as its arguments the functions you want to combine,
                    and returns a new function that, when executed, runs the composed functions in sequence.
                    A set of operators applied to an observable is a recipe—that is,
                    a set of instructions for producing the values you’re interested in.
                    By itself, the recipe doesn’t do anything. You need to call subscribe()
                    to produce a result through the recipe. <br><br>

                    The pipe() function is also a method on the RxJS Observable,
                    so you use this shorter form to define the same operation:
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    import { filter, map } from 'rxjs/operators'; <br><br>

                    SHORTER VERSION:<br><br>

                    import { filter, map } from 'rxjs/operators';<br><br>

                    const squareOdd = of(1, 2, 3, 4, 5).pipe(<br>
                    filter(n => n % 2 !== 0),<br>
                    map(n => n * n) ); // Subscribe to get values<br>
                    squareOdd.subscribe(x => console.log(x));<br><br>

                    LONGER VERSION:<br><br>

                    const nums = of(1, 2, 3, 4, 5);<br>
                    const squareOddVals = pipe(<br>
                    filter((n: number) => n % 2 !== 0),<br>
                    map(n => n * n)<br>
                    );<br>
                    const squareOdd = squareOddVals(nums);
                </p>
            </div>
        </div>

                <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>Of</p>
            </div>
            <div class="second_column table_column">
                <p>
					Emit variable amount of values in a sequence and then emits a complete notification.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Emitting a sequence of numbers <br> <br>

					import { of } from 'rxjs'; <br><br>

					//emits any number of provided values in sequence <br>
					const source = of(1, 2, 3, 4, 5);<br><br>

					//output: 1,2,3,4,5<br>
					const subscribe = source.subscribe(val => console.log(val));<br><br><br>

					Example 2: Emitting an object, array, and function <br> <br>

					import { of } from 'rxjs';<br><br>

					//emits values of any type<br>
					const source = of({ name: 'Brian' }, [1, 2, 3], function hello() {<br>
					  return 'Hello';<br>
					});<br><br>
					<br>
					//output: {name: 'Brian}, [1,2,3], function hello() { return 'Hello' }<br>
					const subscribe = source.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>from</p>
            </div>
            <div class="second_column table_column">
                <p>
					Turn an array, promise, or iterable into an observable.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Observable from array <br> <br>
						
					import { from } from 'rxjs'; <br> <br>

					//emit array as a sequence of values<br>
					const arraySource = from([1, 2, 3, 4, 5]);<br><br>

					//output: 1,2,3,4,5<br>
					const subscribe = arraySource.subscribe(val => console.log(val));<br><br><br>

					Example 2: Observable from collection <br><br>

					import { from } from 'rxjs';<br><br>

					//works on js collections<br>
					const map = new Map();<br>
					map.set(1, 'Hi');<br>
					map.set(2, 'Bye');<br><br>

					const mapSource = from(map);<br>
					//output: [1, 'Hi'], [2, 'Bye']<br>
					const subscribe = mapSource.subscribe(val => console.log(val));<br><br><br>

					Example 3: Observable from string <br><br>

					import { from } from 'rxjs'; <br>

					//emit string as a sequence <br>
					const source = from('Hello World');<br><br>

					//output: 'H','e','l','l','o',' ','W','o','r','l','d'<br>
					const subscribe = source.subscribe(val => console.log(val));<br><br><br>

					Example 2: Observable from promise <br> <br>

					import { from } from 'rxjs'; <br><br>

					//emit result of promise<br>
					const promiseSource = from(new Promise(resolve => resolve('Hello World!')));<br><br>

					//output: 'Hello World'<br>
					const subscribe = promiseSource.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

		
         <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>fromEvent</p>
            </div>
            <div class="second_column table_column">
                <p>
					Turn event into observable sequence.
                </p>
            </div>
            <div class="third_column table_column">
                <p>	
					Example 1: Observable from mouse clicks <br> <br>
 
					import { fromEvent } from 'rxjs'; <br>
					import { map } from 'rxjs/operators'; <br> <br>

					//create observable that emits click events <br>
					const source = fromEvent(document, 'click');<br><br>

					//map to string with given event timestamp<br>
					const example = source.pipe(map(event => `Event time: ${event.timeStamp}`));<br><br>

					//output (example): 'Event time: 7276.390000000001'<br>
					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

         <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>interval</p>
            </div>
            <div class="second_column table_column">
                <p>
					Emit numbers in sequence based on provided timeframe.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Emit sequence of values at 1 second interval <br> <br>

					import { interval } from 'rxjs'; <br><br>

					//emit value in sequence every 1 second<br>
					const source = interval(1000);<br><br>

					//output: 0,1,2,3,4,5....<br>
					const subscribe = source.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

         <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>timer</p>
            </div>
            <div class="second_column table_column">
                <p>
					After given duration, emit numbers in sequence every specified duration.
                </p>
            </div>
            <div class="third_column table_column">
                <p>	
					Example 1: timer emits 1 value then completes <br> <br>

					import { timer } from 'rxjs'; <br> <br>

					//emit 0 after 1 second then complete, since no second argument is supplied <br>
					const source = timer(1000); <br> <br>

					//output: 0 <br>
					const subscribe = source.subscribe(val => console.log(val));<br><br><br>

					Example 2: timer emits after 1 second, then every 2 seconds <br> <br>

					import { timer } from 'rxjs'; <br><br>

					/*<br>
					  timer takes a second argument, how often to emit subsequent values<br>
					  in this case we will emit first value after 1 second and subsequent<br>
					  values every 2 seconds after<br>
					*/<br><br>

					const source = timer(1000, 2000);<br>
					//output: 0,1,2,3,4,5......<br>
					const subscribe = source.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

         <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>tap</p>
            </div>
            <div class="second_column table_column">
                <p>
					Transparently perform actions or side-effects, such as logging.
                </p>
            </div>
            <div class="third_column table_column">
                <p>	
					
					import { of } from 'rxjs'; <br>
					import { tap, map } from 'rxjs/operators';<br><br>

					const source = of(1, 2, 3, 4, 5);<br>
					const example = source.pipe(<br>
					  tap(val => console.log(`BEFORE MAP: ${val}`)),<br>
					  map(val => val + 10),<br>
					  tap(val => console.log(`AFTER MAP: ${val}`))<br>
					);<br><br>

					//'tap' does not transform values<br>
					//output: 11...12...13...14...15<br>
					const subscribe = example.subscribe(val => console.log(val));

                </p>
            </div>
        </div>


        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>mapTo</p>
            </div>
            <div class="second_column table_column">
                <p>
					Map emissions to constant value.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Map every emission to string <br> <br>

					import { interval } from 'rxjs'; <br>
					import { mapTo } from 'rxjs/operators'; <br> <br>

					//emit value every two seconds<br>
					const source = interval(2000);<br><br>

					//map all emissions to one value <br>
					const example = source.pipe(mapTo('HELLO WORLD!')); <br><br>

					//output: 'HELLO WORLD!'...'HELLO WORLD!'...'HELLO WORLD!'...<br>
					const subscribe = example.subscribe(val => console.log(val)); <br><br><br>

					Example 2: Mapping clicks to string <br> <br>

					import { fromEvent } from 'rxjs'; <br>
					import { mapTo } from 'rxjs/operators'; <br><br>

					//emit every click on document <br>
					const source = fromEvent(document, 'click'); <br><br>

					//map all emissions to one value<br>
					const example = source.pipe(mapTo('GOODBYE WORLD!')); <br><br>

					//output: (click)'GOODBYE WORLD!'... <br>
					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>filter</p>
            </div>
            <div class="second_column table_column">
                <p>
					Emit values that pass the provided condition.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: filter for even numbers <br> <br>

					import { from } from 'rxjs'; <br>
					import { filter } from 'rxjs/operators'; <br> <br>

					//emit (1,2,3,4,5) <br>
					const source = from([1, 2, 3, 4, 5]); <br><br>

					//filter out non-even numbers <br>
					const example = source.pipe(filter(num => num % 2 === 0)); <br><br>

					//output: "Even number: 2", "Even number: 4" <br>
					const subscribe = example.subscribe(val => console.log(`Even number: ${val}`)); <br><br><br>

					Example 2: filter objects based on property <br> <br>

					import { from } from 'rxjs'; <br>
					import { filter } from 'rxjs/operators'; <br><br>

					//emit ({name: 'Joe', age: 31}, {name: 'Bob', age:25}) <br>
					const source = from([{ name: 'Joe', age: 31 }, { name: 'Bob', age: 25 }]); <br><br>

					//filter out people with age under 30<br>
					const example = source.pipe(filter(person => person.age >= 30));<br><br>

					//output: "Over 30: Joe"<br>
					const subscribe = example.subscribe(val => console.log(`Over 30: ${val.name}`));<br><br><br>

					Example 3: filter for number greater than specified value <br><br>

					import { interval } from 'rxjs'; <br>
					import { filter } from 'rxjs/operators';<br><br>

					//emit every second<br>
					const source = interval(1000);<br><br>

					//filter out all values until interval is greater than 5<br>
					const example = source.pipe(filter(num => num > 5));<br><br>
					/*<br>
					  "Number greater than 5: 6"<br>
					  "Number greater than 5: 7"<br>
					  "Number greater than 5: 8"<br>
					  "Number greater than 5: 9"<br>
					*/<br><br>
					const subscribe = example.subscribe(val =><br>
					  console.log(`Number greater than 5: ${val}`)<br>
					);
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>pluck</p>
            </div>
            <div class="second_column table_column">
                <p>
					Select properties to emit.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Pluck object property <br> <br>

					import { from } from 'rxjs'; <br>
					import { pluck } from 'rxjs/operators'; <br> <br>

					const source = from([{ name: 'Joe', age: 30 }, { name: 'Sarah', age: 35 }]); <br>

					//grab names<br>
					const example = source.pipe(pluck('name'));<br><br>

					//output: "Joe", "Sarah"<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 2: Pluck nested properties <br><br>

					import { from } from 'rxjs'; <br>
					import { pluck } from 'rxjs/operators'; <br><br>

					const source = from([<br>
					  { name: 'Joe', age: 30, job: { title: 'Developer', language: 'JavaScript' } },<br>
					  //will return undefined when no job is found <br>
					  { name: 'Sarah', age: 35 }<br>
					]);<br><br>

					//grab title property under job<br>
					const example = source.pipe(pluck('job', 'title'));<br><br>

					//output: "Developer" , undefined<br>
					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>map</p>
            </div>
            <div class="second_column table_column">
                <p>
					Apply projection with each value from source.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Add 10 to each number <br> <br>

					import { from } from 'rxjs'; <br>
					import { map } from 'rxjs/operators';<br><br>

					//emit (1,2,3,4,5)<br>
					const source = from([1, 2, 3, 4, 5]);<br><br>

					//add 10 to each value<br>
					const example = source.pipe(map(val => val + 10));<br><br>

					//output: 11,12,13,14,15<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 2: Map to single property <br> <br>

					import { from } from 'rxjs'; <br>
					import { map } from 'rxjs/operators'; <br><br>

					//emit ({name: 'Joe', age: 30}, {name: 'Frank', age: 20},{name: 'Ryan', age: 50})<br>
					const source = from([<br>
					  { name: 'Joe', age: 30 },<br>
					  { name: 'Frank', age: 20 },<br>
					  { name: 'Ryan', age: 50 }<br>
					]);<br><br>

					//grab each persons name, could also use pluck for this scenario <br>
					const example = source.pipe(map(({ name }) => name));<br><br>

					//output: "Joe","Frank","Ryan"<br>
					const subscribe = example.subscribe(val => console.log(val)); <br> <br> <br>

					map( [idString, person]: [string, Person] ): {id: string; name: string} { <br>
						return {...person, id: idString }
				}
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>merge</p>
            </div>
            <div class="second_column table_column">
                <p>
					Turn multiple observables into a single observable.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: merging multiple observables, static method <br> <br>

					import { mapTo } from 'rxjs/operators'; <br>
					import { interval, merge } from 'rxjs';<br><br>

					//emit every 2.5 seconds<br>
					const first = interval(2500);<br>
					//emit every 2 seconds<br>
					const second = interval(2000);<br>
					//emit every 1.5 seconds<br>
					const third = interval(1500);<br>
					//emit every 1 second<br>
					const fourth = interval(1000);<br><br>

					//emit outputs from one observable<br>
					const example = merge(<br>
					  first.pipe(mapTo('FIRST!')),<br>
					  second.pipe(mapTo('SECOND!')),<br>
					  third.pipe(mapTo('THIRD')),<br>
					  fourth.pipe(mapTo('FOURTH'))<br>
					);<br><br>

					//output: "FOURTH", "THIRD", "SECOND!", "FOURTH", "FIRST!", "THIRD", "FOURTH" <br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 2: merge 2 observables, instance method <br> <br>

					import { merge } from 'rxjs/operators'; <br>
					import { interval } from 'rxjs'; <br> <br>

					//emit every 2.5 seconds<br>
					const first = interval(2500);<br>
					//emit every 1 second<br>
					const second = interval(1000);<br><br>

					//used as instance method<br>
					const example = first.pipe(merge(second));<br><br>

					//output: 0,1,0,2....<br>
					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>concat</p>
            </div>
            <div class="second_column table_column">
                <p>
					Subscribe to observables in order as previous completes, emit values.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: concat 2 basic observables <br> <br>

					import { concat } from 'rxjs/operators'; <br>
					import { of } from 'rxjs';<br><br>

					//emits 1,2,3<br>
					const sourceOne = of(1, 2, 3);<br>
					//emits 4,5,6<br>
					const sourceTwo = of(4, 5, 6);<br><br>

					//emit values from sourceOne, when complete, subscribe to sourceTwo<br>
					const example = sourceOne.pipe(concat(sourceTwo));<br><br>

					//output: 1,2,3,4,5,6<br>
					const subscribe = example.subscribe(val =><br>
					  console.log('Example: Basic concat:', val)<br>
					);<br><br><br>

					Example 2: concat as static method <br> <br>

					import { of, concat } from 'rxjs'; <br> <br>

					//emits 1,2,3<br>
					const sourceOne = of(1, 2, 3);<br>
					//emits 4,5,6<br>
					const sourceTwo = of(4, 5, 6);<br><br>

					//used as static<br>
					const example = concat(sourceOne, sourceTwo);<br><br>

					//output: 1,2,3,4,5,6<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 3: concat with delayed source <br> <br>

					import { delay, concat } from 'rxjs/operators';<br>
					import { of } from 'rxjs';<br><br>

					//emits 1,2,3<br>
					const sourceOne = of(1, 2, 3);<br>
					//emits 4,5,6<br>
					const sourceTwo = of(4, 5, 6);<br><br>

					//delay 3 seconds then emit<br>
					const sourceThree = sourceOne.pipe(delay(3000));<br><br>

					//sourceTwo waits on sourceOne to complete before subscribing<br>
					const example = sourceThree.pipe(concat(sourceTwo));<br><br>

					//output: 1,2,3,4,5,6<br>
					const subscribe = example.subscribe(val =><br>
					  console.log('Example: Delayed source one:', val)<br>
					);<br><br><br>

					Example 4: concat with source that does not complete<br><br>

					import { interval, of, concat } from 'rxjs';<br><br>

					//when source never completes, the subsequent observables never runs<br>
					const source = concat(interval(1000), of('This', 'Never', 'Runs'));<br><br>

					//outputs: 0,1,2,3,4....<br>
					const subscribe = source.subscribe(val =><br>
					  console.log(<br>
					    'Example: Source never completes, second observable never runs:',<br>
					    val<br>
					  )<br>
					);
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>combineLatest</p>
            </div>
            <div class="second_column table_column">
                <p>
					When any observable emits a value, emit the latest value from each.
                </p>
            </div>
            <div class="third_column table_column">
                <p>	
					Example 1: <br> <br>


                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>withLatestFrom</p>
            </div>
            <div class="second_column table_column">
                <p>
					Also provide the last value from another observable.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Latest value from quicker second source <br> <br>

					import { withLatestFrom, map } from 'rxjs/operators'; <br>
					import { interval } from 'rxjs';<br><br>

					//emit every 5s<br>
					const source = interval(5000);<br>
					//emit every 1s<br>
					const secondSource = interval(1000);<br><br>

					const example = source.pipe(<br>
					  withLatestFrom(secondSource),<br>
					  map(([first, second]) => {<br>
					    return `First Source (5s): ${first} Second Source (1s): ${second}`;<br>
					  })<br>
					);<br><br>

					/*<br>
					  "First Source (5s): 0 Second Source (1s): 4"<br>
					  "First Source (5s): 1 Second Source (1s): 9"<br>
					  "First Source (5s): 2 Second Source (1s): 14"<br>
					  ...<br>
					*/<br><br>

					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 2: Slower second source <br> <br>

					import { withLatestFrom, map } from 'rxjs/operators'; <br>
					import { interval } from 'rxjs';<br><br>

					//emit every 5s<br>
					const source = interval(5000);<br>
					//emit every 1s<br>
					const secondSource = interval(1000);<br><br>

					//withLatestFrom slower than source <br>
					const example = secondSource.pipe(<br>
					  //both sources must emit at least 1 value (5s) before emitting<br>
					  withLatestFrom(source),<br>
					  map(([first, second]) => {<br>
					    return `Source (1s): ${first} Latest From (5s): ${second}`;<br>
					  })<br>
					);<br><br>

					/*
					  "Source (1s): 4 Latest From (5s): 0" <br>
					  "Source (1s): 5 Latest From (5s): 0"<br>
					  "Source (1s): 6 Latest From (5s): 0"<br>
					  ...<br>
					*/<br><br>

					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>take</p>
            </div>
            <div class="second_column table_column">
                <p>
					Emit provided number of values before completing.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Take 1 value from source <br> <br>

					import { of } from 'rxjs'; <br>
					import { take } from 'rxjs/operators'; <br><br>

					//emit 1,2,3,4,5<br>
					const source = of(1, 2, 3, 4, 5);<br>

					//take the first emitted value then complete<br>
					const example = source.pipe(take(1));<br><br>

					//output: 1<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

					Example 2: Take the first 5 values from source <br> <br>

					import { interval } from 'rxjs'; <br>
					import { take } from 'rxjs/operators'; <br> <br>

					//emit value every 1s <br>
					const interval$ = interval(1000); <br><br>

					//take the first 5 emitted values<br>
					const example = interval$.pipe(take(5));<br><br>

					//output: 0,1,2,3,4<br>
					const subscribe = example.subscribe(val => console.log(val));

					
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>takeWhile</p>
            </div>
            <div class="second_column table_column">
                <p>
					Emit values until provided expression is false.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Take values under limit <br> <br>

					import { of } from 'rxjs'; <br> 
					import { takeWhile } from 'rxjs/operators'; <br> <br>

					//emit 1,2,3,4,5<br>
					const source = of(1, 2, 3, 4, 5);<br><br>

					//allow values until value from source is greater than 4, then complete<br>
					const example = source.pipe(takeWhile(val => val <= 4));<br><br>

					//output: 1,2,3,4<br>
					const subscribe = example.subscribe(val => console.log(val));

                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>takeUntil</p>
            </div>
            <div class="second_column table_column">
                <p>
                    Emit values until provided observable emits.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    Example 1: Take values until timer emits: <br> <br>
                    import { interval, timer } from 'rxjs';<br>
                    import { takeUntil } from 'rxjs/operators';<br><br>

                    //emit value every 1s<br>
                    const source = interval(1000);<br>
                    //after 5 seconds, emit value<br>
                    const timer$ = timer(5000);<br>
                    //when timer emits after 5s, complete source<br>
                    const example = source.pipe(takeUntil(timer$));<br>
                    //output: 0,1,2,3<br>
                    const subscribe = example.subscribe(val => console.log(val));<br><br>

                    Example 2: Take the first 5 even numbers:<br><br>
                    import { interval } from 'rxjs/observable/interval';<br>
                    import { takeUntil, filter, scan, map, withLatestFrom } from 'rxjs/operators';<br><br>

                    //emit value every 1s<br>
                    const source = interval(1000);<br>
                    //is number even?<br>
                    const isEven = val => val % 2 === 0;<br>
                    //only allow values that are even<br>
                    const evenSource = source.pipe(filter(isEven));<br>
                    //keep a running total of the number of even numbers out<br>
                    const evenNumberCount = evenSource.pipe(scan((acc, _) => acc + 1, 0));<br>
                    //do not emit until 5 even numbers have been emitted<br>
                    const fiveEvenNumbers = evenNumberCount.pipe(filter(val => val > 5));<br><br>

                    const example = evenSource.pipe(<br>
                    //also give me the current even number count for display<br>
                    withLatestFrom(evenNumberCount),<br>
                    map(([val, count]) => `Even number (${count}) : ${val}`),<br>
                    //when five even numbers have been emitted, complete source observable<br>
                    takeUntil(fiveEvenNumbers)<br>
                    );<br>
                    /*<br>
                    Even number (1) : 0,<br>
                    Even number (2) : 2<br>
                    Even number (3) : 4<br>
                    Even number (4) : 6<br>
                    Even number (5) : 8<br>
                    */<br>
                    const subscribe = example.subscribe(val => console.log(val)); <br> <br>
	
					Example 3: take until OnDestroy event. <br> <br>

					Component:<br>
					export class TestObservablesComponent extends MyOnDestroy {<br><br>

					  observable1$: Observable&lt;number&gt;;<br><br>

					  constructor( private observableService: ObservableFactoryService,<br>
					               public messageService: MessageService) {<br>
					    super();<br>
					  }<br><br>

					  onFirstButtonClick() {<br>

					    this.observable1$ = this.observableService.getObservable().pipe(<br>
					      takeUntil(this.onDestroy$),<br>
					    );<br>

					    this.observable1$.subscribe(observer);<br>
					 }<br><br>

					 Service: <br>
					   getObservable() { <br>
						    return interval(500); <br>
						  } <br> <br>

					MyOnDestroy.ts: <br>
					export class MyOnDestroy implements OnDestroy { <br><br>

					  onDestroy$ = new Subject();<br>

					  ngOnDestroy() {<br>
					    this.onDestroy$.next();<br>
					    this.onDestroy$.complete();<br>
					  }<br>
					}
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>skipUntil</p>
            </div>
            <div class="second_column table_column">
                <p>
					Skip emitted values from source until provided observable emits.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Skip until observable emits <br> <br>

					import { interval, timer } from 'rxjs'; <br>
					import { skipUntil } from 'rxjs/operators'; <br> <br>

					//emit every 1s <br>
					const source = interval(1000); <br><br>

					//skip emitted values from source until inner observable emits (6s)<br>
					const example = source.pipe(skipUntil(timer(6000)));<br><br>

					//output: 5...6...7...8........<br>
					const subscribe = example.subscribe(val => console.log(val));
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>mergeMap</p>
            </div>
            <div class="second_column table_column">
                <p>
					Map to observable, emit values.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: mergeMap with observable <br> <br>
					
					import { of } from 'rxjs'; <br>
					import { mergeMap } from 'rxjs/operators'; <br><br>

					//emit 'Hello' <br>
					const source = of('Hello'); <br><br>

					//map to inner observable and flatten <br>
					const example = source.pipe(mergeMap(val => of(`${val} World!`)));<br><br>

					//output: 'Hello World!'<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>

                </p>
            </div>
        </div>

		<div class="table_row zebra1">
            <div class="first_column table_column">
                <p>switchMap</p>
            </div>
            <div class="second_column table_column">
                <p>
                    Map to observable, complete previous inner observable, emit values. <br> <br>

                    signature: <br>
                     switchMap(<br>
                     project: function: Observable,<br>
                     resultSelector: function(outerValue, innerValue, outerIndex, innerIndex): any <br>
                     ): Observable <br><br>

          			The main difference between switchMap and other flattening operators is the cancelling effect. On each emission the previous inner observable (the result of the function you supplied) is cancelled and the new observable is subscribed. You can remember this by the phrase switch to a new observable.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                	Example 1: Restart interval every 5 seconds. <br><br>

                    import { timer, interval } from 'rxjs'; <br>
					import { switchMap } from 'rxjs/operators'; <br><br>

					//emit immediately, then every 5s<br>
					const source = timer(0, 5000);<br><br>

					//switch to new inner observable when source emits, emit items that are emitted<br>
					const example = source.pipe(switchMap(() => interval(500)));<br><br>

					//output: 0,1,2,3,4,5,6,7,8,9...0,1,2,3,4,5,6,7,8<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>
					
					Example 2: Reset on every click. <br><br>

					import { interval, fromEvent } from 'rxjs';<br>
					import { switchMap, mapTo } from 'rxjs/operators';<br><br>

					//emit every click<br>
					const source = fromEvent(document, 'click');<br><br>

					//if another click comes within 3s, message will not be emitted<br>
					const example = source.pipe(<br>
					  switchMap(val => interval(3000).pipe(mapTo('Hello, I made it!')))<br>
					);<br><br>

					//(click)...3s...'Hello I made it!'...(click)...2s(click)...<br>
					const subscribe = example.subscribe(val => console.log(val));<br><br><br>


					interface Employee { <br>
						name: string;<br>
						position: string;<br>
						id: string; <br>
					}<br><br>

					interface Location {<br>
						locationName: string;<br>
						employeeId: string;<br>
						locationId: string;<br>
					}<br><br>

					let $employee: Observable&ltEmployee&gt= of({<br>
						name: "Eddy",<br>
						position: "Top Top4ik",<br>
						id: "1"<br>
					});<br><br>

					let $xz = of(null);  // <- UndefinedType<br><br>

					let $location: Observable&ltLocation&gt = of({<br>
						locationName: "San Jose",<br>
						employeeId: "1",<br>
						locationId: "99999"<br>
					});<br><br>

					constructor(private httpService: HttpService){}<br><br>

					combineLatest($employee, $xz).pipe(<br>
						filter([[employee, xz], location]:[[Employee, UndefinedType], Location] => xz !== null; ),<br>
						withLatestFrom($location),<br>
						delay(5000),<br>
						switchMap([[employee, xz], location]:[[Employee, UndefinedType], Location]) =><br>
						 this.httpService.post('SomeUrl', [[employee, xz], location])<br>
					).subscribe();

                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>debounceTime</p>
            </div>
            <div class="second_column table_column">
                <p>
					Discard emitted values that take less than the specified time between output
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: Debouncing based on time between input <br> <br>

					import { fromEvent, timer } from 'rxjs'; <br>
					import { debounceTime, map } from 'rxjs/operators';<br><br>

					const input = document.getElementById('example');<br><br>

					//for every keyup, map to current input value<br>
					const example = fromEvent(input, 'keyup').pipe(map(i => i.currentTarget.value));<br><br>

					//wait .5s between keyups to emit current value<br>
					//throw away all other values<br>
					const debouncedInput = example.pipe(debounceTime(500));<br><br>

					//log values<br>
					const subscribe = debouncedInput.subscribe(val => {<br>
					  console.log(`Debounced Input: ${val}`);<br>
					});
                </p>
            </div>
        </div>

        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>distinctUntilChanged</p>
            </div>
            <div class="second_column table_column">
                <p>
					Only emit when the current value is different than the last. <br> <br>
					distinctUntilChanged uses === comparison by default, object references must match!
                </p>
            </div>
            <div class="third_column table_column">
                <p>
					Example 1: distinctUntilChanged with basic values <br> <br>

					import { from } from 'rxjs'; <br>
					import { distinctUntilChanged } from 'rxjs/operators'; <br><br>

					//only output distinct values, based on the last emitted value <br>
					const myArrayWithDuplicatesInARow = from([1, 1, 2, 2, 3, 1, 2, 3]); <br><br>

					const distinctSub = myArrayWithDuplicatesInARow <br>
					  .pipe(distinctUntilChanged())<br>

					  //output: 1,2,3,1,2,3<br>
					  .subscribe(val => console.log('DISTINCT SUB:', val));<br><br>

					const nonDistinctSub = myArrayWithDuplicatesInARow<br>
					  //output: 1,1,2,2,3,1,2,3<br>
					  .subscribe(val => console.log('NON DISTINCT SUB:', val));<br><br><br>
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>catchError</p>
            </div>
            <div class="second_column table_column">
                <p>
                    In addition to the error() handler that you provide on subscription,
                    RxJS provides the catchError operator that lets you handle known errors in the observable recipe.
                    <br><br>
                    For instance, suppose you have an observable that makes an API request and maps to the response
                    from the server. If the server returns an error or the value doesn’t exist, an error is produced.
                    If you catch this error and supply a default value, your stream continues to process values
                    rather than erroring out.
                    <br><br>
                    retry() - Where the catchError operator provides a simple path of recovery,
                    the retry operator lets you retry a failed request.
                    <br><br>
                    Use the retry operator before the catchError operator. It resubscribes to the original
                    source observable, which can then re-run the full sequence of actions that resulted in the error.
                    If this includes an HTTP request, it will retry that HTTP request.
                    <br><br>

                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    'rxjs/operators'; <br><br>

                    const apiData = ajax('/api/data').pipe( <br>
                    retry(3), // Retry up to 3 times before failing<br>
                    map(res => {<br>
                    if (!res.response) {<br>
                    throw new Error('Value expected!'); }<br>
                    return res.response;<br>
                    }),<br>
                    catchError(err => of([]))<br>
                    );<br><br>

                    apiData.subscribe({<br>
                    next(x) { console.log('data: ', x); }, <br>
                    error(err) { console.log('errors already caught... will not run'); } <br>
                    });
                </p>
            </div>
        </div>


        <div class="table_row zebra1">
            <div class="first_column table_column">
                <p>Type-ahead Suggestions</p>
            </div>
            <div class="second_column table_column">
                <p>
                    Observables can simplify the implementation of type-ahead suggestions.
                    Typically, a type-ahead has to do a series of separate tasks: <br>
                    •	Listen for data from an input.<br>
                    •	Trim the value (remove whitespace) and make sure it’s a minimum length.<br>
                    •	Debounce (so as not to send off API requests for every keystroke, but instead wait for a break in keystrokes).<br>
                    •	Don’t send a request if the value stays the same (rapidly hit a character, then backspace, for instance).<br>
                    •	Cancel ongoing AJAX requests if their results will be invalidated by the updated results.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    import { fromEvent } from 'rxjs'; <br>
                    import { ajax } from 'rxjs/ajax';<br>
                    import { map, filter, debounceTime, distinctUntilChanged, switchMap } from 'rxjs/operators';<br><br>

                    const searchBox = document.getElementById('search-box'); <br><br>

                    const typeahead = fromEvent(searchBox, 'input').pipe(<br>
                    map((e: KeyboardEvent) =&gt; e.target.value),<br>
                    filter(text =&gt; text.length &gt; 2),<br>
                    debounceTime(10),<br>
                    distinctUntilChanged(),<br>
                    switchMap(() =&gt; ajax('/api/endpoint'))<br>
                    );<br><br>

                    typeahead.subscribe(data =&gt; {<br>
                    // Handle the data from the API<br>
                    });
                </p>
            </div>
        </div>

        <div class="table_row zebra2">
            <div class="first_column table_column">
                <p>
                    Exponential Backoff
                </p>
            </div>
            <div class="second_column table_column">
                <p>
                    Exponential backoff is a technique in which you retry an API after failure,
                    making the time in between retries longer after each consecutive failure,
                    with a maximum number of retries after which the request is considered to have failed.
                </p>
            </div>
            <div class="third_column table_column">
                <p>
                    import { pipe, range, timer, zip } from 'rxjs'; <br>
                    import { ajax } from 'rxjs/ajax';<br>
                    import { retryWhen, map, mergeMap } from 'rxjs/operators';<br><br>

                    function backoff(maxTries, ms) {<br>
                    return pipe(<br>
                    retryWhen(attempts =&gt; range(1, maxTries)<br>
                    .pipe(<br>
                    zip(attempts, (i) =&gt; i),<br>
                    map(i =&gt; i * i),<br>
                    mergeMap(i =&gt; timer(i * ms))<br>
                    ) ) ); }<br><br>

                    ajax('/api/endpoint')<br>
                    .pipe(backoff(3, 250))<br>
                    .subscribe(data =&gt; handleData(data));<br><br>

                    function handleData(data) {<br>
                    // ...<br>
                    }
                </p>
            </div>
        </div>

        <!-- -------------------------------------------------HTTP------------------------------------------------------ -->

        <div class="anchor_row zebra3" id="http">
            <h1>HTTP</h1>
        </div>

        <div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Setup</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Before you can use the HttpClient, you need to import the Angular HttpClientModule.
                    Most apps do so in the root AppModule. <br><br>

                    Having imported HttpClientModule into the AppModule,
                    you can inject the HttpClient into an application class
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    import { HttpClientModule } from '@angular/common/http'; <br><br>

                    @NgModule({<br>
                    imports: [ BrowserModule,<br>
                    // import HttpClientModule after BrowserModule.<br>
                    HttpClientModule, ],<br><br>

                    constructor(private http: HttpClient) { }
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.get() JSON</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Applications often request JSON data from the server. <br><br>

                    The service fetches this file with a get() method on HttpClient.<br><br>

                    Because the service method returns an Observable of configuration data,
                    the component subscribes to the method's return value. The subscription callback copies
                    the data fields into the component's config object,
                    which is data-bound in the component template for display.<br><br>


                    You can tell HttpClient the type of the response to make consuming the output easier and more obvious.
                    define an interface with the correct shape.
                    Then, specify that interface as the HttpClient.get() call's type parameter in the service:
                    The callback in the updated component method receives a typed data object,
                    which is easier and safer to consume:
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    config.json: <br>
                    {<br>
                    "heroesUrl": "api/heroes",<br>
                    "textfile": "assets/textfile.txt"<br>
                    }<br><br>

                    export interface Config {<br>
                    heroesUrl: string;<br>
                    textfile: string; }<br><br>
                    configUrl = 'assets/config.json';<br><br>

                    getConfig() {<br>
                    return this.http.get(this.configUrl);<br>
                    }<br><br>

                    showConfig() {<br>
                    this.getConfig() .subscribe(<br>
                    (data: Config) =&gt; this.config = {<br>
                    heroesUrl: data['heroesUrl'],<br>
                    textfile: data['textfile']<br>
                    }); }<br><br>

                    OR<br><br>

                    getConfig() {<br>
                    // now returns an Observable of Config<br>
                    return this.http.get&lt;Config&gt;(this.configUrl);<br>
                    }<br><br>

                    config: Config;<br>
                    showConfig() {<br>
                    this.getConfig() // clone the data object, using its known Config shape<br>
                    .subscribe(<br>
                    (data: Config) =&gt; this.config = { ...data }<br>
                    ); }
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>get() not JSON</p>
			</div>
			<div class="second_column table_column">
				<p>
                    HttpClient.get() returns a string rather than the default JSON because of the responseTypeoption.
                    The RxJS tap operator (as in "wiretap") lets the code inspect good and error values passing through
                    the observable without disturbing them.
                    A download() method in the DownloaderComponent initiates the request by subscribing
                    to the service method.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    getTextFile(filename: string) {<br>
                    // The Observable returned by get() is of type Observable&lt;string&gt; because a text response was specified.
                    <br>
                    // There's no need to pass a &lt;string&gt; type parameter to get(). <br>
                    return this.http.get(filename, {responseType: 'text'}) .pipe(<br>
                    tap( // Log the result or error<br>
                    data =&gt; this.log(filename, data),<br>
                    error =&gt; this.logError(filename, error)<br>
                    ) ); }<br><br>

                    download() {<br>
                    this.downloaderService.getTextFile('assets/textfile.txt')<br>
                    .subscribe(results =&gt; this.contents = results);<br>
                    }
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Error handling</p>
			</div>
			<div class="second_column table_column">
				<p>
                    What happens if the request fails on the server,
                    or if a poor network connection prevents it from even reaching the server?
                    HttpClient will return an error object instead of a successful response. <br> <br>

                    You could handle in the component by adding a second callback to the .subscribe():<br> <br>

                    Better:<br> <br>

                    Two types of errors can occur. The server backend might reject the request, returning an HTTP response
                    with a status code such as 404 or 500. These are error responses.<br>
                    Or something could go wrong on the client-side such as a network error that prevents
                    the request from completing successfully or an exception thrown in an RxJS operator.
                    These errors produce JavaScript ErrorEvent objects.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    showConfig() {<br>
                    this.configService.getConfig()<br>
                    .subscribe(<br>
                    (data: Config) =&gt; this.config = { ...data }, // success path<br>
                    error =&gt; this.error = error // error path );<br>
                    }<br><br>

                    Better:<br><br>

                    private handleError(error: HttpErrorResponse) {<br>
                    if (error.error instanceof ErrorEvent) {<br>
                    // A client-side or network error occurred. Handle it accordingly.<br>
                    console.error('An error occurred:', error.error.message); }<br>
                    else {<br>
                    // The backend returned an unsuccessful response code.<br>
                    // The response body may contain clues as to what went wrong,<br>
                    console.error( `Backend returned code ${error.status}, ` + `body was: ${error.error}`);<br>
                    } // return an observable with a user-facing error message<br>
                    return throwError( 'Something bad happened; please try again later.');<br>
                    };<br><br>

                    getConfig() {<br>
                    return this.http.get&lt;Config&gt;(this.configUrl)<br>
                    .pipe( catchError(this.handleError) );<br>
                    }
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>retry()</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Sometimes the error is transient and will go away automatically if you try again. <br>
                    retry() - automatically re-subscribes to a failed Observable a specified number of times.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    getConfig() {<br>
                    return this.http.get&lt;Config&gt;(this.configUrl)<br>
                    .pipe(<br>
                    retry(3), // retry a failed request up to 3 times<br>
                    catchError(this.handleError) // then handle the error );<br>
                    }
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.post()</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Often apps POST when submitting a form. <br><br>

                    The HttpClient.post() method is similar to get() in that it has a type parameter
                    (you're expecting the server to return the new hero) and it takes a resource URL.<br>
                    It takes two more parameters:<br>
                    1.	hero - the data to POST in the body of the request. <br>
                    2.	httpOptions - the method options which, in this case, specify required headers.<br><br>
                    The HeroesComponent initiates the actual POST operation by subscribing
                    to the Observable returned by this service method.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    // POST: add a new hero to the database <br>
                    addHero (hero: Hero): Observable&lt;Hero&gt; {<br>
                    return this.http.post&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)<br>
                    .pipe( catchError(this.handleError('addHero', hero)) );<br>
                    }<br><br>

                    this.heroesService.addHero(newHero)<br>
                    .subscribe(hero =&gt; this.heroes.push(hero));
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>.delete()</p>
			</div>
			<div class="second_column table_column">
				<p>
                    This application deletes a hero with the HttpClient.delete method by passing the hero's
                    id in the request URL. <br><br>

                    The HeroesComponent initiates the actual DELETE operation by subscribing to the Observable returned
                    by this service method.<br><br>

                    The component isn't expecting a result from the delete operation,
                    so it subscribes without a callback. Even though you are not using the result,
                    you still have to subscribe. Calling the subscribe() method executes the observable,
                    which is what initiates the DELETE request.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    // DELETE: delete the hero from the server <br>
                    deleteHero (id: number): Observable&lt;{}&gt; {<br>
                    const url = `${this.heroesUrl}/${id}`;<br>
                    // DELETE api/heroes/42<br>
                    return this.http.delete(url, httpOptions)<br>
                    .pipe( catchError(this.handleError('deleteHero')) );<br>
                    }<br><br>

                    this.heroesService.deleteHero(hero.id).subscribe();
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.put()</p>
			</div>
			<div class="second_column table_column">
				<p>
                    An app will send a PUT request to completely replace a resource with updated data.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    // PUT: update the hero on the server. Returns the updated hero upon success.<br>
                    updateHero (hero: Hero): Observable&lt;Hero&gt; {<br>
                    return this.http.put&lt;Hero&gt;(this.heroesUrl, hero, httpOptions)<br>
                    .pipe( catchError(this.handleError('updateHero', hero)) );<br>
                    }<br><br>

                    this.heroesService. updateHero (hero).subscribe();
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Headers</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Many servers require extra headers for save operations. <br><br>

                    Sets the default headers by passing an options object (httpOptions) to its save methods. <br><br>

                    You can't directly modify the existing headers within the previous options object because
                    instances of the HttpHeaders class are immutable.<br>
                    Use the set() method instead. It returns a clone of the current instance with the new changes applied.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    import { HttpHeaders } from '@angular/common/http';<br><br>

                    const httpOptions = { headers: new HttpHeaders({<br>
                    'Content-Type': 'application/json',<br>
                    'Authorization': 'my-auth-token'<br>
                    }) };<br><br>

                    httpOptions.headers = httpOptions.headers.set('Authorization', 'my-new-auth-token');
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>URL Parameters</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Adding URL search parameters works a similar way. <br> <br>

                    If there is a search term, the code constructs an options object with
                    an HTML URL-encoded search parameter. If the term were "foo",
                    the GET request URL would be api/heroes/?name=foo.<br>
                    The HttpParams are immutable so you'll have to use the set() method to update the options.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    // GET heroes whose name contains search term<br>
                    searchHeroes(term: string): Observable&lt;Hero[]&gt; {<br>
                    term = term.trim();<br>
                    // Add safe, URL encoded search parameter if there is a search term<br>
                    const options = term ? { params: new HttpParams().set('name', term) } : {};<br>
                    return this.http.get&lt;Hero[]&gt;(this.heroesUrl, options)<br>
                    .pipe(<br>
                    catchError(this.handleError&lt;Hero[]&gt;('searchHeroes', [])) );<br>
                    }
                </p>
			</div>
		</div>


        <!-- -------------------------------------------------Routing------------------------------------------------------ -->

        <div class="anchor_row zebra3" id="routing">
            <h1>Routing</h1>
        </div>

        <div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Setup</p>
			</div>
			<div class="second_column table_column">
				<p>
                    Most routing applications should add a &lt;base&gt; element to the index.html as the first child
                    in the &lt;head&gt; tag to tell the router how to compose navigation URLs. <br> <br>

                    The Angular Router is an optional service that presents a particular component view for a given URL.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    index.html: <br>
                    &lt;base href="/"&gt;<br><br>

                    router-module:<br>
                    import { RouterModule, Routes } from '@angular/router';
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Routes</p>
			</div>
			<div class="second_column table_column">
				<p>
                    A routed Angular application has one singleton instance of the Router service.
                    When the browser's URL changes, that router looks for a corresponding Route from which
                    it can determine the component to display. <br> <br>

                    The appRoutes array of routes describes how to navigate.
                    Pass it to the RouterModule.forRoot method in the module imports to configure the router. <br><br>

                    Each Route maps a URL path to a component. There are no leading slashes in the path.
                    The router parses and builds the final URL for you,
                    allowing you to use both relative and absolute paths when navigating between application views. <br><br>

                    The order of the routes in the configuration matters and this is by design.
                    The router uses a first-match wins strategy when matching routes,
                    so more specific routes should be placed above less specific routes.
                    In the configuration above, routes with a static path are listed first,
                    followed by an empty path route, that matches the default route.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    const appRoutes: Routes = [ <br>
                    { path: 'crisis-center', component: CrisisListComponent },<br>
                    { path: 'hero/:id', component: HeroDetailComponent },<br>
                    { path: 'heroes', component: HeroListComponent, data: { title: 'Heroes List' } },<br>
                    { path: '', redirectTo: '/heroes', pathMatch: 'full' },<br>
                    { path: '**', component: PageNotFoundComponent }<br>
                    ];<br><br>

                    @NgModule({<br>
                    imports: [ RouterModule.forRoot(<br>
                    appRoutes,<br>
                    { enableTracing: true } // &lt;-- debugging purposes only )<br>
                    // other imports here ], ...<br>
                    })<br><br>

                    export class AppModule { }
                </p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Child Routes</p>
			</div>
			<div class="second_column table_column">
				<p>
					If the selected component itself must accept some other component as internal content depending on the request.
					 In this case, we need to use child routes. <br>
					Each of the child routes is matched not entirely by the url address, but only with its part. <br><br>

					When navigating through similar links, routing to the ItemComponent component will work and the route parameter -
					 id will be transmitted to it. And routing to the ItemDetailsComponent or ItemStatComponent will also work
					  if after the id there is any "details" or "stat" segment:
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					Route module: <br> <br>

					const itemRoutes: Routes = [<br>
					    { path: 'details', component: ItemDetailsComponent},<br>
					    { path: 'stat', component: ItemStatComponent},<br>
					];<br><br>
					 
					const appRoutes: Routes =[<br><br>
					 
					    { path: 'item/:id', component: ItemComponent},<br>
					    { path: 'item/:id', component: ItemComponent, children: itemRoutes},<br>
					    { path: '', component: HomeComponent}<br>
					];<br><br><br>

					Item.component:<br><br>

					import { Component} from '@angular/core';<br>
					import { ActivatedRoute} from '@angular/router';<br>
					import {Subscription} from 'rxjs/Subscription';<br><br>
					  
					@Component({<br>
					    selector: 'item-info',<br>
					    template: `&lt;h2&gt;Projuct {{id}}&lt;/h2&gt;<br>
					               &lt;router-outlet&gt;&lt;/router-outlet&gt;`<br>
					})<br><br>

					export class ItemComponent{ <br><br>
					     
					    private id: number;<br>
					    private routeSubscription: Subscription;<br><br>
					     
					    constructor(private route: ActivatedRoute){<br><br>
					         
					        this.routeSubscription = route.params.subscribe(params=&gt;this.id=params['id']);<br>
					    }<br>
					}<br><br><br>

					App.component:<br><br>

					    template: `&lt;div&gt;<br>
					                    &lt;nav&gt;<br>
					                        &lt;a routerLink=""&gt;Home&lt;/a&gt; | <br>
					                        &lt;a routerLink="/item/5/details"&gt;Product Details&lt;/a&gt; | <br>
					                        &lt;a routerLink="/item/5/stat"&gt;Product Stats&lt;/a&gt; <br>
					                    &lt;/nav&gt; <br>
					                    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br>
					               &lt;/div&gt;` <br> <br> <br>

				Example 2: <br> <br>

				const crisisCenterRoutes: Routes = [<br>
				  {<br>
				    path: 'crisis-center',<br>
				    component: CrisisCenterComponent,<br>
				    children: [<br>
				      {<br>
				        path: '',<br>
				        component: CrisisListComponent,<br>
				        children: [<br>
				          {<br>
				            path: ':id',<br>
				            component: CrisisDetailComponent<br>
				          },<br>
				          {<br>
				            path: '',<br>
				            component: CrisisCenterHomeComponent<br>
				          }<br>
				        ]<br>
				      }<br>
				    ]<br>
				  }<br>
				];
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>&lt;router-outlet&gt;</p>
			</div>
			<div class="second_column table_column">
				<p>
                    The RouterOutlet is a directive from the router library that is used like a component.
                    It acts as a placeholder that marks the spot in the template where the router should display
                    the components for that outlet.
                </p>
			</div>
			<div class="third_column table_column">
				<p>&lt;router-outlet&gt;&lt;/router-outlet&gt;</p>
			</div>
		</div>

		
		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Router Links</p>
			</div>
			<div class="second_column table_column">
				<p>
                    routerLink="/heroes" <br><br>

                    routerLinkActive="active" <br><br>

                    [routerLinkActiveOptions] = { exact: true } <br><br>

                    The RouterLink directives on the anchor tags give the router control over those elements.
                    The navigation paths are fixed, so you can assign a string to the routerLink (a "one-time" binding).<br><br>

                    The RouterLinkActive directive toggles css classes for active RouterLink
                    bindings based on the current RouterState.<br><br>

                    By using { exact: true }, a given RouterLink will only be active if its URL
                    is an exact match to the current URL.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    &lt;h1&gt;Angular Router&lt;/h1&gt; <br>
                    &lt;nav&gt;<br>
                    &lt;a routerLink="/crisis-center" routerLinkActive="active"&gt;Crisis Center&lt;/a&gt;<br>
                    &lt;a routerLink="/heroes" routerLinkActive="active"<br>
                    [routerLinkActiveOptions] = { exact: true } &gt;Heroes&lt;/a&gt;<br>
                    &lt;/nav&gt;<br>
                    &lt;router-outlet&gt;&lt;/router-outlet&gt;
                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>.navigate()</p>
			</div>
			<div class="second_column table_column">
				<p>
					We can go to any resource in our application. <br>
					 A router that is defined in the "angular / router" packet,
					  and which is passed to the components through the dependency injection mechanism. <br>
					Through the constructor, get the Router object and in the handler of the button call its navigate () method. <br> <br>

					this.router.navigate (['/about']); <br> <br>

					To give the ItemComponent necessary parameters we put path as a first parameter in the navigate() method,
					and all other are values for path parameters . <br>
					 The second parameter represents a javascript object that contains all the necessary values ​​for the query string parameters:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Example 1: <br><br>
                    import { Component} from '@angular/core'; <br>
					import {Router} from '@angular/router';<br><br>
					  
					@Component({<br>
					    selector: 'my-app',<br>
					    template: `&lt;div&gt;<br>
					                    &lt;nav&gt;<br>
					                        &lt;a routerLink=""&gt;Home&lt;/a&gt;<br>
					                        &lt;a routerLink="/about"&gt;About&lt;/a&gt;<br>
					                    &lt;/nav&gt;<br>
					                    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br>
					                    &lt;button (click)="goHome()"&gt;To Home&lt;/button&gt;<br>
					               &lt;/div&gt;`<br>
					})<br><br>
					export class AppComponent {<br><br>
					     
					    constructor(private router: Router){}<br><br>

					    goHome(){<br><br>
					         
					        this.router.navigate(['']);<br>
					    }<br><br><br>

					Example 2: For path with paramaters:<br><br>

					import { Component} from '@angular/core'; <br>
					import { Router} from '@angular/router'; <br><br>
					  
					export class Item{<br><br>
					     
					    id: number;<br>
					    product: string;<br>
					    price: number;<br>
					}<br><br>
					  
					@Component({<br>
					    selector: 'my-app',<br>
					    template: `&lt;div&gt;<br>
					                    &lt;nav&gt;<br>
					                        &lt;a routerLink=""&gt;Home&lt;/a&gt;<br>
					                        &lt;a routerLink="/about"&gt;About&lt;/a&gt;
					                    &lt;/nav&gt;<br>
					                    &lt;div  class="form-group"&gt;<br>
					                        &lt;h3&gt;Object Parameters&lt;/h3&gt; <br>
					                        &lt;input type="number" [(ngModel)]="item.id" class="form-control" placeholder="Item's ID" <br>
					                        &lt;input type="number" [(ngModel)]="item.price" class="form-control" placeholder="Price"  <br>
					                        &lt;input [(ngModel)]="item.product" class="form-control" placeholder="Product"<br>
					                        &lt;button (click)="goToItem(item)" class="btn"&gt;GO&lt;/button&gt;<br>
					                    &lt;/div&gt;<br>
					                    &lt;router-outlet&gt;&lt;/router-outlet&gt;<br>
					               &lt;/div&gt;`<br>
					})<br><br>
					export class AppComponent {<br><br>
					     
					    item: Item=new Item();<br><br>
					     
					    constructor(private router: Router){}<br><br>
					     
					    goToItem(myItem: Item){<br><br>
					             
					        this.router.navigate(<br>
					            ['/item', myItem.id], <br>
					            {<br>
					                queryParams:{<br>
					                    'product': myItem.product, <br>
					                    'price': myItem.price<br>
					                }<br>
					            }<br>
					        );<br>
					    }<br>
					}

                </p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Activated Route</p>
			</div>
			<div class="second_column table_column">
				<p>
                    The route path and parameters are available through an injected router
                    service called theActivatedRoute. It has a great deal of useful information including: <br><br>

                    -   url - An Observable of the route path(s), represented as an array
                    of strings for each part of the route path. <br><br>

                    -   data - An Observable that contains the data object provided for the route.
                    Also contains any resolved values from the resolve guard. <br><br>

                    -   paramMap - An Observable that contains a map of the required and optional
                    parameters specific to the route. The map supports retrieving single and
                    multiple values from the same parameter.<br><br>

                    -   queryParamMap - An Observable that contains a map of the query parameters available
                    to all routes. The map supports retrieving single and multiple values from the query parameter.<br><br>

                    -   fragment - An Observable of the URL fragment available to all routes.<br><br>

                    -   outlet - The name of the RouterOutlet used to render the route.
                    For an unnamed outlet, the outlet name is primary.<br><br>

                    -    routeConfig - The route configuration used for the route that contains the origin path.<br><br>

                    -   parent - The route's parent ActivatedRoute when this route is a child route.<br><br>

                    -   firstChild - Contains the first ActivatedRoute in the list of this route's child routes.<br><br>

                    -   children - Contains all the child routes activated under the current route.
                </p>
			</div>
			<div class="third_column table_column">
				<p>-</p>
			</div>
		</div>


		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Parameters</p>
			</div>
			<div class="second_column table_column">
				<p>
                    The :id in the second route is a token for a route parameter.
                    In a URL such as /hero/42, "42" is the value of the id parameter. <br> <br>

                    The switchMap operator also cancels previous in-flight requests.
                    If the user re-navigates to this route with a new id while
                    the HeroService is still retrieving the old id, switchMap discards that old request
                    and returns the hero for the new id. <br>
                    The observable Subscription will be handled by the AsyncPipe
                    and the component's hero property will be (re)set with the retrieved hero. <br><br>

                    The route.snapshot provides the initial value of the route parameter map.
                    You can access the parameters directly without subscribing or adding observable operators.
                    It's much simpler to write and read:
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    localhost:4200/hero/42 <br><br>

                    { path: 'hero/:id', component: HeroDetailComponent } <br><br>

                    import { Router, ActivatedRoute, ParamMap } from '@angular/router';<br>
                    import { switchMap } from 'rxjs/operators';<br><br>

                    constructor( <br>
                    private route: ActivatedRoute,<br>
                    private router: Router,<br>
                    private service: HeroService <br>
                    ) {}<br><br>

                    ngOnInit() {<br>
                    this.hero$ = this.route.paramMap.pipe(<br>
                    switchMap((params: ParamMap) => this.service.getHero(params.get('id')))<br>
                    ); }<br><br>

                    Or if you don’t have chance of dynamical change of ID: <br><br>

                    ngOnInit() {<br>
                    let id = this.route.snapshot.paramMap.get('id');<br>
                    this.hero$ = this.service.getHero(id);<br>
                    }
                </p>
			</div>
		</div>

				<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Query Parameters</p>
			</div>
			<div class="second_column table_column">
				<p>
					In addition to the route parameters in the request, the parameters of the query string can be passed. <br>
					in the request http: // localhost: 3000 / item? product = phone & price = 200 the product = phone & price = 200 part will represent the request parameters - product and price. Such parameters are placed at the end of the address after the question mark and are separated by an ampersand.
						<br> <br>
					Getting parameters from the query string is similar to getting data from the route, only in this case the queryParams property of the ActivatedRoute class is used. <br> <br>

					And as in the case of route parameters, the result of calling route.queryParams.subscribe () is the Subscription object, which must be deleted when the component is deleted in the ngOnDestroy method. <br> <br>

					To pass parameters to the link, the queryParams directive is applied, which accepts a javascript object.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
					import { Component} from '@angular/core'; <br>
					import { ActivatedRoute} from '@angular/router'; <br>
					import {Subscription} from 'rxjs'; <br><br>
					  
					@Component({<br>
					    selector: 'item-info',<br>
					    template: `&lt;h3&gt;Id #{{id}}&lt;/h3&gt; <br>
					                &lt;div&gt;Product: {{product}}&lt;/div&gt;<br>
					                &lt;div&gt;Price: {{price}}&lt;/div&gt;`<br>
					})<br><br>

					export class ItemComponent{ <br><br>
					     
					    private id: number;<br>
					    private product: string;<br>
					    private price: string;<br><br>
					     
					    private routeSubscription: Subscription;<br>
					    private querySubscription: Subscription;<br><br>
					    constructor(private route: ActivatedRoute){<br><br>
					         
					        this.routeSubscription = route.params.subscribe(params=&gt;this.id=params['id']); <br>
					        this.querySubscription = route.queryParams.subscribe(<br>
					            (queryParam: any) =&gt; {<br>
					                this.product = queryParam['product'];<br>
					                this.price = queryParam['price'];<br>
					            }<br>
					        );<br>
					    }<br>
					}<br><br><br>

					Appcomponent:<br><br>

						&lt;a [routerLink]="['item', '5']"<br>
					      [queryParams]="{'product':'phone', 'price': 200}"&gt;item 5&lt;/a&gt;<br>
					    &lt;a [routerLink]="['item', '8']"<br>
					      [queryParams]="{'product':'tablet'}"&gt;item 8&lt;/a&gt;

                </p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>Data</p>
			</div>
			<div class="second_column table_column">
				<p>
                    The data property in the third route is a place to store arbitrary data associated
                    with this specific route. The data property is accessible within each activated route.
                    Use it to store items such as page titles, breadcrumb text, and other read-only, static data.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    { path: 'heroes', component: HeroListComponent, data: { title: 'Heroes List' }
                </p>
			</div>
		</div>

		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>Router Events</p>
			</div>
			<div class="second_column table_column">
				<p>
                    If you need to see what events are happening during the navigation lifecycle,
                    there is the enableTracing option as part of the router's default configuration.
                    This outputs each router event that took place during each navigation lifecycle to the browser console.
                    This should only be used for debugging purposes. You set the enableTracing: true option in
                    the object passed as the second argument to the RouterModule.forRoot() method. <br><br>

                    During each navigation, the Router emits navigation events through the Router.events property.
                    These events range from when the navigation starts and ends to many points in between.
                    These events are logged to the console when the enableTracing option is enabled also.
                    The full list of navigation events is displayed in the table below. <br><br>

                    NavigationStart - An event triggered when navigation starts.<br><br>

                    RouteConfigLoadStart - An event triggered before the Router lazy loads a route configuration.<br><br>

                    RouteConfigLoadEnd - An event triggered after a route has been lazy loaded.<br><br>

                    RoutesRecognized - An event triggered when the Router parses the URL and the routes are recognized.<br><br>

                    GuardsCheckStart - An event triggered when the Router begins the Guards phase of routing.<br><br>

                    ChildActivationStart - An event triggered when the Router begins activating a route's children.<br><br>

                    ActivationStart - An event triggered when the Router begins activating a route.<br><br>

                    GuardsCheckEnd - An event triggered when the Router finishes the Guards phase of routing successfully.<br><br>

                    ResolveStart - An event triggered when the Router begins the Resolve phase of routing.<br><br>

                    ResolveEnd - An event triggered when the Router finishes the Resolve phase of routing successfuly.<br><br>

                    ChildActivationEnd - An event triggered when the Router finishes activating a route's children.<br><br>

                    ActivationEnd - An event triggered when the Router finishes activating a route.<br><br>

                    NavigationEnd - An event triggered when navigation ends successfully.<br><br>

                    NavigationCancel - An event triggered when navigation is canceled. This is due to a
                    Route Guard returning false during navigation.<br><br>

                    NavigationError - An event triggered when navigation fails due to an unexpected error.<br><br>

                    Scroll - An event that represents a scrolling event.
                </p>
			</div>
			<div class="third_column table_column">
				<p>
                    RouterModule.forRoot( <br>
                    appRoutes,<br>
                    { enableTracing: true } // <-- debugging purposes only )<br>
                    // other imports here ],<br>
                    ... })
                </p>
			</div>
		</div>

		<!-- -------------------------------------------------Guards------------------------------------------------------ -->

		<div class="anchor_row zebra3" id="guards">
			<h1>Guards</h1>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>CanActivate</p>
			</div>
			<div class="second_column table_column">
				<p>
					CanActivate is one of the guards types, which allows you to control access to a resource during routing.
					 CanActivate checks the ability to switch to a specific component. <br> <br>

					The class implements the CanActivate interface, namely its canActivate () method.
					 This method takes two parameters — the ActivatedRouteSnapshot and RouterStateSnapshot objects,
					  which contain information about the request. ActivatedRouteSnapshot allows you to get various information from a request,
					   including route parameters and query strings. <br> <br>

					The result of the method is a Boolean value, or a Boolean value wrapped in an Observable object.
					 If AboutGuard allows the transition, then the canActivate () method should return true. If access is denied, the method returns false.
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					About.guard.ts: <br><br>

					import {CanActivate, ActivatedRouteSnapshot, RouterStateSnapshot} from "@angular/router";<br>
					import {Observable} from "rxjs";<br><br>
					 
					export class AboutGuard implements CanActivate{<br><br>
					 
					    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) : Observable&ltboolean&gt | boolean{ <br><br>
					         
					        return confirm('Are you sure?');<br>
					    }<br>
					}<br><br><br>


					App.module.ts:<br><br>

					import { NgModule }      from '@angular/core';<br>
					import { BrowserModule } from '@angular/platform-browser';<br><br>
					  
					import {Routes, RouterModule} from '@angular/router';<br><br>
					  
					import { AppComponent }   from './app.component';<br>
					import { AboutComponent }   from './about.component';<br>
					import { HomeComponent }   from './home.component';<br>
					import { AboutGuard }   from './about.guard';<br><br>
					  
					// routes defining<br>
					const appRoutes: Routes =[<br>
					    { path: '', component: HomeComponent},<br>
					    { path: 'about', component: AboutComponent, canActivate: [AboutGuard]}<br>
					];<br><br>
					  
					@NgModule({<br>
					    imports:      [ BrowserModule, RouterModule.forRoot(appRoutes)],<br>
					    declarations: [ AppComponent, HomeComponent, AboutComponent],<br>
					    providers:    [AboutGuard],<br>
					    bootstrap:    [ AppComponent ]<br>
					})<br>
					export class AppModule { }

				</p>
			</div>
		</div>


		<div class="table_row zebra1">
			<div class="first_column table_column">
				<p>CanDeactivate</p>
			</div>
			<div class="second_column table_column">
				<p>
					CanDeactivate also allows you to manage transitions. It is intended for such cases when the user enters some data.
					 However, it does not leave them and leaves the page. In this case,
					  we could provide the user with a warning or a window confirming the transition.
					CanDeactivate checks the possibility of leaving a particular component. <br> <br>

					ExitAboutGuard must implement the canDeactivate() method of the CanDeactivate interface.
					 This method actually controls the transition to another component. <br> <br>

					To control the navigation, the component from which the transition is made is passed to this method. Due to this we can take into account the state of the component during the transition. But the parameter passed must implement a specific interface - in this case ComponentCanDeactivate. The name of the interface is not so important, as long as it defines the canDeactivate () method, which returns a boolean | Observable&ltboolean&gt. If the transition cannot be made, then false is returned; otherwise, true is returned. It may be just a Boolean value, or it may be a Boolean value wrapped in an Observable object. <br>
					Suppose we want to control the navigation from the AboutComponent component. In this case, the AboutComponent class should implement the ComponentCanDeactivate interface:
				</p>
			</div>
			<div class="third_column table_column">
				<p>
					Exit.about.guard.ts: <br><br>

					import {CanDeactivate} from "@angular/router";<br>
					import {Observable} from "rxjs";<br><br>
					 
					export interface ComponentCanDeactivate{<br>
					    canDeactivate: () =&gt; boolean | Observable&lt;boolean&gt;;<br>
					}<br><br>
					 
					export class ExitAboutGuard implements CanDeactivate&lt;ComponentCanDeactivate&gt;{<br><br>
					 
					    canDeactivate(component: ComponentCanDeactivate) : Observable&lt;boolean&gt; | boolean{<br><br>
					         
					        return component.canDeactivate ? component.canDeactivate() : true;<br>
					    }<br>
					}<br><br><br>

					About.component.ts:<br><br>

					import { Component} from '@angular/core';<br>
					import {ComponentCanDeactivate} from './exit.about.guard';<br>
					import {Observable} from "rxjs";<br><br>
					  
					@Component({<br>
					    selector: 'about-app',<br>
					    template: `&lt;h3&gt;About&lt;/h3&gt; <br>
					                &lt;button class="btn btn-default" (click)="save()"&gt;Save&lt;/button&gt;<br>
					                &lt;a routerLink=""&gt;To Home&lt;/a&gt;<br>
					                `<br>
					})<br><br>
					export class AboutComponent implements ComponentCanDeactivate { <br><br>
					    saved: boolean = false;<br><br>
					    save(){<br><br>
					        this.saved = true;<br>
					    }<br><br>
					     
					    canDeactivate() : boolean | Observable&lt;boolean&gt;{<br><br>
					     
					        if(!this.saved){<br>
					            return confirm("Вы хотите покинуть страницу?");<br>
					        }<br>
					        else{<br>
					            return true;<br>
					        }<br>
					    }<br>
					}<br><br><br>

					App.module:<br><br>

					import { NgModule }      from '@angular/core';<br>
					import { BrowserModule } from '@angular/platform-browser';<br><br>
					  
					import {Routes, RouterModule} from '@angular/router';<br><br>
					  
					import { AppComponent }   from './app.component';<br>
					import { AboutComponent }   from './about.component';<br>
					import { HomeComponent }   from './home.component';<br>
					import { AboutGuard }   from './about.guard';<br>
					import {ExitAboutGuard} from './exit.about.guard';<br><br>
					  
					const appRoutes: Routes =[<br>
					    { path: '', component: HomeComponent},<br>
					    { <br>
					        path: 'about', <br>
					        component: AboutComponent, <br>
					        canActivate: [AboutGuard],<br>
					        canDeactivate: [ExitAboutGuard]<br>
					    }<br>
					];<br><br>
					  
					@NgModule({<br>
					    imports:      [ BrowserModule, RouterModule.forRoot(appRoutes)],<br>
					    declarations: [ AppComponent, HomeComponent, AboutComponent],<br>
					    providers:    [ AboutGuard, ExitAboutGuard],<br>
					    bootstrap:    [ AppComponent ]<br>
					})<br><br>
					export class AppModule { }
				</p>
			</div>
		</div>

		<div class="table_row zebra2">
			<div class="first_column table_column">
				<p>CanActivateChild</p>
			</div>
			<div class="second_column table_column">
				<p>You can also protect child routes with the CanActivateChild guard. The CanActivateChild guard is similar to the CanActivate guard. The key difference is that it runs before any child route is activated.</p>
			</div>
			<div class="third_column table_column">
				<p></p>
			</div>
		</div>

		<footer>
			<h4>All Rights Reserved (c)</h4>
		</footer>
	</section>
</main>


<script src="scripts/search_angular.js"></script>
<script src="scripts/script.js"></script>

</body>
</html>